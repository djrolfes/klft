diff --git a/.gitignore b/.gitignore
index 753ced7..63ffe66 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,4 @@
 .vscode
 build
 *.code-workspace
-arc
+CMakePresets.json
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index fc0e493..2e40881 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,6 +1,5 @@
 cmake_minimum_required(VERSION 3.21.0)
 project(klft VERSION 0.0.1 LANGUAGES CXX)
-set(CMAKE_EXPORT_COMPILE_COMMANDS "ON")
 
 # Honor already set CMAKE_CXX_STANDARD.
 # Otherwise default to C++17
@@ -29,11 +28,15 @@ include_directories(${CMAKE_SOURCE_DIR}/include)
 # build the library
 add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/lib ${CMAKE_CURRENT_BINARY_DIR}/lib)
 
+# option to build the tests
+option(BUILD_TESTS "Build tests" ON)
+
+if(BUILD_TESTS)
+  add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests ${CMAKE_CURRENT_BINARY_DIR}/tests)
+endif()
+
 # build the binaries
 add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/binaries ${CMAKE_CURRENT_BINARY_DIR}/binaries)
 
 # build the benchmarks
 add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/benchmarks ${CMAKE_CURRENT_BINARY_DIR}/benchmarks)
-
-# build the tests
-add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests ${CMAKE_CURRENT_BINARY_DIR}/tests)
diff --git a/binaries/hmc.cpp b/binaries/hmc.cpp
index e06e017..48d9285 100644
--- a/binaries/hmc.cpp
+++ b/binaries/hmc.cpp
@@ -1,7 +1,8 @@
 
-#include "klft.hpp" // or wherever HMC_execute is declared
 #include <getopt.h>
 
+#include <filesystem>
+#include "klft.hpp"  // or wherever HMC_execute is declared
 using namespace klft;
 
 // we are hard coding the RNG now to use Kokkos::Random_XorShift64_Pool
@@ -11,17 +12,24 @@ using namespace klft;
 
 using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
 
-#define HLINE                                                                  \
+#define HLINE \
   "====================================================================\n"
 
-int parse_args(int argc, char **argv, std::string &input_file) {
+int parse_args(int argc,
+               char** argv,
+               std::string& input_file,
+               std::string& output_directory) {
   // Defaults
-  input_file = "input.yaml";
-
+  input_file = "../../../new_test.yaml";
+  output_directory = "./";
   const std::string help_string =
       "  -f <file_name> --filename <file_name>\n"
       "     Name of the input file.\n"
       "     Default: input.yaml\n"
+      "  -o <file_name> --output <file_name>\n"
+      "     Path to the output folder.\n"
+      "     Hint: if the folder does not exist, it will be created.\n"
+      "     Default: .\n"
       "  -h, --help\n"
       "     Prints this message.\n"
       "     Hint: use --kokkos-help to see command line options provided by "
@@ -29,32 +37,42 @@ int parse_args(int argc, char **argv, std::string &input_file) {
 
   static struct option long_options[] = {
       {"filename", required_argument, NULL, 'f'},
+      {"output", required_argument, NULL, 'o'},
       {"help", no_argument, NULL, 'h'},
       {NULL, 0, NULL, 0}};
 
   int c;
   int option_index = 0;
-  while ((c = getopt_long(argc, argv, "f:h", long_options, &option_index)) !=
+  while ((c = getopt_long(argc, argv, "f:o:h", long_options, &option_index)) !=
          -1)
     switch (c) {
-    case 'f':
-      input_file = optarg;
-      break;
-    case 'h':
-      printf("%s", help_string.c_str());
-      return -2;
-      break;
-    case 0:
-      break;
-    default:
-      printf("%s", help_string.c_str());
-      return -1;
-      break;
+      case 'f':
+        input_file = optarg;
+        break;
+      case 'o':
+        output_directory = optarg;
+        if (output_directory.back() != '/') {
+          output_directory += '/';
+        }
+        if (!std::filesystem::exists(output_directory)) {
+          std::filesystem::create_directories(output_directory);
+        }
+        break;
+      case 'h':
+        printf("%s", help_string.c_str());
+        return -2;
+        break;
+      case 0:
+        break;
+      default:
+        printf("%s", help_string.c_str());
+        return -1;
+        break;
     }
   return 0;
 }
 
-int main(int argc, char *argv[]) {
+int main(int argc, char* argv[]) {
   printf(HLINE);
   printf("HMC for SU(N) gauge fields\n");
   printf(HLINE);
@@ -62,9 +80,10 @@ int main(int argc, char *argv[]) {
   Kokkos::initialize(argc, argv);
   int rc;
   std::string input_file;
-  rc = parse_args(argc, argv, input_file);
+  std::string output_directory;
+  rc = parse_args(argc, argv, input_file, output_directory);
   if (rc == 0) {
-    rc = HMC_execute(input_file);
+    rc = HMC_execute(input_file, output_directory);
   } else if (rc == -2) {
     // Don't return error code when called with "-h"
     rc = 0;
diff --git a/binaries/metropolis.cpp b/binaries/metropolis.cpp
index a125097..fb89a37 100644
--- a/binaries/metropolis.cpp
+++ b/binaries/metropolis.cpp
@@ -20,9 +20,9 @@
 // this file performs metropolis for gauge fields
 // for different dimensions and gauge groups
 
-#include "klft.hpp"
 #include <getopt.h>
-
+#include <filesystem>
+#include "klft.hpp"
 using namespace klft;
 
 // we are hard coding the RNG now to use Kokkos::Random_XorShift64_Pool
@@ -32,16 +32,24 @@ using namespace klft;
 
 using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
 
-#define HLINE "====================================================================\n"
+#define HLINE \
+  "====================================================================\n"
 
-int parse_args(int argc, char **argv, std::string &input_file) {
+int parse_args(int argc,
+               char** argv,
+               std::string& input_file,
+               std::string& output_directory) {
   // Defaults
-  input_file = "input.yaml";
-
+  input_file = "../../../new_test.yaml";
+  output_directory = "./";
   const std::string help_string =
       "  -f <file_name> --filename <file_name>\n"
       "     Name of the input file.\n"
       "     Default: input.yaml\n"
+      "  -o <file_name> --output <file_name>\n"
+      "     Path to the output folder.\n"
+      "     Hint: if the folder does not exist, it will be created.\n"
+      "     Default: .\n"
       "  -h, --help\n"
       "     Prints this message.\n"
       "     Hint: use --kokkos-help to see command line options provided by "
@@ -49,20 +57,33 @@ int parse_args(int argc, char **argv, std::string &input_file) {
 
   static struct option long_options[] = {
       {"filename", required_argument, NULL, 'f'},
+      {"output", optional_argument, NULL, 'o'},
       {"help", no_argument, NULL, 'h'},
       {NULL, 0, NULL, 0}};
 
   int c;
   int option_index = 0;
-  while ((c = getopt_long(argc, argv, "f:h", long_options, &option_index)) !=
+  while ((c = getopt_long(argc, argv, "f:o:h", long_options, &option_index)) !=
          -1)
     switch (c) {
-      case 'f': input_file = optarg; break;
+      case 'f':
+        input_file = optarg;
+        break;
+      case 'o':
+        output_directory = optarg;
+        if (output_directory.back() != '/') {
+          output_directory += '/';
+        }
+        if (!std::filesystem::exists(output_directory)) {
+          std::filesystem::create_directories(output_directory);
+        }
+        break;
       case 'h':
         printf("%s", help_string.c_str());
         return -2;
         break;
-      case 0: break;
+      case 0:
+        break;
       default:
         printf("%s", help_string.c_str());
         return -1;
@@ -71,7 +92,7 @@ int parse_args(int argc, char **argv, std::string &input_file) {
   return 0;
 }
 
-int main(int argc, char *argv[]) {
+int main(int argc, char* argv[]) {
   printf(HLINE);
   printf("Metropolis for SU(N) gauge fields\n");
   printf(HLINE);
@@ -79,9 +100,10 @@ int main(int argc, char *argv[]) {
   Kokkos::initialize(argc, argv);
   int rc;
   std::string input_file;
-  rc = parse_args(argc, argv, input_file);
+  std::string output_directory;
+  rc = parse_args(argc, argv, input_file, output_directory);
   if (rc == 0) {
-    rc = Metropolis(input_file);
+    rc = Metropolis(input_file, output_directory);
   } else if (rc == -2) {
     // Don't return error code when called with "-h"
     rc = 0;
diff --git a/include/AdjointField.hpp b/include/AdjointField.hpp
index b138f75..1951614 100644
--- a/include/AdjointField.hpp
+++ b/include/AdjointField.hpp
@@ -9,20 +9,20 @@
 
 namespace klft {
 
-template <size_t Nd, size_t Nc> struct deviceAdjointField {
-
+template <size_t Nd, size_t Nc>
+struct deviceAdjointField {
   deviceAdjointField() = delete;
 
   SUNAdjField<Nd, Nc> field;
   IndexArray<Nd> dimensions;
 
   deviceAdjointField(const index_t L0, const index_t L1, const index_t L2,
-                     const index_t L3, const SUNAdj<Nc> &init)
+                     const index_t L3, const SUNAdj<Nc>& init)
       : dimensions({L0, L1, L2, L3}) {
     do_init(field, init);
   }
 
-  void do_init(SUNAdjField<Nd, Nc> &V, const SUNAdj<Nc> &init) {
+  void do_init(SUNAdjField<Nd, Nc>& V, const SUNAdj<Nc>& init) {
     Kokkos::realloc(Kokkos::WithoutInitializing, V, dimensions[0],
                     dimensions[1], dimensions[2], dimensions[3]);
     Kokkos::fence();
@@ -38,65 +38,69 @@ template <size_t Nd, size_t Nc> struct deviceAdjointField {
     Kokkos::fence();
   }
 
-  template <class RNG> void randomize_field(RNG &rng) {
-    auto self = field;
-    tune_and_launch_for(
-        "randomize_adj_field", IndexArray<Nd>{0}, dimensions,
-        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
-                      const index_t i3) {
-          auto generator = rng.get_state();
-          for (index_t mu = 0; mu < Nd; ++mu) {
-            randSUNAdj<Nc>(self(i0, i1, i2, i3, mu), generator);
-          }
-          rng.free_state(generator);
-        });
-    Kokkos::fence();
-  }
-
   // define accessors for the field
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const indexType i, const indexType j, const indexType k,
-             const indexType l, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(const indexType i,
+                                                     const indexType j,
+                                                     const indexType k,
+                                                     const indexType l,
+                                                     const index_t mu) const {
     return field(i, j, k, l, mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const indexType i, const indexType j, const indexType k,
-             const indexType l, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(const indexType i,
+                                                     const indexType j,
+                                                     const indexType k,
+                                                     const indexType l,
+                                                     const index_t mu) {
     return field(i, j, k, l, mu);
   }
 
   // define accessors with 4D Kokkos array
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const Kokkos::Array<indexType, 4> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(
+      const Kokkos::Array<indexType, 4> site, const index_t mu) const {
     return field(site[0], site[1], site[2], site[3], mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const Kokkos::Array<indexType, 4> site, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(
+      const Kokkos::Array<indexType, 4> site, const index_t mu) {
     return field(site[0], site[1], site[2], site[3], mu);
   }
-};
 
-template <size_t Nd, size_t Nc> struct deviceAdjointField3D {
+  template <class RNG>
+  void randomize_field(RNG& rng) {
+    tune_and_launch_for(
+        "randomize_adj_field", IndexArray<Nd>{0}, dimensions,
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+          auto generator = rng.get_state();
+          for (index_t mu = 0; mu < Nd; ++mu) {
+            randSUNAdj<Nc>((*this)(i0, i1, i2, i3, mu), generator);
+          }
+          rng.free_state(generator);
+        });
+  }
+};
 
+template <size_t Nd, size_t Nc>
+struct deviceAdjointField3D {
   deviceAdjointField3D() = delete;
 
   SUNAdjField3D<Nd, Nc> field;
   IndexArray<Nd> dimensions;
 
   deviceAdjointField3D(const index_t L0, const index_t L1, const index_t L2,
-                       const SUNAdj<Nc> &init)
+                       const SUNAdj<Nc>& init)
       : dimensions({L0, L1, L2}) {
     do_init(field, init);
   }
-  void do_init(SUNAdjField3D<Nd, Nc> &V, const SUNAdj<Nc> &init) {
+  void do_init(SUNAdjField3D<Nd, Nc>& V, const SUNAdj<Nc>& init) {
     Kokkos::realloc(Kokkos::WithoutInitializing, V, dimensions[0],
                     dimensions[1], dimensions[2]);
+    Kokkos::fence();
     tune_and_launch_for(
         "init_DeviceAdjointField", IndexArray<Nd>{0}, dimensions,
         KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2) {
@@ -105,16 +109,17 @@ template <size_t Nd, size_t Nc> struct deviceAdjointField3D {
             V(i0, i1, i2, mu) = init;
           }
         });
+    Kokkos::fence();
   }
 
-  template <class RNG> void randomize_field(RNG &rng) {
-    auto self = field;
+  template <class RNG>
+  void randomize_field(RNG& rng) {
     tune_and_launch_for(
         "randomize_adj_field", IndexArray<Nd>{0}, dimensions,
         KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2) {
           auto generator = rng.get_state();
           for (index_t mu = 0; mu < Nd; ++mu) {
-            randSUNAdj<Nc>(self(i0, i1, i2, mu), generator);
+            randSUNAdj<Nc>((*this)(i0, i1, i2, mu), generator);
           }
           rng.free_state(generator);
         });
@@ -123,48 +128,51 @@ template <size_t Nd, size_t Nc> struct deviceAdjointField3D {
 
   // define accessors for the field
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const indexType i, const indexType j, const indexType k,
-             const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(const indexType i,
+                                                     const indexType j,
+                                                     const indexType k,
+                                                     const index_t mu) const {
     return field(i, j, k, mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const indexType i, const indexType j, const indexType k,
-             const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(const indexType i,
+                                                     const indexType j,
+                                                     const indexType k,
+                                                     const index_t mu) {
     return field(i, j, k, mu);
   }
 
   // define accessors with 4D Kokkos array
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const Kokkos::Array<indexType, 3> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(
+      const Kokkos::Array<indexType, 3> site, const index_t mu) const {
     return field(site[0], site[1], site[2], mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const Kokkos::Array<indexType, 3> site, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(
+      const Kokkos::Array<indexType, 3> site, const index_t mu) {
     return field(site[0], site[1], site[2], mu);
   }
 };
 
-template <size_t Nd, size_t Nc> struct deviceAdjointField2D {
-
+template <size_t Nd, size_t Nc>
+struct deviceAdjointField2D {
   deviceAdjointField2D() = delete;
 
   SUNAdjField2D<Nd, Nc> field;
   IndexArray<Nd> dimensions;
 
   deviceAdjointField2D(const index_t L0, const index_t L1,
-                       const SUNAdj<Nc> &init)
+                       const SUNAdj<Nc>& init)
       : dimensions({L0, L1}) {
     do_init(field, init);
   }
-  void do_init(SUNAdjField2D<Nd, Nc> &V, const SUNAdj<Nc> &init) {
+  void do_init(SUNAdjField2D<Nd, Nc>& V, const SUNAdj<Nc>& init) {
     Kokkos::realloc(Kokkos::WithoutInitializing, V, dimensions[0],
                     dimensions[1]);
+    Kokkos::fence();
     tune_and_launch_for(
         "init_DeviceAdjointField", IndexArray<Nd>{0}, dimensions,
         KOKKOS_LAMBDA(const index_t i0, const index_t i1) {
@@ -173,16 +181,17 @@ template <size_t Nd, size_t Nc> struct deviceAdjointField2D {
             V(i0, i1, mu) = init;
           }
         });
+    Kokkos::fence();
   }
 
-  template <class RNG> void randomize_field(RNG &rng) {
-    auto self = field;
+  template <class RNG>
+  void randomize_field(RNG& rng) {
     tune_and_launch_for(
         "randomize_adj_field", IndexArray<Nd>{0}, dimensions,
         KOKKOS_LAMBDA(const index_t i0, const index_t i1) {
           auto generator = rng.get_state();
           for (index_t mu = 0; mu < Nd; ++mu) {
-            randSUNAdj<Nc>(self(i0, i1, mu), generator);
+            randSUNAdj<Nc>((*this)(i0, i1, mu), generator);
           }
           rng.free_state(generator);
         });
@@ -191,28 +200,30 @@ template <size_t Nd, size_t Nc> struct deviceAdjointField2D {
 
   // define accessors for the field
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const indexType i, const indexType j, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(const indexType i,
+                                                     const indexType j,
+                                                     const index_t mu) const {
     return field(i, j, mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const indexType i, const indexType j, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(const indexType i,
+                                                     const indexType j,
+                                                     const index_t mu) {
     return field(i, j, mu);
   }
 
   // define accessors with 4D Kokkos array
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const Kokkos::Array<indexType, 2> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(
+      const Kokkos::Array<indexType, 2> site, const index_t mu) const {
     return field(site[0], site[1], mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> &
-  operator()(const Kokkos::Array<indexType, 2> site, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc>& operator()(
+      const Kokkos::Array<indexType, 2> site, const index_t mu) {
     return field(site[0], site[1], mu);
   }
 };
-} // namespace klft
+}  // namespace klft
diff --git a/include/AdjointFieldHelper.hpp b/include/AdjointFieldHelper.hpp
new file mode 100644
index 0000000..501ea5e
--- /dev/null
+++ b/include/AdjointFieldHelper.hpp
@@ -0,0 +1,37 @@
+#pragma once
+#include "AdjointField.hpp"
+#include "FieldTypeHelper.hpp"
+#include "GLOBAL.hpp"
+namespace klft {
+template <typename DAdjFieldType, class RNG>
+void randomize_field(typename DAdjFieldType::type& field, RNG& rng) {
+  size_t constexpr Nd = DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank;
+  size_t constexpr Nc = DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc;
+  tune_and_launch_for(
+      "randomize_adj_field", IndexArray<Nd>{0}, field.dimensions,
+      KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                    const index_t i3) {
+        auto generator = rng.get_state();
+        for (index_t mu = 0; mu < Nd; ++mu) {
+          randSUNAdj<Nc>(field(i0, i1, i2, i3, mu), generator);
+        }
+        rng.free_state(generator);
+      });
+  Kokkos::fence();
+}
+
+template <typename DAdjFieldType>
+void flip_sign(typename DAdjFieldType::type& field) {
+  size_t constexpr Nd = DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank;
+  size_t constexpr Nc = DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc;
+  tune_and_launch_for(
+      "randomize_adj_field", IndexArray<Nd>{0}, field.dimensions,
+      KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                    const index_t i3) {
+        for (index_t mu = 0; mu < Nd; ++mu) {
+          flip_sign<Nc>(field(i0, i1, i2, i3, mu));
+        }
+      });
+  Kokkos::fence();
+}
+}  // namespace klft
diff --git a/include/AdjointSUN.hpp b/include/AdjointSUN.hpp
index 9c98530..8723327 100644
--- a/include/AdjointSUN.hpp
+++ b/include/AdjointSUN.hpp
@@ -12,9 +12,18 @@ namespace klft {
 //   static constexpr size_t Nc = _Nc;
 // };
 
+template <size_t Nc>
+KOKKOS_FORCEINLINE_FUNCTION void print_SUNAdj(
+    const SUNAdj<Nc>& a, const std::string& name = "SUNAdj:") {
+  printf("%s\n", name.c_str());
+  for (size_t i = 0; i < Nc * Nc - 1; ++i) {
+    printf("    [%zu] = (% .20f)\n", i, a[i]);
+  }
+}
+
 template <size_t Nc, typename Tin>
-KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator*(const SUNAdj<Nc> &a,
-                                                 const Tin &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator*(const SUNAdj<Nc>& a,
+                                                 const Tin& b) {
   SUNAdj<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
@@ -24,14 +33,14 @@ KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator*(const SUNAdj<Nc> &a,
 }
 
 template <size_t Nc, typename Tin>
-KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator*(const Tin &b,
-                                                 const SUNAdj<Nc> &a) {
+KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator*(const Tin& b,
+                                                 const SUNAdj<Nc>& a) {
   return a * b;
 }
 
 template <size_t Nc, typename Tin>
-KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> multSUNAdj(const SUNAdj<Nc> &a,
-                                                  const Tin &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> multSUNAdj(const SUNAdj<Nc>& a,
+                                                  const Tin& b) {
   SUNAdj<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
@@ -41,7 +50,7 @@ KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> multSUNAdj(const SUNAdj<Nc> &a,
 }
 
 template <size_t Nc, typename Tin>
-KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUNAdj<Nc> &a, const Tin &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUNAdj<Nc>& a, const Tin& b) {
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
     a[i] *= b;
@@ -49,8 +58,8 @@ KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUNAdj<Nc> &a, const Tin &b) {
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator+(const SUNAdj<Nc> &a,
-                                                 const SUNAdj<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator+(const SUNAdj<Nc>& a,
+                                                 const SUNAdj<Nc>& b) {
   SUNAdj<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
@@ -60,8 +69,8 @@ KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator+(const SUNAdj<Nc> &a,
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION void operator+=(SUNAdj<Nc> &a,
-                                            const SUNAdj<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator+=(SUNAdj<Nc>& a,
+                                            const SUNAdj<Nc>& b) {
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
     a[i] += b[i];
@@ -69,8 +78,8 @@ KOKKOS_FORCEINLINE_FUNCTION void operator+=(SUNAdj<Nc> &a,
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator-(const SUNAdj<Nc> &a,
-                                                 const SUNAdj<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator-(const SUNAdj<Nc>& a,
+                                                 const SUNAdj<Nc>& b) {
   SUNAdj<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
@@ -80,16 +89,23 @@ KOKKOS_FORCEINLINE_FUNCTION SUNAdj<Nc> operator-(const SUNAdj<Nc> &a,
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION void operator-=(SUNAdj<Nc> &a,
-                                            const SUNAdj<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator-=(SUNAdj<Nc>& a,
+                                            const SUNAdj<Nc>& b) {
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
     a[i] -= b[i];
   }
 }
+template <size_t Nc>
+KOKKOS_FORCEINLINE_FUNCTION void flip_sign(SUNAdj<Nc>& a) {
+#pragma unroll
+  for (size_t i = 0; i < NcAdj<Nc>; ++i) {
+    a[i] = -1 * a[i];
+  }
+}
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION real_t norm2(const SUNAdj<Nc> &a) {
+KOKKOS_FORCEINLINE_FUNCTION real_t norm2(const SUNAdj<Nc>& a) {
   real_t c = 0.0;
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
@@ -100,7 +116,7 @@ KOKKOS_FORCEINLINE_FUNCTION real_t norm2(const SUNAdj<Nc> &a) {
 
 // random SUNAdj matrix generator
 template <size_t Nc, class RNG>
-KOKKOS_FORCEINLINE_FUNCTION void randSUNAdj(SUNAdj<Nc> &r, RNG &generator) {
+KOKKOS_FORCEINLINE_FUNCTION void randSUNAdj(SUNAdj<Nc>& r, RNG& generator) {
 #pragma unroll
   for (size_t i = 0; i < NcAdj<Nc>; ++i) {
     r[i] = generator.normal(0.0, 1.0);
@@ -110,14 +126,14 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUNAdj(SUNAdj<Nc> &r, RNG &generator) {
 // get the adjoint from an SU(N) matrix
 // nneds to be defined for each Nc
 KOKKOS_FORCEINLINE_FUNCTION
-SUNAdj<1> traceT(const SUN<1> &a) {
+SUNAdj<1> traceT(const SUN<1>& a) {
   SUNAdj<1> c;
   c[0] = a[0][0].imag();
   return c;
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-SUNAdj<2> traceT(const SUN<2> &a) {
+SUNAdj<2> traceT(const SUN<2>& a) {
   SUNAdj<2> c;
   c[0] = 2.0 * a[0][1].imag();
   c[1] = 2.0 * a[0][1].real();
@@ -126,7 +142,7 @@ SUNAdj<2> traceT(const SUN<2> &a) {
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-SUNAdj<3> traceT(const SUN<3> &a) {
+SUNAdj<3> traceT(const SUN<3>& a) {
   SUNAdj<3> c;
   c[0] = 0.5 * (-a[0][1].imag() - a[1][0].imag());
   c[1] = 0.5 * (a[1][0].real() - a[0][1].real());
@@ -143,18 +159,15 @@ SUNAdj<3> traceT(const SUN<3> &a) {
 // exponential of an adjoint matrix
 // needs to be defined for each Nc
 KOKKOS_FORCEINLINE_FUNCTION
-SUN<1> expoSUN(const SUNAdj<1> &a) {
+SUN<1> expoSUN(const SUNAdj<1>& a) {
   SUN<1> c;
   c[0][0] = complex_t(Kokkos::cos(a[0]), Kokkos::sin(a[0]));
   return c;
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-SUN<2> expoSUN(const SUNAdj<2> &a) {
+SUN<2> expoSUN(const SUNAdj<2>& a) {
   const real_t alpha = Kokkos::sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
-  constexpr real_t tiny = real_t(100) * std::numeric_limits<real_t>::epsilon();
-  if (alpha < tiny)
-    return identitySUN<2>();
   const Kokkos::Array<real_t, 3> u = {a[0] / alpha, a[1] / alpha, a[2] / alpha};
   const real_t sin_alpha = Kokkos::sin(alpha);
   SUN<2> c;
@@ -191,7 +204,7 @@ SUN<2> expoSUN(const SUNAdj<2> &a) {
 //   }
 //   return coeffs;
 // }();
-//
+
 // // a function to generate SU(3) matrix from adjoint
 // constexpr KOKKOS_FORCEINLINE_FUNCTION SUN<3>
 // get_SU3_from_adj(const SUNAdj<3> &a) {
@@ -207,7 +220,7 @@ SUN<2> expoSUN(const SUNAdj<2> &a) {
 //   c[2][2] = complex_t(0.0, -SQRT3INV * a[7]);
 //   return c;
 // }
-//
+
 // // we also need the determinant of the SU(3) matrix
 // // returns i det(a)
 // constexpr KOKKOS_FORCEINLINE_FUNCTION real_t imag_det_SU3(const SUNAdj<3> &a)
@@ -220,7 +233,7 @@ SUN<2> expoSUN(const SUNAdj<2> &a) {
 //        2.0 * SQRT3INV * a[7] * (a[0] * a[0] + a[1] * a[1]);
 //   return d;
 // }
-//
+
 // KOKKOS_FORCEINLINE_FUNCTION
 // SUN<3> expoSUN(const SUNAdj<3> &a) {
 //   // Cayley-Hamilton expansion
@@ -240,7 +253,7 @@ SUN<2> expoSUN(const SUNAdj<2> &a) {
 //   // store a in a temporary variable
 //   // to perform the numerical stability step
 //   // a_tmp = a
-//   SUNadj<3> a_tmp = a;
+//   SUNAdj<3> a_tmp = a;
 //   // mm stores the number of times we need to
 //   // multiply by 0.5
 //   size_t mm = 0;
@@ -299,4 +312,4 @@ SUN<2> expoSUN(const SUNAdj<2> &a) {
 //   return pt;
 // }
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/FermionMonomial.hpp b/include/FermionMonomial.hpp
new file mode 100644
index 0000000..d59b615
--- /dev/null
+++ b/include/FermionMonomial.hpp
@@ -0,0 +1,90 @@
+
+#pragma once
+#include "GDiracOperator.hpp"
+#include "GLOBAL.hpp"
+#include "Monomial.hpp"
+#include "Solver.hpp"
+#include "SpinorFieldLinAlg.hpp"
+
+#define SQRT2INV \
+  0.707106781186547524400844362104849039284835937688474036588339868995366239231053519425193767163820786367506  // Oeis A010503
+namespace klft {
+template <typename DiracOperator, class Solver, class RNGType,
+          typename DFermionFieldType, typename DGaugeFieldType,
+          typename DAdjFieldType>
+class FermionMonomial : public Monomial<DGaugeFieldType, DAdjFieldType> {
+  static_assert(isDeviceFermionFieldType<DFermionFieldType>::value);
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
+  constexpr static size_t rank =
+      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
+  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DFermionFieldType>::RepDim;
+  static_assert(rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank &&
+                    rank ==
+                        DeviceFermionFieldTypeTraits<DFermionFieldType>::Rank &&
+                    Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc &&
+                    Nc == DeviceFermionFieldTypeTraits<DFermionFieldType>::Nc,
+                "Rank and Nc must match between gauge, adjoint, and fermion "
+                "field types.");
+  using FermionField = typename DFermionFieldType::type;
+
+ public:
+  FermionField& phi;
+  const diracParams<rank, RepDim> params;
+  const real_t tol;
+  RNGType rng;
+  FermionMonomial(FermionField& _phi, const diracParams<rank, RepDim>& params_,
+                  const real_t& tol_, RNGType& RNG_, unsigned int _time_scale)
+      : Monomial<DGaugeFieldType, DAdjFieldType>(_time_scale),
+        phi(_phi),
+        params(params_),
+        rng(RNG_),
+        tol(tol_) {
+    Monomial<DGaugeFieldType, DAdjFieldType>::monomial_type =
+        KLFT_MONOMIAL_FERMION;
+  }
+
+  void heatbath(HamiltonianField<DGaugeFieldType, DAdjFieldType> h) override {
+    auto dims = h.gauge_field.dimensions;
+
+    // print_spinor_int(this->phi(0, 0, 0, 0),
+    //                  "Spinor s_in(0,0,0,0)  before Heatbath");
+    // print_SUN(h.gauge_field(0, 0, 0, 0, 0), "SUN in Fermion heatbath");
+    FermionField R(dims, rng, 0, SQRT2INV);
+    // print_spinor_int(R(0, 0, 0, 0), "Spinor R(0,0,0,0) before dirac op in
+    // Heatbath");
+    Monomial<DGaugeFieldType, DAdjFieldType>::H_old =
+        spinor_norm_sq<rank, Nc, RepDim>(R);
+    DiracOperator dirac_op(h.gauge_field, params);
+    dirac_op.applyD_inplace(R, this->phi);
+    // print_spinor_int(this->phi(0, 0, 0, 0),
+    //                  "Spinor s_in(0,0,0,0) after  Heatbath");
+  }
+
+  void accept(HamiltonianField<DGaugeFieldType, DAdjFieldType> h) override {
+    auto dims = h.gauge_field.dimensions;
+    // print_SUN(h.gauge_field(0, 0, 0, 0, 0), "SUN in Fermion accept");
+
+    FermionField x(dims, complex_t(0.0, 0.0));
+    FermionField x0(dims, complex_t(0.0, 0.0));
+    DiracOperator dirac_op(h.gauge_field, params);
+    Solver solver(this->phi, x, dirac_op);
+    if (KLFT_VERBOSITY > 4) {
+      printf("Solving inside Fermion Monomial accept:");
+    }
+
+    solver.solve(x0, this->tol);
+    const FermionField chi = solver.x;
+    // print_spinor_int(this->phi(0, 0, 0, 0), "Phi field in acceot step");
+    Monomial<DGaugeFieldType, DAdjFieldType>::H_new =
+        spinor_dot_product<rank, Nc, RepDim>(this->phi, chi).real();
+    // print_SUNAdj(h.adjoint_field(0, 0, 0, 0, 0),
+    //              "SUNAdj at accept Monomial Fermion");
+  }
+  void print() override {
+    printf("Fermion Monomial: %.20f\n", this->get_delta_H());
+  }
+};
+}  // namespace klft
diff --git a/include/FermionParams.hpp b/include/FermionParams.hpp
new file mode 100644
index 0000000..533ac39
--- /dev/null
+++ b/include/FermionParams.hpp
@@ -0,0 +1,79 @@
+#pragma once
+#include "FieldTypeHelper.hpp"
+#include "GLOBAL.hpp"
+#include "GammaMatrix.hpp"
+#include "HMC_Params.hpp"
+
+namespace klft {
+
+// Parameters specific to the Dirac operator
+template <size_t rank, size_t RepDim>
+struct diracParams {
+  using VecGammaMatrix = Kokkos::Array<GammaMat<RepDim>, 4>;
+  const VecGammaMatrix gammas;
+  const GammaMat<RepDim> gamma_id = get_identity<RepDim>();
+  const GammaMat<RepDim> gamma5;
+  const real_t kappa;
+  const IndexArray<rank> dimensions;
+  diracParams(const IndexArray<rank> _dimensions,
+              const VecGammaMatrix& _gammas,
+              const GammaMat<RepDim>& _gamma5,
+              const real_t& _kappa)
+      : dimensions(_dimensions),
+        gammas(_gammas),
+        gamma5(_gamma5),
+        kappa(_kappa) {}
+};
+
+struct FermionParams {
+  std::string fermion_type;
+  std::string Solver;
+  size_t rank;
+  size_t Nc;
+  size_t RepDim;
+  real_t kappa;
+  real_t tol;
+  FermionParams(size_t _rank,
+                size_t _Nc,
+                size_t _RepDim,
+                real_t _kappa,
+                real_t _tol,
+                const std::string& _fermion_type = "Wilson")
+      : rank(_rank),
+        Nc(_Nc),
+        RepDim(_RepDim),
+        kappa(_kappa),
+        tol(_tol),
+        fermion_type(_fermion_type) {}
+  FermionParams() = default;
+  void print() const {
+    printf("Fermion Parameter:\n");
+    printf("  Fermion Type: %s\n", fermion_type.c_str());
+    printf("  Solver: %s\n", Solver.c_str());
+    printf("  Rank: %zu\n", rank);
+    printf("  Nc: %zu\n", Nc);
+    printf("  RepDim: %zu\n", RepDim);
+    printf("  Kappa: %f\n", kappa);
+    printf("  Tolerance: %f\n", tol);
+  }
+};
+template <size_t rank>
+auto getDiracParams(const IndexArray<rank>& dimensions,
+                    const FermionMonomial_Params& fparams) {
+  if (fparams.RepDim == 4) {
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    diracParams<rank, 4> dParams(dimensions, gammas, gamma5, fparams.kappa);
+    return dParams;
+
+  } else {
+    printf("Warning: Unsupported Gamma Matrix Representation\n");
+    printf("Warning: Fallback RepDim = 4\n");
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    diracParams<rank, 4> dParams(dimensions, gammas, gamma5, fparams.kappa);
+    return dParams;
+  }
+}
+
+}  // namespace klft
diff --git a/include/FieldTypeHelper.hpp b/include/FieldTypeHelper.hpp
index 85981a9..c1d4b8e 100644
--- a/include/FieldTypeHelper.hpp
+++ b/include/FieldTypeHelper.hpp
@@ -23,18 +23,20 @@
 // dimensionality from Nd, you can not use the definitions here
 
 #pragma once
+
 #include "AdjointField.hpp"
 #include "Field.hpp"
 #include "GaugeField.hpp"
 #include "PTBCGaugeField.hpp"
 #include "SUNField.hpp"
 #include "ScalarField.hpp"
-#include <cstddef>
+#include "SpinorField.hpp"
 
 namespace klft {
 // define GaugeFieldKinds
 enum class GaugeFieldKind { Standard, PTBC };
 
+enum class SpinorFieldKind { Standard, Staggered };
 // define a function to get the gauge field type based on the rank,
 // with the default Field being the default GaugeField
 template <size_t rank, size_t Nc, GaugeFieldKind k = GaugeFieldKind::Standard>
@@ -56,21 +58,37 @@ struct DeviceGaugeFieldType<4, Nc, GaugeFieldKind::Standard> {
   using type = deviceGaugeField<4, Nc>;
 };
 
+// now do the same for the SpinorField field types
+template <size_t rank,
+          size_t Nc,
+          size_t RepDim,
+          SpinorFieldKind k = SpinorFieldKind::Standard>
+struct DeviceSpinorFieldType;
+
+template <size_t Nc>
+struct DeviceSpinorFieldType<4, Nc, 4, SpinorFieldKind::Standard> {
+  using type = deviceSpinorField<Nc, 4>;
+};
+
 // now do the same for the PTBC gauge field types
-template <size_t Nc> struct DeviceGaugeFieldType<4, Nc, GaugeFieldKind::PTBC> {
+template <size_t Nc>
+struct DeviceGaugeFieldType<4, Nc, GaugeFieldKind::PTBC> {
   using type = devicePTBCGaugeField<4, Nc>;
 };
 
-template <size_t Nc> struct DeviceGaugeFieldType<3, Nc, GaugeFieldKind::PTBC> {
+template <size_t Nc>
+struct DeviceGaugeFieldType<3, Nc, GaugeFieldKind::PTBC> {
   using type = devicePTBCGaugeField3D<3, Nc>;
 };
 
-template <size_t Nc> struct DeviceGaugeFieldType<2, Nc, GaugeFieldKind::PTBC> {
+template <size_t Nc>
+struct DeviceGaugeFieldType<2, Nc, GaugeFieldKind::PTBC> {
   using type = devicePTBCGaugeField2D<2, Nc>;
 };
 
 // define Traits to extract the rank, Nc and GaugeFieldKind at a later point
-template <typename T> struct DeviceGaugeFieldTypeTraits;
+template <typename T>
+struct DeviceGaugeFieldTypeTraits;
 
 template <size_t _rank, size_t _Nc, GaugeFieldKind _k>
 struct DeviceGaugeFieldTypeTraits<DeviceGaugeFieldType<_rank, _Nc, _k>> {
@@ -80,30 +98,55 @@ struct DeviceGaugeFieldTypeTraits<DeviceGaugeFieldType<_rank, _Nc, _k>> {
 };
 
 // compile time check for the appropriate types
-template <typename T> struct isDeviceGaugeFieldType : std::false_type {};
+template <typename T>
+struct isDeviceGaugeFieldType : std::false_type {};
+
+template <typename T>
+struct isDeviceFermionFieldType : std::false_type {};
 
 template <size_t rank, size_t Nc, GaugeFieldKind k>
 struct isDeviceGaugeFieldType<DeviceGaugeFieldType<rank, Nc, k>>
     : std::true_type {};
 
+template <size_t rank, size_t Nc, size_t RepDim, SpinorFieldKind k>
+struct isDeviceFermionFieldType<DeviceSpinorFieldType<rank, Nc, RepDim, k>>
+    : std::true_type {};
+
+template <typename T>
+struct DeviceFermionFieldTypeTraits;
+
+template <size_t _rank, size_t _Nc, size_t _RepDim, SpinorFieldKind _k>
+struct DeviceFermionFieldTypeTraits<
+    DeviceSpinorFieldType<_rank, _Nc, _RepDim, _k>> {
+  static constexpr size_t Rank = _rank;
+  static constexpr size_t Nc = _Nc;
+  static constexpr size_t RepDim = _RepDim;
+  static constexpr SpinorFieldKind Kind = _k;
+};
+
 // define a function to get the gauge field type based on the rank,
 // with the default Field being the default GaugeField
-template <size_t rank, size_t Nc> struct DeviceAdjFieldType;
+template <size_t rank, size_t Nc>
+struct DeviceAdjFieldType;
 
-template <size_t Nc> struct DeviceAdjFieldType<4, Nc> {
+template <size_t Nc>
+struct DeviceAdjFieldType<4, Nc> {
   using type = deviceAdjointField<4, Nc>;
 };
 
-template <size_t Nc> struct DeviceAdjFieldType<3, Nc> {
+template <size_t Nc>
+struct DeviceAdjFieldType<3, Nc> {
   using type = deviceAdjointField3D<3, Nc>;
 };
 
-template <size_t Nc> struct DeviceAdjFieldType<2, Nc> {
+template <size_t Nc>
+struct DeviceAdjFieldType<2, Nc> {
   using type = deviceAdjointField2D<2, Nc>;
 };
 
 // define Traits to extract the rank, Nc and GaugeFieldKind at a later point
-template <typename T> struct DeviceAdjFieldTypeTraits;
+template <typename T>
+struct DeviceAdjFieldTypeTraits;
 
 template <size_t _rank, size_t _Nc>
 struct DeviceAdjFieldTypeTraits<DeviceAdjFieldType<_rank, _Nc>> {
@@ -112,68 +155,85 @@ struct DeviceAdjFieldTypeTraits<DeviceAdjFieldType<_rank, _Nc>> {
 };
 
 // compile time check for the appropriate types
-template <typename T> struct isDeviceAdjFieldType : std::false_type {};
+template <typename T>
+struct isDeviceAdjFieldType : std::false_type {};
 
 template <size_t rank, size_t Nc>
 struct isDeviceAdjFieldType<DeviceAdjFieldType<rank, Nc>> : std::true_type {};
 
 // define the same thing for SUN fields
-template <size_t rank, size_t Nc> struct DeviceSUNFieldType;
+template <size_t rank, size_t Nc>
+struct DeviceSUNFieldType;
 
-template <size_t Nc> struct DeviceSUNFieldType<2, Nc> {
+template <size_t Nc>
+struct DeviceSUNFieldType<2, Nc> {
   using type = deviceSUNField2D<Nc>;
 };
 
-template <size_t Nc> struct DeviceSUNFieldType<3, Nc> {
+template <size_t Nc>
+struct DeviceSUNFieldType<3, Nc> {
   using type = deviceSUNField3D<Nc>;
 };
 
-template <size_t Nc> struct DeviceSUNFieldType<4, Nc> {
+template <size_t Nc>
+struct DeviceSUNFieldType<4, Nc> {
   using type = deviceSUNField<Nc>;
 };
 
 // repeat for field
-template <size_t rank> struct DeviceFieldType;
+template <size_t rank>
+struct DeviceFieldType;
 
-template <> struct DeviceFieldType<2> {
+template <>
+struct DeviceFieldType<2> {
   using type = deviceField2D;
 };
 
-template <> struct DeviceFieldType<3> {
+template <>
+struct DeviceFieldType<3> {
   using type = deviceField3D;
 };
 
-template <> struct DeviceFieldType<4> {
+template <>
+struct DeviceFieldType<4> {
   using type = deviceField;
 };
 
 // define the same for the scalar fields
-template <size_t rank> struct DeviceScalarFieldType;
+template <size_t rank>
+struct DeviceScalarFieldType;
 
-template <> struct DeviceScalarFieldType<2> {
+template <>
+struct DeviceScalarFieldType<2> {
   using type = deviceScalarField2D;
 };
 
-template <> struct DeviceScalarFieldType<3> {
+template <>
+struct DeviceScalarFieldType<3> {
   using type = deviceScalarField3D;
 };
 
-template <> struct DeviceScalarFieldType<4> {
+template <>
+struct DeviceScalarFieldType<4> {
   using type = deviceScalarField;
 };
 
 // Type selector
-template <size_t Nd, size_t Nc> struct ConstGaugeFieldSelector;
+template <size_t Nd, size_t Nc>
+struct ConstGaugeFieldSelector;
 
-template <size_t Nc> struct ConstGaugeFieldSelector<4, Nc> {
+template <size_t Nc>
+struct ConstGaugeFieldSelector<4, Nc> {
   using type = constGaugeField<4, Nc>;
 };
 
-template <size_t Nc> struct ConstGaugeFieldSelector<3, Nc> {
+template <size_t Nc>
+struct ConstGaugeFieldSelector<3, Nc> {
   using type = constGaugeField3D<3, Nc>;
 };
 
-template <size_t Nc> struct ConstGaugeFieldSelector<2, Nc> {
+template <size_t Nc>
+struct ConstGaugeFieldSelector<2, Nc> {
   using type = constGaugeField2D<2, Nc>;
 };
 
@@ -182,4 +242,4 @@ template <size_t Nd, size_t Nc>
 using ConstGaugeFieldType = typename ConstGaugeFieldSelector<Nd, Nc>::type;
 
 // add the same for scalar fields here when needed
-} // namespace klft
+}  // namespace klft
diff --git a/include/GDiracOperator.hpp b/include/GDiracOperator.hpp
new file mode 100644
index 0000000..a3cbbe5
--- /dev/null
+++ b/include/GDiracOperator.hpp
@@ -0,0 +1,232 @@
+//******************************************************************************/
+//
+// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
+//
+// KLFT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// KLFT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
+//
+//******************************************************************************/
+
+// this file defines various versions of the Wilson-Dirac (WD) operator, in
+// lattice units following Gattringer2010 (5.55) f. and absorbing the constant C
+// into the field definition
+#pragma once
+#include "FermionParams.hpp"
+#include "FieldTypeHelper.hpp"
+#include "GammaMatrix.hpp"
+#include "IndexHelper.hpp"
+#include "Spinor.hpp"
+namespace klft {
+
+template <typename _Derived, typename DSpinorFieldType,
+          typename DGaugeFieldType>
+class DiracOperator {
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  static_assert(isDeviceFermionFieldType<DSpinorFieldType>::value);
+  constexpr static size_t rank =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Rank;
+  constexpr static size_t Nc =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::RepDim;
+  static_assert((rank == DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank) &&
+                (Nc == DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc));
+
+  using Derived = _Derived;
+  // Define Tags for template dispatch:
+  using SpinorFieldType = typename DSpinorFieldType::type;
+  using GaugeFieldType = typename DGaugeFieldType::type;
+
+ public:
+  struct TagD {};
+  struct TagDdagger {};
+  ~DiracOperator() = default;
+
+  SpinorFieldType applyD(const SpinorFieldType& s_in) {
+    // Initialize the input field
+    this->s_in = s_in;
+    // Initialize the output field
+    this->s_out = SpinorFieldType(params.dimensions, complex_t(0.0, 0.0));
+    // Apply the operator
+    tune_and_launch_for<rank, TagD>(typeid(Derived).name(), IndexArray<rank>{},
+                                    params.dimensions,
+                                    static_cast<_Derived&>(*this));
+    Kokkos::fence();
+    return s_out;
+  }
+  SpinorFieldType applyDdagger(const SpinorFieldType& s_in) {
+    this->s_in = s_in;
+    // Initialize the output field
+    this->s_out = SpinorFieldType(params.dimensions, complex_t(0.0, 0.0));
+    // Apply the operator
+    tune_and_launch_for<rank, TagDdagger>(typeid(Derived).name(),
+                                          IndexArray<rank>{}, params.dimensions,
+                                          static_cast<_Derived&>(*this));
+    Kokkos::fence();
+    return s_out;
+  }
+  void applyD_inplace(const SpinorFieldType& s_in, SpinorFieldType& s_out) {
+    this->s_in = s_in;
+    this->s_out = s_out;
+    tune_and_launch_for<rank, TagD>(typeid(Derived).name(), IndexArray<rank>{},
+                                    params.dimensions,
+                                    static_cast<_Derived&>(*this));
+    Kokkos::fence();
+  }
+  void applyDdagger_inplace(const SpinorFieldType& s_in,
+                            SpinorFieldType& s_out) {
+    this->s_in = s_in;
+    this->s_out = s_out;
+    tune_and_launch_for<rank, TagDdagger>(typeid(Derived).name(),
+                                          IndexArray<rank>{}, params.dimensions,
+                                          static_cast<_Derived&>(*this));
+    Kokkos::fence();
+  }
+  SpinorFieldType s_in;
+  SpinorFieldType s_out;
+  const GaugeFieldType g_in;
+  const diracParams<rank, RepDim> params;
+
+  DiracOperator(const GaugeFieldType& g_in,
+                const diracParams<rank, RepDim>& params)
+      : g_in(g_in), params(params) {}
+
+ protected:
+  DiracOperator() = default;
+};
+
+template <typename DSpinorFieldType, typename DGaugeFieldType>
+class WilsonDiracOperator
+    : public DiracOperator<
+          WilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+          DSpinorFieldType, DGaugeFieldType> {
+ public:
+  constexpr static size_t Nc =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::RepDim;
+  constexpr static size_t rank =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Rank;
+
+  ~WilsonDiracOperator() = default;
+  using Base =
+      DiracOperator<WilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                    DSpinorFieldType, DGaugeFieldType>;
+  using Base::Base;
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(typename Base::TagD,
+                                              const Indices... Idcs) const {
+    Spinor<Nc, RepDim> temp;
+#pragma unroll
+    for (size_t mu = 0; mu < rank; ++mu) {
+      auto xm = shift_index_minus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+      auto xp = shift_index_plus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+
+      temp += (this->params.gamma_id - this->params.gammas[mu]) * 0.5 *
+              xp.second * (this->g_in(Idcs..., mu) * this->s_in(xp.first));
+      temp += (this->params.gamma_id + this->params.gammas[mu]) * 0.5 *
+              xm.second *
+              (conj(this->g_in(xm.first, mu)) * this->s_in(xm.first));
+    }
+
+    this->s_out(Idcs...) = this->s_in(Idcs...) - this->params.kappa * temp;
+  }
+
+  // only for testing purpose, not the real Ddagger operator
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(typename Base::TagDdagger,
+                                              const Indices... Idcs) const {
+    Spinor<Nc, RepDim> temp;
+#pragma unroll
+    for (size_t mu = 0; mu < rank; ++mu) {
+      auto xm = shift_index_minus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+      auto xp = shift_index_plus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+
+      temp += (this->params.gamma_id - this->params.gammas[mu]) * xp.second *
+              (this->g_in(Idcs..., mu) * this->s_in(xp.first));
+      temp += (this->params.gamma_id + this->params.gammas[mu]) * xm.second *
+              (conj(this->g_in(xm.first, mu)) * this->s_in(xm.first));
+    }
+
+    this->s_out(Idcs...) = this->s_in(Idcs...) - this->params.kappa * temp;
+  }
+};
+// // Deduction guide
+// template <typename GaugeType, typename ParamType>
+// WilsonDiracOperator(const GaugeType&, const ParamType&)
+//     -> WilsonDiracOperator<ParamType::rank, ParamType::Nc,
+//     ParamType::RepDim>;
+
+template <typename DSpinorFieldType, typename DGaugeFieldType>
+class HWilsonDiracOperator
+    : public DiracOperator<
+          HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+          DSpinorFieldType, DGaugeFieldType> {
+ public:
+  constexpr static size_t Nc =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::RepDim;
+  constexpr static size_t rank =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Rank;
+
+  ~HWilsonDiracOperator() = default;
+  using Base =
+      DiracOperator<HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                    DSpinorFieldType, DGaugeFieldType>;
+  using Base::Base;
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(typename Base::TagD,
+                                              const Indices... Idcs) const {
+    Spinor<Nc, RepDim> temp;
+#pragma unroll
+    for (size_t mu = 0; mu < rank; ++mu) {
+      auto xm = shift_index_minus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+      auto xp = shift_index_plus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+
+      temp += (this->params.gamma_id - this->params.gammas[mu]) * xp.second *
+              (this->g_in(Idcs..., mu) * this->s_in(xp.first));
+      temp += (this->params.gamma_id + this->params.gammas[mu]) * xm.second *
+              (conj(this->g_in(xm.first, mu)) * this->s_in(xm.first));
+    }
+
+    this->s_out(Idcs...) =
+        this->params.gamma5 * (this->s_in(Idcs...) - this->params.kappa * temp);
+  }
+
+  // only for testing porpose, not the real Ddagger operator
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(typename Base::TagDdagger,
+                                              const Indices... Idcs) const {
+    operator()(typename Base::TagD(), Idcs...);
+  }
+};
+// // Deduction guide
+// template <typename GaugeType, typename ParamType>
+// HWilsonDiracOperator(const GaugeType&, const ParamType&)
+//     -> HWilsonDiracOperator<ParamType::rank, ParamType::Nc,
+//     ParamType::RepDim>;
+
+}  // namespace klft
\ No newline at end of file
diff --git a/include/GLOBAL.hpp b/include/GLOBAL.hpp
index 14881f6..c25c754 100644
--- a/include/GLOBAL.hpp
+++ b/include/GLOBAL.hpp
@@ -26,17 +26,6 @@
 #pragma once
 #include <Kokkos_Core.hpp>
 #include <Kokkos_Random.hpp>
-#ifdef ENABLE_DEBUG
-#include <iostream>
-#define DEBUG_LOG(msg)                                                         \
-  do {                                                                         \
-    std::cout << msg << std::endl;                                             \
-  } while (0)
-#else
-#define DEBUG_LOG(msg)                                                         \
-  do {                                                                         \
-  } while (0)
-#endif
 
 namespace klft {
 
@@ -53,18 +42,20 @@ using complex_t = Kokkos::complex<real_t>;
 using index_t = int;
 
 // define index_arrays
-template <size_t rank> using IndexArray = Kokkos::Array<index_t, rank>;
+template <size_t rank>
+using IndexArray = Kokkos::Array<index_t, rank>;
 
 // define groups for gauge fields
-template <typename T> struct Wrapper {
+template <typename T>
+struct Wrapper {
   T data;
 
   // Implicit conversion to T&
   KOKKOS_INLINE_FUNCTION
-  operator T &() { return data; }
+  operator T&() { return data; }
 
   KOKKOS_INLINE_FUNCTION
-  operator const T &() const { return data; }
+  operator const T&() const { return data; }
 
   // Optional: pointer-style access (if T is a View or Array)
   KOKKOS_INLINE_FUNCTION
@@ -82,12 +73,13 @@ template <typename T> struct Wrapper {
   // }
 
   // operator[] forwarding
-  template <typename Index> KOKKOS_INLINE_FUNCTION auto &operator[](Index i) {
+  template <typename Index>
+  KOKKOS_INLINE_FUNCTION auto& operator[](Index i) {
     return data[i];
   }
 
   template <typename Index>
-  KOKKOS_INLINE_FUNCTION const auto &operator[](Index i) const {
+  KOKKOS_INLINE_FUNCTION const auto& operator[](Index i) const {
     return data[i];
   }
 
@@ -106,16 +98,35 @@ template <typename T> struct Wrapper {
 };
 
 template <size_t Nc>
-using SUN = Kokkos::Array<Kokkos::Array<complex_t, Nc>, Nc>;
+using SUN = Wrapper<Kokkos::Array<Kokkos::Array<complex_t, Nc>, Nc>>;
+
+// define Spinor Type
+// info correct dispatch is only guaranteed for    Nd != Nc ! -> Conflicts with
+// SUN.hpp version Maybe via class to make it safe
+template <size_t Nc, size_t Nd>
+using Spinor = Kokkos::Array<Kokkos::Array<complex_t, Nd>, Nc>;
+
+// define field view types
+// by default all views are 4D
+// some dimensions are set to 1 for lower dimensions
+// I'm still not sure if this is the best way to do it
+// Nd here is templated, but for a 4D gauge field,
+// shouldn't Nd always be 4?
+// Nc is the number of colors
+template <size_t Nc, size_t RepDim>
+using SpinorField = Kokkos::View<Spinor<Nc, RepDim>****,
+                                 Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 // define adjoint groups of gauge fields
 template <size_t Nc>
-using sun = Kokkos::Array<real_t, std::max<size_t>(Nc *Nc - 1, 1)>;
+using sun = Kokkos::Array<real_t, std::max<size_t>(Nc* Nc - 1, 1)>;
 
 // define adjoint groups
-template <size_t Nc> constexpr size_t NcAdj = (Nc * Nc > 1) ? Nc * Nc - 1 : 1;
+template <size_t Nc>
+constexpr size_t NcAdj = (Nc * Nc > 1) ? Nc * Nc - 1 : 1;
 
-template <size_t Nc> struct SUNAdj {
+template <size_t Nc>
+struct SUNAdj {
   Kokkos::Array<real_t, NcAdj<Nc>> data;
 
   KOKKOS_INLINE_FUNCTION
@@ -125,12 +136,13 @@ template <size_t Nc> struct SUNAdj {
   auto operator->() const { return &data; }
 
   // operator[] forwarding
-  template <typename Index> KOKKOS_INLINE_FUNCTION auto &operator[](Index i) {
+  template <typename Index>
+  KOKKOS_INLINE_FUNCTION auto& operator[](Index i) {
     return data[i];
   }
 
   template <typename Index>
-  KOKKOS_INLINE_FUNCTION const auto &operator[](Index i) const {
+  KOKKOS_INLINE_FUNCTION const auto& operator[](Index i) const {
     return data[i];
   }
 };
@@ -146,245 +158,255 @@ template <size_t Nc> struct SUNAdj {
 // Nc is the number of colors
 template <size_t Nd, size_t Nc>
 using GaugeField =
-    Kokkos::View<SUN<Nc> ****[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUN<Nc>**** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using GaugeField3D =
-    Kokkos::View<SUN<Nc> ***[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUN<Nc>*** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using GaugeField2D =
-    Kokkos::View<SUN<Nc> **[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUN<Nc>** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using SUNAdjField =
-    Kokkos::View<SUNAdj<Nc> ****[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUNAdj<Nc>**** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using SUNAdjField3D =
-    Kokkos::View<SUNAdj<Nc> ***[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUNAdj<Nc>*** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using SUNAdjField2D =
-    Kokkos::View<SUNAdj<Nc> **[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUNAdj<Nc>** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nc>
 using SUNField =
-    Kokkos::View<SUN<Nc> ****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUN<Nc>****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nc>
 using SUNField3D =
-    Kokkos::View<SUN<Nc> ***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUN<Nc>***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nc>
 using SUNField2D =
-    Kokkos::View<SUN<Nc> **, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<SUN<Nc>**, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using Field =
-    Kokkos::View<complex_t ****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<complex_t****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using Field3D =
-    Kokkos::View<complex_t ***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<complex_t***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using Field2D =
-    Kokkos::View<complex_t **, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<complex_t**, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using Field1D =
-    Kokkos::View<complex_t *, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<complex_t*, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using ScalarField =
-    Kokkos::View<real_t ****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using ScalarField3D =
-    Kokkos::View<real_t ***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using ScalarField2D =
-    Kokkos::View<real_t **, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t**, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using ScalarField1D =
-    Kokkos::View<real_t *, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t*, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd>
 using LinkScalarField =
-    Kokkos::View<real_t ****[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t**** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd>
 using LinkScalarField3D =
-    Kokkos::View<real_t ***[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t*** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd>
 using LinkScalarField2D =
-    Kokkos::View<real_t **[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<real_t** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 // define corresponding constant fields
 #if defined(KOKKOS_ENABLE_CUDA)
+template <size_t Nc, size_t RepDim>
+using constSpinorField =
+    Kokkos::View<const Spinor<Nc, RepDim>****,
+                 Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd, size_t Nc>
 using constGaugeField =
-    Kokkos::View<const SUN<Nc> ****[Nd],
+    Kokkos::View<const SUN<Nc>**** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd, size_t Nc>
 using constGaugeField3D =
-    Kokkos::View<const SUN<Nc> ***[Nd],
+    Kokkos::View<const SUN<Nc>*** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd, size_t Nc>
 using constGaugeField2D =
-    Kokkos::View<const SUN<Nc> **[Nd],
+    Kokkos::View<const SUN<Nc>** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd, size_t Nc>
 using constSUNAdjField =
-    Kokkos::View<const SUNAdj<Nc> ****[Nd],
+    Kokkos::View<const SUNAdj<Nc>**** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd, size_t Nc>
 using constSUNAdjField3D =
-    Kokkos::View<const SUNAdj<Nc> ****[Nd],
+    Kokkos::View<const SUNAdj<Nc>**** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd, size_t Nc>
 using constSUNAdjField2D =
-    Kokkos::View<const SUNAdj<Nc> ****[Nd],
+    Kokkos::View<const SUNAdj<Nc>**** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nc>
-using constSUNField = Kokkos::View<const SUN<Nc> ****,
-                                   Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+using constSUNField =
+    Kokkos::View<const SUN<Nc>****, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nc>
 using constSUNField3D =
-    Kokkos::View<const SUN<Nc> ***, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const SUN<Nc>***, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nc>
 using constSUNField2D =
-    Kokkos::View<const SUN<Nc> **, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const SUN<Nc>**, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
-using constField = Kokkos::View<const complex_t ****,
+using constField = Kokkos::View<const complex_t****,
                                 Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
-using constField3D = Kokkos::View<const complex_t ***,
+using constField3D = Kokkos::View<const complex_t***,
                                   Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
-using constField2D = Kokkos::View<const complex_t **,
-                                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+using constField2D =
+    Kokkos::View<const complex_t**, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 using constField1D =
-    Kokkos::View<const complex_t *, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const complex_t*, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 using constScalarField =
-    Kokkos::View<const real_t ****, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const real_t****, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 using constScalarField3D =
-    Kokkos::View<const real_t ***, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const real_t***, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 using constScalarField2D =
-    Kokkos::View<const real_t **, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const real_t**, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 using constScalarField1D =
-    Kokkos::View<const real_t *, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
+    Kokkos::View<const real_t*, Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd>
 using constLinkScalarField =
-    Kokkos::View<const real_t ****[Nd],
+    Kokkos::View<const real_t**** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd>
 using constLinkScalarField3D =
-    Kokkos::View<const real_t ***[Nd],
+    Kokkos::View<const real_t*** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 template <size_t Nd>
 using constLinkScalarField2D =
-    Kokkos::View<const real_t **[Nd],
+    Kokkos::View<const real_t** [Nd],
                  Kokkos::MemoryTraits<Kokkos::RandomAccess>>;
 
 #else
+template <size_t Nc, size_t RepDim>
+using constSpinorField = Kokkos::View<const Spinor<Nc, RepDim>****,
+                                      Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
-using constGaugeField = Kokkos::View<const SUN<Nc> ****[Nd],
+using constGaugeField = Kokkos::View<const SUN<Nc>**** [Nd],
                                      Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using constGaugeField3D =
-    Kokkos::View<const SUN<Nc> ***[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const SUN<Nc>*** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
 using constGaugeField2D =
-    Kokkos::View<const SUN<Nc> **[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const SUN<Nc>** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
-using constSUNAdjField = Kokkos::View<const SUNAdj<Nc> ****[Nd],
+using constSUNAdjField = Kokkos::View<const SUNAdj<Nc>**** [Nd],
                                       Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
-using constSUNAdjField3D = Kokkos::View<const SUNAdj<Nc> ****[Nd],
+using constSUNAdjField3D = Kokkos::View<const SUNAdj<Nc>**** [Nd],
                                         Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd, size_t Nc>
-using constSUNAdjField2D = Kokkos::View<const SUNAdj<Nc> ****[Nd],
+using constSUNAdjField2D = Kokkos::View<const SUNAdj<Nc>**** [Nd],
                                         Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nc>
 using constSUNField =
-    Kokkos::View<const SUN<Nc> ****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const SUN<Nc>****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nc>
 using constSUNField3D =
-    Kokkos::View<const SUN<Nc> ***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const SUN<Nc>***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nc>
 using constSUNField2D =
-    Kokkos::View<const SUN<Nc> **, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const SUN<Nc>**, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constField =
-    Kokkos::View<const complex_t ****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const complex_t****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constField3D =
-    Kokkos::View<const complex_t ***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const complex_t***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constField2D =
-    Kokkos::View<const complex_t **, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const complex_t**, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constField1D =
-    Kokkos::View<const complex_t *, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const complex_t*, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constScalarField =
-    Kokkos::View<const real_t ****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t****, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constScalarField3D =
-    Kokkos::View<const real_t ***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t***, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constScalarField2D =
-    Kokkos::View<const real_t **, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t**, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 using constScalarField1D =
-    Kokkos::View<const real_t *, Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t*, Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd>
 using constLinkScalarField =
-    Kokkos::View<const real_t ****[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t**** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd>
 using constLinkScalarField3D =
-    Kokkos::View<const real_t ***[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t*** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 template <size_t Nd>
 using constLinkScalarField2D =
-    Kokkos::View<const real_t **[Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
+    Kokkos::View<const real_t** [Nd], Kokkos::MemoryTraits<Kokkos::Restrict>>;
 
 #endif
 
 // define policy as mdrange
-template <size_t rank> using Policy = Kokkos::MDRangePolicy<Kokkos::Rank<rank>>;
+template <size_t rank, class WorkTag = void>
+using Policy = Kokkos::MDRangePolicy<WorkTag, Kokkos::Rank<rank>>;
 
 // special case for 1D
-using Policy1D = Kokkos::RangePolicy<>;
+template <class WorkTag = void>
+using Policy1D = Kokkos::RangePolicy<WorkTag>;
 
 // define a global zero field generator
 // for the color x color matrix
-template <size_t Nc> constexpr KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> zeroSUN() {
+template <size_t Nc>
+constexpr KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> zeroSUN() {
   SUN<Nc> zero;
 #pragma unroll
   for (index_t c1 = 0; c1 < Nc; ++c1) {
@@ -395,7 +417,20 @@ template <size_t Nc> constexpr KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> zeroSUN() {
   }
   return zero;
 }
-
+// define a global zero generator
+// for spinor
+template <size_t Nc, size_t Nd>
+constexpr KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> zeroSpinor() {
+  Spinor<Nc, Nd> zero;
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; ++j) {
+      zero[i][j] = complex_t(0.0, 0.0);
+    }
+  }
+  return zero;
+}
 // define a global identity field generator
 // for the color x color matrix
 template <size_t Nc>
@@ -408,6 +443,21 @@ constexpr KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> identitySUN() {
   return id;
 }
 
+// define a global one generator
+// for spinor
+template <size_t Nc, size_t Nd>
+constexpr KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> oneSpinor() {
+  Spinor<Nc, Nd> id = zeroSpinor<Nc, Nd>();
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; ++j) {
+      id[i][j] = complex_t(1.0, 0.0);
+    }
+  }
+  return id;
+}
+
 // global verbosity level
 // 0 = silent
 // 1 = normal
@@ -417,13 +467,17 @@ constexpr KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> identitySUN() {
 // 5 = trace
 inline int KLFT_VERBOSITY = 0;
 
-inline void setVerbosity(int v) { KLFT_VERBOSITY = v; }
+inline void setVerbosity(int v) {
+  KLFT_VERBOSITY = v;
+}
 
 // variable that enables tuning
 // 0 = no tuning
 // 1 = tuning enabled
 inline int KLFT_TUNING = 0;
 
-inline void setTuning(int t) { KLFT_TUNING = t; }
+inline void setTuning(int t) {
+  KLFT_TUNING = t;
+}
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/GammaMatrix.hpp b/include/GammaMatrix.hpp
new file mode 100644
index 0000000..79aef0c
--- /dev/null
+++ b/include/GammaMatrix.hpp
@@ -0,0 +1,244 @@
+//******************************************************************************/
+//
+// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
+//
+// KLFT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// KLFT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
+//
+//******************************************************************************/
+
+// Define the global types and views for Kokkos Lattice Field Theory (KLFT)
+// This file contains the definitions for the types used in KLFT, including
+// the real and complex types, gauge field types, and field view types.
+// It also includes the definitions for the policies used in Kokkos parallel
+// programming.
+
+#pragma once
+#include "GLOBAL.hpp"
+
+// Implementation of Dirac Gamma Matrices
+// The Idea is to initialise the gamma matrices once at the beginning as array
+// and use it through out the simulation
+namespace klft {
+// using RepDim =size_t 4;
+template <size_t RepDim>
+struct GammaMat {
+  Kokkos::Array<Kokkos::Array<complex_t, RepDim>, RepDim> matrix;
+
+  GammaMat() = default;
+  GammaMat(
+      const Kokkos::Array<Kokkos::Array<complex_t, RepDim>, RepDim>& _mat) {
+    matrix = _mat;
+  }
+  KOKKOS_FORCEINLINE_FUNCTION
+  complex_t& operator()(size_t i, size_t j) { return matrix[i][j]; }
+  KOKKOS_FORCEINLINE_FUNCTION
+  const complex_t& operator()(size_t i, size_t j) const { return matrix[i][j]; }
+  KOKKOS_FORCEINLINE_FUNCTION
+  GammaMat<RepDim> operator-(const GammaMat<RepDim>& b) const {
+    GammaMat c{};
+#pragma unroll
+    for (size_t i = 0; i < RepDim; ++i) {
+#pragma unroll
+      for (size_t j = 0; j < RepDim; j++) {
+        c(i, j) = matrix[i][j] - b(i, j);
+      }
+    }
+    return c;
+  }
+  KOKKOS_FORCEINLINE_FUNCTION
+  GammaMat<RepDim> operator+(const GammaMat<RepDim>& b) const {
+    GammaMat c{};
+#pragma unroll
+    for (size_t i = 0; i < RepDim; ++i) {
+#pragma unroll
+      for (size_t j = 0; j < RepDim; j++) {
+        c(i, j) = matrix[i][j] + b(i, j);
+      }
+    }
+    return c;
+  }
+  KOKKOS_FORCEINLINE_FUNCTION
+  GammaMat<RepDim> operator*(const GammaMat<RepDim>& b) const {
+    GammaMat<RepDim> c;
+#pragma unroll
+    for (size_t i = 0; i < RepDim; ++i) {
+#pragma unroll
+      for (size_t j = 0; j < RepDim; ++j) {
+        c(i, j) = matrix[i][0] * b(0, j);
+#pragma unroll
+        for (size_t k = 1; k < RepDim; ++k) {
+          c(i, j) += matrix[i][k] * b(k, j);
+        }
+      }
+    }
+    return c;
+  }
+  KOKKOS_FORCEINLINE_FUNCTION
+  GammaMat<RepDim> operator*(const real_t& b) const {
+    GammaMat<RepDim> c;
+#pragma unroll
+    for (size_t i = 0; i < RepDim; ++i) {
+#pragma unroll
+      for (size_t j = 0; j < RepDim; ++j) {
+        c(i, j) = matrix[i][j] * b;
+      }
+    }
+    return c;
+  }
+  KOKKOS_FORCEINLINE_FUNCTION
+  GammaMat<RepDim> operator*(const complex_t& b) const {
+    GammaMat<RepDim> c;
+#pragma unroll
+    for (size_t i = 0; i < RepDim; ++i) {
+#pragma unroll
+      for (size_t j = 0; j < RepDim; ++j) {
+        c(i, j) = matrix[i][j] * b;
+      }
+    }
+    return c;
+  }
+  KOKKOS_FORCEINLINE_FUNCTION
+  bool operator==(const GammaMat<RepDim>& b) { return matrix == b.matrix; }
+  KOKKOS_FORCEINLINE_FUNCTION
+  const bool operator==(const GammaMat<RepDim>& b) const {
+    return matrix == b.matrix;
+  }
+};
+GammaMat<4> get_gamma0() {
+  GammaMat<4> g;
+  g(0, 0) = complex_t(0, 0);
+  g(0, 1) = complex_t(0, 0);
+  g(0, 2) = complex_t(-1, 0);
+  g(0, 3) = complex_t(0, 0);
+  g(1, 0) = complex_t(0, 0);
+  g(1, 1) = complex_t(0, 0);
+  g(1, 2) = complex_t(0, 0);
+  g(1, 3) = complex_t(-1, 0);
+  g(2, 0) = complex_t(-1, 0);
+  g(2, 1) = complex_t(0, 0);
+  g(2, 2) = complex_t(0, 0);
+  g(2, 3) = complex_t(0, 0);
+  g(3, 0) = complex_t(0, 0);
+  g(3, 1) = complex_t(-1, 0);
+  g(3, 2) = complex_t(0, 0);
+  g(3, 3) = complex_t(0, 0);
+  return g;
+}
+
+GammaMat<4> get_gamma1() {
+  GammaMat<4> g{};
+  g(0, 0) = complex_t(0, 0);
+  g(0, 1) = complex_t(0, 0);
+  g(0, 2) = complex_t(0, 0);
+  g(0, 3) = complex_t(0, -1);
+  g(1, 0) = complex_t(0, 0);
+  g(1, 1) = complex_t(0, 0);
+  g(1, 2) = complex_t(0, -1);
+  g(1, 3) = complex_t(0, 0);
+  g(2, 0) = complex_t(0, 0);
+  g(2, 1) = complex_t(0, 1);
+  g(2, 2) = complex_t(0, 0);
+  g(2, 3) = complex_t(0, 0);
+  g(3, 0) = complex_t(0, 1);
+  g(3, 1) = complex_t(0, 0);
+  g(3, 2) = complex_t(0, 0);
+  g(3, 3) = complex_t(0, 0);
+  return g;
+}
+
+GammaMat<4> get_gamma2() {
+  GammaMat<4> g{};
+  g(0, 0) = complex_t(0, 0);
+  g(0, 1) = complex_t(0, 0);
+  g(0, 2) = complex_t(0, 0);
+  g(0, 3) = complex_t(-1, 0);
+  g(1, 0) = complex_t(0, 0);
+  g(1, 1) = complex_t(0, 0);
+  g(1, 2) = complex_t(1, 0);
+  g(1, 3) = complex_t(0, 0);
+  g(2, 0) = complex_t(0, 0);
+  g(2, 1) = complex_t(1, 0);
+  g(2, 2) = complex_t(0, 0);
+  g(2, 3) = complex_t(0, 0);
+  g(3, 0) = complex_t(-1, 0);
+  g(3, 1) = complex_t(0, 0);
+  g(3, 2) = complex_t(0, 0);
+  g(3, 3) = complex_t(0, 0);
+  return g;
+}
+
+GammaMat<4> get_gamma3() {
+  GammaMat<4> g{};
+  g(0, 0) = complex_t(0, 0);
+  g(0, 1) = complex_t(0, 0);
+  g(0, 2) = complex_t(0, -1);
+  g(0, 3) = complex_t(0, 0);
+  g(1, 0) = complex_t(0, 0);
+  g(1, 1) = complex_t(0, 0);
+  g(1, 2) = complex_t(0, 0);
+  g(1, 3) = complex_t(0, 1);
+  g(2, 0) = complex_t(0, 1);
+  g(2, 1) = complex_t(0, 0);
+  g(2, 2) = complex_t(0, 0);
+  g(2, 3) = complex_t(0, 0);
+  g(3, 0) = complex_t(0, 0);
+  g(3, 1) = complex_t(0, -1);
+  g(3, 2) = complex_t(0, 0);
+  g(3, 3) = complex_t(0, 0);
+  return g;
+}
+
+GammaMat<4> get_gamma5() {
+  GammaMat<4> g{};
+  g(0, 0) = complex_t(1, 0);
+  g(0, 1) = complex_t(0, 0);
+  g(0, 2) = complex_t(0, 0);
+  g(0, 3) = complex_t(0, 0);
+  g(1, 0) = complex_t(0, 0);
+  g(1, 1) = complex_t(1, 0);
+  g(1, 2) = complex_t(0, 0);
+  g(1, 3) = complex_t(0, 0);
+  g(2, 0) = complex_t(0, 0);
+  g(2, 1) = complex_t(0, 0);
+  g(2, 2) = complex_t(-1, 0);
+  g(2, 3) = complex_t(0, 0);
+  g(3, 0) = complex_t(0, 0);
+  g(3, 1) = complex_t(0, 0);
+  g(3, 2) = complex_t(0, 0);
+  g(3, 3) = complex_t(-1, 0);
+  return g;
+}
+template <size_t RepDim>
+const Kokkos::Array<GammaMat<RepDim>, 4> get_gammas() {
+  Kokkos::Array<GammaMat<RepDim>, 4> c;
+  c[0] = get_gamma0();
+  c[1] = get_gamma1();
+  c[2] = get_gamma2();
+  c[3] = get_gamma3();
+  return c;
+}
+template <size_t RepDim>
+const GammaMat<RepDim> get_identity() {
+  GammaMat<RepDim> c;
+  for (size_t i = 0; i < RepDim; ++i) {
+    for (size_t j = 0; j < RepDim; ++j) {
+      c(i, j) = complex_t(0.0, 0.0);
+      if (i == j) {
+        c(i, j) = complex_t(1.0, 0.0);
+      }
+    }
+  }
+  return c;
+}
+}  // namespace klft
\ No newline at end of file
diff --git a/include/GaugeField.hpp b/include/GaugeField.hpp
index fcf6ade..8f964f6 100644
--- a/include/GaugeField.hpp
+++ b/include/GaugeField.hpp
@@ -21,29 +21,40 @@
 
 #pragma once
 #include "GLOBAL.hpp"
-#include "Kokkos_Core.hpp"
 #include "SUN.hpp"
+#include "Tuner.hpp"
 
 namespace klft {
 
-template <size_t Nd, size_t Nc> struct deviceGaugeField {
-
+template <size_t Nd, size_t Nc>
+struct deviceGaugeField {
   deviceGaugeField() = delete;
 
-  GaugeField<Nd, Nc> field;
-  const IndexArray<4> dimensions;
-
-  deviceGaugeField(const GaugeField<Nd, Nc> &f_in)
-      : field("gauge_field", 0, 0, 0, 0),
-        dimensions({static_cast<index_t>(f_in.extent(0)),
-                    static_cast<index_t>(f_in.extent(1)),
-                    static_cast<index_t>(f_in.extent(2)),
-                    static_cast<index_t>(f_in.extent(3))}) {
+  // deviceGaugeField(GaugeField<Nd, Nc> &f_in)
+  //     : dimensions({static_cast<int>(f_in.extent(0)),
+  //                   static_cast<int>(f_in.extent(1)),
+  //                   static_cast<int>(f_in.extent(2)),
+  //                   static_cast<int>(f_in.extent(3))}) {
+  //   Kokkos::fence();
+  //   Kokkos::realloc(
+  //       Kokkos::WithoutInitializing, field, static_cast<int>(f_in.extent(0)),
+  //       static_cast<int>(f_in.extent(1)), static_cast<int>(f_in.extent(2)),
+  //       static_cast<int>(f_in.extent(3)));
+  //   Kokkos::fence();
+  //   Kokkos::deep_copy(field, f_in);
+  // }
 
-    static_assert(std::is_same_v<decltype(f_in), const GaugeField<Nd, Nc> &>,
-                  "WRONG TYPE PASSED TO CONSTRUCTOR");
-    do_init(field, f_in);
-  }
+  // deviceGaugeField(const GaugeField<Nd, Nc> &f_in)
+  //     : dimensions({static_cast<int>(f_in.extent(0)),
+  //                   static_cast<int>(f_in.extent(1)),
+  //                   static_cast<int>(f_in.extent(2)),
+  //                   static_cast<int>(f_in.extent(3))}) {
+  //   Kokkos::realloc(
+  //       Kokkos::WithoutInitializing, field, static_cast<int>(f_in.extent(0)),
+  //       static_cast<int>(f_in.extent(1)), static_cast<int>(f_in.extent(2)),
+  //       static_cast<int>(f_in.extent(3)));
+  //   Kokkos::deep_copy(field, f_in);
+  // }
 
   // initialize all sites to a given value
   deviceGaugeField(const index_t L0, const index_t L1, const index_t L2,
@@ -51,6 +62,11 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
       : dimensions({L0, L1, L2, L3}) {
     do_init(L0, L1, L2, L3, field, init);
   }
+  deviceGaugeField(const IndexArray<4> &dimensions, const complex_t init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            init);
+  }
 
   // initialize all links to a given SUN matrix
   deviceGaugeField(const index_t L0, const index_t L1, const index_t L2,
@@ -58,7 +74,11 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
       : dimensions({L0, L1, L2, L3}) {
     do_init(L0, L1, L2, L3, field, init);
   }
-
+  deviceGaugeField(const IndexArray<4> &dimensions, const SUN<Nc> &init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            init);
+  }
   // initialize all links to a random SUN matrix
   template <class RNG>
   deviceGaugeField(const index_t L0, const index_t L1, const index_t L2,
@@ -67,6 +87,14 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
     do_init(L0, L1, L2, L3, field, rng, delta);
   }
 
+  template <class RNG>
+  deviceGaugeField(const IndexArray<4> &dimensions, RNG &rng,
+                   const real_t delta)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            rng, delta);
+  }
+
   // initialize all sites to a random value
   template <class RNG>
   deviceGaugeField(const index_t L0, const index_t L1, const index_t L2,
@@ -74,23 +102,15 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
       : dimensions({L0, L1, L2, L3}) {
     do_init(L0, L1, L2, L3, field, rng);
   }
-
-  void do_init(GaugeField<Nd, Nc> &V, const GaugeField<Nd, Nc> &f_in) {
-    if (!V.is_allocated()) {
-      V = GaugeField<Nd, Nc>("gauge_field_tmp", 0, 0, 0, 0);
-    }
-    Kokkos::realloc(Kokkos::WithoutInitializing, V, dimensions[0],
-                    dimensions[1], dimensions[2], dimensions[3]);
-    Kokkos::fence();
-    Kokkos::deep_copy(V, f_in);
-    Kokkos::fence();
+  template <class RNG>
+  deviceGaugeField(const IndexArray<4> &dimensions, RNG &rng)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            rng);
   }
 
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                const index_t L3, GaugeField<Nd, Nc> &V, complex_t init) {
-    if (!V.is_allocated()) {
-      V = GaugeField<Nd, Nc>("gauge_field_tmp", 0, 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
     tune_and_launch_for<4>(
         "init_deviceGaugeField", IndexArray<4>{0, 0, 0, 0},
@@ -113,9 +133,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
 
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                const index_t L3, GaugeField<Nd, Nc> &V, const SUN<Nc> &init) {
-    if (!V.is_allocated()) {
-      V = GaugeField<Nd, Nc>("gauge_field_tmp", 0, 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
     tune_and_launch_for<4>(
         "init_deviceGaugeField", IndexArray<4>{0, 0, 0, 0},
@@ -134,9 +151,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                const index_t L3, GaugeField<Nd, Nc> &V, RNG &rng,
                const real_t delta) {
-    if (!V.is_allocated()) {
-      V = GaugeField<Nd, Nc>("gauge_field_tmp", 0, 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
     tune_and_launch_for<4>(
         "init_deviceGaugeField", IndexArray<4>{0, 0, 0, 0},
@@ -156,9 +170,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
   template <class RNG>
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                const index_t L3, GaugeField<Nd, Nc> &V, RNG &rng) {
-    if (!V.is_allocated()) {
-      V = GaugeField<Nd, Nc>("gauge_field_tmp", 0, 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
     tune_and_launch_for<4>(
         "init_deviceGaugeField", IndexArray<4>{0, 0, 0, 0},
@@ -182,31 +193,38 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
     Kokkos::fence();
   }
 
+  GaugeField<Nd, Nc> field;
+  const IndexArray<4> dimensions;
+
   // define accessors for the field
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const indexType i0, const indexType i1, const indexType i2,
-             const indexType i3, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(const indexType i0,
+                                                  const indexType i1,
+                                                  const indexType i2,
+                                                  const indexType i3,
+                                                  const index_t mu) const {
     return field(i0, i1, i2, i3, mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const indexType i0, const indexType i1, const indexType i2,
-             const indexType i3, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(const indexType i0,
+                                                  const indexType i1,
+                                                  const indexType i2,
+                                                  const indexType i3,
+                                                  const index_t mu) {
     return field(i0, i1, i2, i3, mu);
   }
 
   // define accessors with 4D Kokkos array
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const Kokkos::Array<indexType, 4> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(
+      const Kokkos::Array<indexType, 4> site, const index_t mu) const {
     return field(site[0], site[1], site[2], site[3], mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const Kokkos::Array<indexType, 4> site, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(
+      const Kokkos::Array<indexType, 4> site, const index_t mu) {
     return field(site[0], site[1], site[2], site[3], mu);
   }
 
@@ -238,8 +256,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
   // }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc>
-  staple(const Kokkos::Array<indexType, 4> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> staple(
+      const Kokkos::Array<indexType, 4> site, const index_t mu) const {
     // this only works if Nd == 4
     assert(Nd == 4);
     // get the indices
@@ -256,10 +274,9 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
     const index_t i3pmu = mu == 3 ? (i3 + 1) % dimensions[3] : i3;
 // positive directions
 #pragma unroll
-    for (index_t nu = 0; nu < Nd; ++nu) { // loop over nu
+    for (index_t nu = 0; nu < Nd; ++nu) {  // loop over nu
       // do nothing for mu = nu
-      if (nu == mu)
-        continue;
+      if (nu == mu) continue;
       // get the x + nu indices
       const index_t i0pnu = nu == 0 ? (i0 + 1) % dimensions[0] : i0;
       const index_t i1pnu = nu == 1 ? (i1 + 1) % dimensions[1] : i1;
@@ -269,13 +286,12 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
       temp += field(i0pmu, i1pmu, i2pmu, i3pmu, nu) *
               conj(field(i0pnu, i1pnu, i2pnu, i3pnu, mu)) *
               conj(field(i0, i1, i2, i3, nu));
-    } // loop over nu
+    }  // loop over nu
 // negative directions
 #pragma unroll
-    for (index_t nu = 0; nu < Nd; ++nu) { // loop over nu
+    for (index_t nu = 0; nu < Nd; ++nu) {  // loop over nu
       // do nothing for mu = nu
-      if (nu == mu)
-        continue;
+      if (nu == mu) continue;
       // get the x + mu - nu indices
       const index_t i0pmu_mnu =
           nu == 0 ? (i0pmu - 1 + dimensions[0]) % dimensions[0] : i0pmu;
@@ -298,39 +314,38 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField {
       temp += conj(field(i0pmu_mnu, i1pmu_mnu, i2pmu_mnu, i3pmu_mnu, nu)) *
               conj(field(i0mnu, i1mnu, i2mnu, i3mnu, mu)) *
               field(i0mnu, i1mnu, i2mnu, i3mnu, nu);
-    } // loop over nu
+    }  // loop over nu
     return temp;
   }
 };
 
-template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
+template <size_t Nd, size_t Nc>
+struct deviceGaugeField3D {
   GaugeField3D<Nd, Nc> field;
   const IndexArray<3> dimensions;
 
   deviceGaugeField3D() = delete;
 
-  deviceGaugeField3D(const GaugeField3D<Nd, Nc> &f_in)
-      : field("gauge_field", 0, 0, 0),
-        dimensions({static_cast<index_t>(f_in.extent(0)),
-                    static_cast<index_t>(f_in.extent(1)),
-                    static_cast<index_t>(f_in.extent(2))}) {
-    do_init(field, f_in);
-  }
-
   // initialize all sites to a given value
   deviceGaugeField3D(const index_t L0, const index_t L1, const index_t L2,
                      const complex_t init)
-      : field("gauge_field", 0, 0, 0), dimensions({L0, L1, L2}) {
+      : dimensions({L0, L1, L2}) {
     do_init(L0, L1, L2, field, init);
   }
-
+  deviceGaugeField3D(const IndexArray<3> &dimensions, const complex_t init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], field, init);
+  }
   // initialize all links to a given SUN matrix
   deviceGaugeField3D(const index_t L0, const index_t L1, const index_t L2,
                      const SUN<Nc> &init)
       : dimensions({L0, L1, L2}) {
     do_init(L0, L1, L2, field, init);
   }
-
+  deviceGaugeField3D(const IndexArray<3> &dimensions, const SUN<Nc> &init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], field, init);
+  }
   // initialize all links to a random SUN matrix
   template <class RNG>
   deviceGaugeField3D(const index_t L0, const index_t L1, const index_t L2,
@@ -338,6 +353,12 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
       : dimensions({L0, L1, L2}) {
     do_init(L0, L1, L2, field, rng, delta);
   }
+  template <class RNG>
+  deviceGaugeField3D(const IndexArray<3> &dimensions, RNG &rng,
+                     const real_t delta)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], field, rng, delta);
+  }
 
   // initialize all sites to a random value
   template <class RNG>
@@ -346,21 +367,15 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
       : dimensions({L0, L1, L2}) {
     do_init(L0, L1, L2, field, rng);
   }
-
-  void do_init(GaugeField3D<Nd, Nc> &V, const GaugeField3D<Nd, Nc> &f_in) {
-    if (!V.is_allocated()) {
-      V = GaugeField3D<Nd, Nc>("gauge_field_tmp", 0, 0, 0);
-    }
-    Kokkos::realloc(Kokkos::WithoutInitializing, V, dimensions[0],
-                    dimensions[1], dimensions[2]);
-    Kokkos::deep_copy(V, f_in);
+  // initialize all sites to a random value
+  template <class RNG>
+  deviceGaugeField3D(const IndexArray<3> &dimensions, RNG &rng)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], field, rng);
   }
 
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                GaugeField3D<Nd, Nc> &V, complex_t init) {
-    if (!V.is_allocated()) {
-      V = GaugeField3D<Nd, Nc>("gauge_field_tmp", 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2);
     tune_and_launch_for<3>(
         "init_deviceGaugeField3D", IndexArray<3>{0, 0, 0},
@@ -382,9 +397,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
 
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                GaugeField3D<Nd, Nc> &V, const SUN<Nc> &init) {
-    if (!V.is_allocated()) {
-      V = GaugeField3D<Nd, Nc>("gauge_field_tmp", 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2);
     tune_and_launch_for<3>(
         "init_deviceGaugeField3D", IndexArray<3>{0, 0, 0},
@@ -401,9 +413,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
   template <class RNG>
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                GaugeField3D<Nd, Nc> &V, RNG &rng, const real_t delta) {
-    if (!V.is_allocated()) {
-      V = GaugeField3D<Nd, Nc>("gauge_field_tmp", 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2);
     tune_and_launch_for<3>(
         "init_deviceGaugeField3D", IndexArray<3>{0, 0, 0},
@@ -422,9 +431,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
   template <class RNG>
   void do_init(const index_t L0, const index_t L1, const index_t L2,
                GaugeField3D<Nd, Nc> &V, RNG &rng) {
-    if (!V.is_allocated()) {
-      V = GaugeField3D<Nd, Nc>("gauge_field_tmp", 0, 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2);
     tune_and_launch_for<3>(
         "init_deviceGaugeField3D", IndexArray<3>{0, 0, 0},
@@ -449,29 +455,31 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
 
   // define accessors for the field
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const indexType i0, const indexType i1, const indexType i2,
-             const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(const indexType i0,
+                                                  const indexType i1,
+                                                  const indexType i2,
+                                                  const index_t mu) const {
     return field(i0, i1, i2, mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const indexType i0, const indexType i1, const indexType i2,
-             const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(const indexType i0,
+                                                  const indexType i1,
+                                                  const indexType i2,
+                                                  const index_t mu) {
     return field(i0, i1, i2, mu);
   }
 
   // define accessors with 3D Kokkos array
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const Kokkos::Array<indexType, 3> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(
+      const Kokkos::Array<indexType, 3> site, const index_t mu) const {
     return field(site[0], site[1], site[2], mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const Kokkos::Array<indexType, 3> site, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(
+      const Kokkos::Array<indexType, 3> site, const index_t mu) {
     return field(site[0], site[1], site[2], mu);
   }
 
@@ -499,8 +507,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
   // }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc>
-  staple(const Kokkos::Array<indexType, 3> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> staple(
+      const Kokkos::Array<indexType, 3> site, const index_t mu) const {
     // this only works if Nd == 3
     assert(Nd == 3);
     // get the indices
@@ -516,9 +524,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
 
 // positive directions
 #pragma unroll
-    for (index_t nu = 0; nu < Nd; ++nu) { // loop over nu
-      if (nu == mu)
-        continue; // skip if mu == nu
+    for (index_t nu = 0; nu < Nd; ++nu) {  // loop over nu
+      if (nu == mu) continue;              // skip if mu == nu
       const index_t i0pnu = nu == 0 ? (i0 + 1) % dimensions[0] : i0;
       const index_t i1pnu = nu == 1 ? (i1 + 1) % dimensions[1] : i1;
       const index_t i2pnu = nu == 2 ? (i2 + 1) % dimensions[2] : i2;
@@ -530,9 +537,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
 
 // negative directions
 #pragma unroll
-    for (index_t nu = 0; nu < Nd; ++nu) { // loop over nu
-      if (nu == mu)
-        continue; // skip if mu == nu
+    for (index_t nu = 0; nu < Nd; ++nu) {  // loop over nu
+      if (nu == mu) continue;              // skip if mu == nu
       const index_t i0pmu_mnu =
           nu == 0 ? (i0pmu - 1 + dimensions[0]) % dimensions[0] : i0pmu;
       const index_t i1pmu_mnu =
@@ -556,71 +562,54 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField3D {
   }
 };
 
-template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
-  GaugeField2D<Nd, Nc> field;
-  const IndexArray<2> dimensions;
-
+template <size_t Nd, size_t Nc>
+struct deviceGaugeField2D {
   deviceGaugeField2D() = delete;
 
-  deviceGaugeField2D(const GaugeField2D<Nd, Nc> &f_in)
-      : field("gauge_field", f_in.extent(0),
-              f_in.extent(1)), // Allocate directly in constructor
-        dimensions({static_cast<index_t>(f_in.extent(0)),
-                    static_cast<index_t>(f_in.extent(1))}) {
-    do_init(field, f_in);
-  }
-
   // initialize all sites to a given value
   deviceGaugeField2D(const index_t L0, const index_t L1, const complex_t init)
-      : field("gauge_field", L0, L1), // Allocate directly in constructor
-        dimensions({L0, L1}) {
+      : dimensions({L0, L1}) {
     do_init(L0, L1, field, init);
-    Kokkos::fence(); // Ensure initialization is complete
   }
-
+  deviceGaugeField2D(const IndexArray<2> &dimensions, const complex_t init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], field, init);
+  }
   // initialize all links to a given SUN matrix
   deviceGaugeField2D(const index_t L0, const index_t L1, const SUN<Nc> &init)
-      : field("gauge_field", L0, L1), // Allocate directly in constructor
-        dimensions({L0, L1}) {
+      : dimensions({L0, L1}) {
     do_init(L0, L1, field, init);
-    Kokkos::fence(); // Ensure initialization is complete
   }
-
+  deviceGaugeField2D(const IndexArray<2> &dimensions, const SUN<Nc> &init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], field, init);
+  }
   // initialize all links to a random SUN matrix
   template <class RNG>
   deviceGaugeField2D(const index_t L0, const index_t L1, RNG &rng,
                      const real_t delta)
-      : field("gauge_field", L0, L1), // Allocate directly in constructor
-        dimensions({L0, L1}) {
-    Kokkos::fence(); // Ensure allocation is complete
+      : dimensions({L0, L1}) {
     do_init(L0, L1, field, rng, delta);
-    Kokkos::fence(); // Ensure initialization is complete
   }
-
+  template <class RNG>
+  deviceGaugeField2D(const IndexArray<2> &dimensions, RNG &rng,
+                     const real_t delta)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], field, rng, delta);
+  }
   // initialize all sites to a random value
   template <class RNG>
   deviceGaugeField2D(const index_t L0, const index_t L1, RNG &rng)
-      : field("gauge_field", L0, L1), // Allocate directly in constructor
-        dimensions({L0, L1}) {
-    Kokkos::fence(); // Ensure allocation is complete
+      : dimensions({L0, L1}) {
     do_init(L0, L1, field, rng);
-    Kokkos::fence(); // Ensure initialization is complete
   }
-
-  void do_init(GaugeField2D<Nd, Nc> &V, const GaugeField2D<Nd, Nc> &f_in) {
-    if (!V.is_allocated()) {
-      V = GaugeField2D<Nd, Nc>("gauge_field_tmp", 0, 0);
-    }
-    Kokkos::realloc(Kokkos::WithoutInitializing, V, dimensions[0],
-                    dimensions[1]);
-    Kokkos::deep_copy(V, f_in);
+  template <class RNG>
+  deviceGaugeField2D(const IndexArray<2> &dimensions, RNG &rng)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], field, rng);
   }
-
   void do_init(const index_t L0, const index_t L1, GaugeField2D<Nd, Nc> &V,
                complex_t init) {
-    if (!V.is_allocated()) {
-      V = GaugeField2D<Nd, Nc>("gauge_field", 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1);
     tune_and_launch_for<2>(
         "init_deviceGaugeField2D", IndexArray<2>{0, 0}, IndexArray<2>{L0, L1},
@@ -641,9 +630,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
 
   void do_init(const index_t L0, const index_t L1, GaugeField2D<Nd, Nc> &V,
                const SUN<Nc> &init) {
-    if (!V.is_allocated()) {
-      V = GaugeField2D<Nd, Nc>("gauge_field", 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1);
     tune_and_launch_for<2>(
         "init_deviceGaugeField2D", IndexArray<2>{0, 0}, IndexArray<2>{L0, L1},
@@ -659,9 +645,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
   template <class RNG>
   void do_init(const index_t L0, const index_t L1, GaugeField2D<Nd, Nc> &V,
                RNG &rng, const real_t delta) {
-    if (!V.is_allocated()) {
-      V = GaugeField2D<Nd, Nc>("gauge_field", 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1);
     tune_and_launch_for<2>(
         "init_deviceGaugeField2D", IndexArray<2>{0, 0}, IndexArray<2>{L0, L1},
@@ -679,9 +662,6 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
   template <class RNG>
   void do_init(const index_t L0, const index_t L1, GaugeField2D<Nd, Nc> &V,
                RNG &rng) {
-    if (!V.is_allocated()) {
-      V = GaugeField2D<Nd, Nc>("gauge_field", 0, 0);
-    }
     Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1);
     tune_and_launch_for<2>(
         "init_deviceGaugeField2D", IndexArray<2>{0, 0}, IndexArray<2>{L0, L1},
@@ -699,34 +679,38 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
               }
             }
           }
-          rng.free_state(generator);
         });
     Kokkos::fence();
   }
 
+  GaugeField2D<Nd, Nc> field;
+  const IndexArray<2> dimensions;
+
   // define accessors for the field
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const indexType i0, const indexType i1, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(const indexType i0,
+                                                  const indexType i1,
+                                                  const index_t mu) const {
     return field(i0, i1, mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const indexType i0, const indexType i1, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(const indexType i0,
+                                                  const indexType i1,
+                                                  const index_t mu) {
     return field(i0, i1, mu);
   }
 
   // define accessors with 2D Kokkos array
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const Kokkos::Array<indexType, 2> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(
+      const Kokkos::Array<indexType, 2> site, const index_t mu) const {
     return field(site[0], site[1], mu);
   }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &
-  operator()(const Kokkos::Array<indexType, 2> site, const index_t mu) {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> &operator()(
+      const Kokkos::Array<indexType, 2> site, const index_t mu) {
     return field(site[0], site[1], mu);
   }
 
@@ -745,8 +729,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
   // }
 
   template <typename indexType>
-  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc>
-  staple(const Kokkos::Array<indexType, 2> site, const index_t mu) const {
+  KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> staple(
+      const Kokkos::Array<indexType, 2> site, const index_t mu) const {
     // this only works if Nd == 2
     assert(Nd == 2);
     // get the indices
@@ -760,9 +744,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
 
 // positive directions
 #pragma unroll
-    for (index_t nu = 0; nu < Nd; ++nu) { // loop over nu
-      if (nu == mu)
-        continue; // skip if mu == nu
+    for (index_t nu = 0; nu < Nd; ++nu) {  // loop over nu
+      if (nu == mu) continue;              // skip if mu == nu
       const index_t i0pnu = nu == 0 ? (i0 + 1) % dimensions[0] : i0;
       const index_t i1pnu = nu == 1 ? (i1 + 1) % dimensions[1] : i1;
 
@@ -772,9 +755,8 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
 
 // negative directions
 #pragma unroll
-    for (index_t nu = 0; nu < Nd; ++nu) { // loop over nu
-      if (nu == mu)
-        continue; // skip if mu == nu
+    for (index_t nu = 0; nu < Nd; ++nu) {  // loop over nu
+      if (nu == mu) continue;              // skip if mu == nu
       const index_t i0pmu_mnu =
           nu == 0 ? (i0pmu - 1 + dimensions[0]) % dimensions[0] : i0pmu;
       const index_t i1pmu_mnu =
@@ -793,4 +775,4 @@ template <size_t Nd, size_t Nc> struct deviceGaugeField2D {
   }
 };
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/GaugeFieldHelper.hpp b/include/GaugeFieldHelper.hpp
deleted file mode 100644
index dc08510..0000000
--- a/include/GaugeFieldHelper.hpp
+++ /dev/null
@@ -1,120 +0,0 @@
-#pragma once
-#include "FieldTypeHelper.hpp"
-#include "SUN.hpp"
-
-namespace klft {
-template <typename DGaugeFieldType> struct UnitarityCheckFunctor {
-  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
-  constexpr static size_t rank =
-      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
-  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
-
-  using Field = typename DGaugeFieldType::type;
-  Field field;
-
-  UnitarityCheckFunctor() = delete;
-
-  UnitarityCheckFunctor(const Field &f_in) : field(f_in) {}
-
-  // ——— rank-2 lattice  (x , t) ————————————————————————————————
-  KOKKOS_FORCEINLINE_FUNCTION
-  void operator()(const int x, const int t, real_t &local_max) const {
-    for (int mu = 0; mu < 2; ++mu) {
-      const real_t d = unitary_defect(field(x, t, mu));
-      local_max = fmax(local_max, d);
-    }
-  }
-
-  // ——— rank-3 lattice  (x , y , t) ————————————————————————————
-  KOKKOS_FORCEINLINE_FUNCTION
-  void operator()(const int x, const int y, const int t,
-                  real_t &local_max) const {
-    for (int mu = 0; mu < 3; ++mu) {
-      const real_t d = unitary_defect(field(x, y, t, mu));
-      local_max = fmax(local_max, d);
-    }
-  }
-
-  // ——— rank-4 lattice  (x , y , z , t) ————————————————————————
-  KOKKOS_FORCEINLINE_FUNCTION
-  void operator()(const int x, const int y, const int z, const int t,
-                  real_t &local_max) const {
-    for (int mu = 0; mu < 4; ++mu) {
-      const real_t d = unitary_defect(field(x, y, z, t, mu));
-      local_max = fmax(local_max, d);
-    }
-  }
-};
-
-template <typename DGaugeFieldType>
-real_t unitarity_check(const typename DGaugeFieldType::type &field) {
-  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
-  constexpr static size_t rank =
-      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
-  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
-
-  // initialize the local sum
-  real_t defect_max = 0.0;
-  // create the functor
-  UnitarityCheckFunctor<DGaugeFieldType> functor(field);
-  // launch the kernel
-
-  const auto rp = Kokkos::MDRangePolicy<Kokkos::Rank<rank>>(IndexArray<rank>{0},
-                                                            field.dimensions);
-  Kokkos::parallel_reduce("UnitarityCheck", rp, functor,
-                          Kokkos::Max<real_t>(defect_max));
-  // return the local sum
-  return defect_max;
-}
-
-template <typename DGaugeFieldType>
-void unitarity_restore(const typename DGaugeFieldType::type &field) {
-  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
-  constexpr static size_t rank =
-      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
-  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
-
-  if (KLFT_VERBOSITY > 5) {
-    Kokkos::printf("Restoring Unitarity of GaugeField.\n");
-    Kokkos::printf("Unitarity defect before restoration: %f\n",
-                   unitarity_check<DGaugeFieldType>(field));
-  }
-
-  const auto rp = Kokkos::MDRangePolicy<Kokkos::Rank<rank>>(IndexArray<rank>{0},
-                                                            field.dimensions);
-  if constexpr (rank == 4) {
-    tune_and_launch_for<rank>(
-        "UnitaryRestore", IndexArray<rank>{0}, field.dimensions,
-        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
-                      const index_t i3) {
-          for (index_t mu = 0; mu < rank; ++mu) {
-            restoreSUN(field(i0, i1, i2, i3, mu));
-          }
-        });
-  } else if constexpr (rank == 3) {
-    tune_and_launch_for<rank>(
-        "UnitaryRestore", IndexArray<rank>{0}, field.dimensions,
-        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2) {
-          for (index_t mu = 0; mu < rank; ++mu) {
-            restoreSUN(field(i0, i1, i2, mu));
-          }
-        });
-  } else if constexpr (rank == 2) {
-    tune_and_launch_for<rank>(
-        "UnitaryRestore", IndexArray<rank>{0}, field.dimensions,
-        KOKKOS_LAMBDA(const index_t i0, const index_t i1) {
-          for (index_t mu = 0; mu < rank; ++mu) {
-            restoreSUN(field(i0, i1, mu));
-          }
-        });
-  } else {
-    static_assert(rank == 2 || rank == 3 || rank == 4, "Unsupported rank");
-  }
-
-  if (KLFT_VERBOSITY > 5) {
-    Kokkos::printf("Unitarity defect after restoration: %f\n",
-                   unitarity_check<DGaugeFieldType>(field));
-  }
-}
-
-} // namespace klft
diff --git a/include/GaugeMonomial.hpp b/include/GaugeMonomial.hpp
index 52f1dd1..c9da5ec 100644
--- a/include/GaugeMonomial.hpp
+++ b/include/GaugeMonomial.hpp
@@ -19,7 +19,7 @@ class GaugeMonomial : public Monomial<DGaugeFieldType, DAdjFieldType> {
 
   using GaugeFieldType = typename DGaugeFieldType::type;
 
-public:
+ public:
   real_t beta;
 
   GaugeMonomial(real_t _beta, unsigned int _time_scale)
@@ -40,6 +40,9 @@ public:
         -(beta / static_cast<real_t>(Nc)) *
         GaugePlaquette<rank, Nc>(h.gauge_field, false);
   }
+  void print() override {
+    printf("Gauge Monomial:   %.20f\n", this->get_delta_H());
+  }
 };
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/GaugeObservable.hpp b/include/GaugeObservable.hpp
index 55e2645..98cb8ab 100644
--- a/include/GaugeObservable.hpp
+++ b/include/GaugeObservable.hpp
@@ -21,222 +21,239 @@
 // different gauge observables to be measured during simulations
 
 #pragma once
+#include <fstream>
+#include <iomanip>
+
 #include "GaugePlaquette.hpp"
 #include "WilsonLoop.hpp"
-#include <fstream>
 
-namespace klft
-{
-  // define a struct to hold parameters related to the gauge observables
-  struct GaugeObservableParams {
-    size_t measurement_interval; // interval between measurements
-    bool measure_plaquette; // whether to measure the plaquette
-    bool measure_wilson_loop_temporal; // whether to measure the temporal Wilson loop
-    bool measure_wilson_loop_mu_nu; // whether to measure the mu-nu Wilson loop
-    std::vector<Kokkos::Array<index_t,2>> W_temp_L_T_pairs; // pairs of (L,T) for the temporal Wilson loop
-    std::vector<Kokkos::Array<index_t,2>> W_mu_nu_pairs; // pairs of (mu,nu) for the mu-nu Wilson loop
-    std::vector<Kokkos::Array<index_t,2>> W_Lmu_Lnu_pairs; // pairs of (Lmu,Lnu) for the Wilson loop
+namespace klft {
+// define a struct to hold parameters related to the gauge observables
+struct GaugeObservableParams {
+  size_t measurement_interval;        // interval between measurements
+  bool measure_plaquette;             // whether to measure the plaquette
+  bool measure_wilson_loop_temporal;  // whether to measure the temporal Wilson
+                                      // loop
+  bool measure_wilson_loop_mu_nu;  // whether to measure the mu-nu Wilson loop
+  std::vector<Kokkos::Array<index_t, 2>>
+      W_temp_L_T_pairs;  // pairs of (L,T) for the temporal Wilson loop
+  std::vector<Kokkos::Array<index_t, 2>>
+      W_mu_nu_pairs;  // pairs of (mu,nu) for the mu-nu Wilson loop
+  std::vector<Kokkos::Array<index_t, 2>>
+      W_Lmu_Lnu_pairs;  // pairs of (Lmu,Lnu) for the Wilson loop
 
-    // we also define vectors to hold the measurements
-    std::vector<size_t> measurement_steps; // steps at which measurements are taken
-    std::vector<real_t> plaquette_measurements; // measurements of the plaquette
-    std::vector<std::vector<Kokkos::Array<real_t,3>>> W_temp_measurements; // L, T and corresponding W_temp
-    std::vector<std::vector<Kokkos::Array<real_t,5>>> W_mu_nu_measurements; // mu, nu, Lmu, Lnu and corresponding W_mu_nu
+  // we also define vectors to hold the measurements
+  std::vector<size_t>
+      measurement_steps;  // steps at which measurements are taken
+  std::vector<real_t> plaquette_measurements;  // measurements of the plaquette
+  std::vector<std::vector<Kokkos::Array<real_t, 3>>>
+      W_temp_measurements;  // L, T and corresponding W_temp
+  std::vector<std::vector<Kokkos::Array<real_t, 5>>>
+      W_mu_nu_measurements;  // mu, nu, Lmu, Lnu and corresponding W_mu_nu
 
-    // finally, some filenames where the measurements will be flushed
-    std::string plaquette_filename; // filename for the plaquette measurements
-    std::string W_temp_filename; // filename for the temporal Wilson loop measurements
-    std::string W_mu_nu_filename; // filename for the mu-nu Wilson loop measurements
+  // finally, some filenames where the measurements will be flushed
+  std::string plaquette_filename;  // filename for the plaquette measurements
+  std::string
+      W_temp_filename;  // filename for the temporal Wilson loop measurements
+  std::string
+      W_mu_nu_filename;  // filename for the mu-nu Wilson loop measurements
 
-    // boolean flag to indicate if the measurements are to be flushed
-    bool write_to_file;
+  // boolean flag to indicate if the measurements are to be flushed
+  bool write_to_file;
 
-    // constructor to initialize the parameters
-    // by default nothing is measured
-    GaugeObservableParams()
+  // constructor to initialize the parameters
+  // by default nothing is measured
+  GaugeObservableParams()
       : measurement_interval(0),
         measure_plaquette(false),
         measure_wilson_loop_temporal(false),
         measure_wilson_loop_mu_nu(false) {}
-  };
+};
 
-  // define a function to measure the gauge observables
-  template <size_t rank, size_t Nc>
-  void measureGaugeObservables(const typename DeviceGaugeFieldType<rank, Nc>::type &g_in,
-                              GaugeObservableParams &params,
-                              const size_t step) {
-    // check if the step is a measurement step
-    if ((params.measurement_interval == 0) ||
-        (step % params.measurement_interval != 0) ||
-        (step == 0)) {
-      return;
+// define a function to measure the gauge observables
+template <size_t rank, size_t Nc>
+void measureGaugeObservables(
+    const typename DeviceGaugeFieldType<rank, Nc>::type& g_in,
+    GaugeObservableParams& params,
+    const size_t step) {
+  // check if the step is a measurement step
+  if ((params.measurement_interval == 0) ||
+      (step % params.measurement_interval != 0) || (step == 0)) {
+    return;
+  }
+  // otherwise, carry out the measurements
+  if (KLFT_VERBOSITY > 1) {
+    printf("Measurement of Gauge Observables\n");
+    printf("step: %zu\n", step);
+  }
+  // measure the plaquette if requested
+  if (params.measure_plaquette) {
+    real_t P = GaugePlaquette<rank, Nc>(g_in);
+    params.plaquette_measurements.push_back(P);
+    if (KLFT_VERBOSITY > 1) {
+      printf("plaquette: %11.6f\n", P);
     }
-    // otherwise, carry out the measurements
-    if (KLFT_VERBOSITY > 0) {
-      printf("Measurement of Gauge Observables\n");
-      printf("step: %zu\n", step);
+  }
+  // measure the Wilson loop in the temporal direction
+  if (params.measure_wilson_loop_temporal) {
+    if (KLFT_VERBOSITY > 1) {
+      printf("temporal Wilson loop:\n");
+      printf("L, T, W_temp\n");
     }
-    // measure the plaquette if requested
-    if (params.measure_plaquette) {
-      real_t P = GaugePlaquette<rank, Nc>(g_in);
-      params.plaquette_measurements.push_back(P);
-      if (KLFT_VERBOSITY > 0) {
-        printf("plaquette: %11.6f\n", P);
+    std::vector<Kokkos::Array<real_t, 3>> temp_measurements;
+    WilsonLoop_temporal<rank, Nc>(g_in, params.W_temp_L_T_pairs,
+                                  temp_measurements);
+    if (KLFT_VERBOSITY > 1) {
+      for (const auto& measure : temp_measurements) {
+        printf("%d, %d, %11.6f\n", static_cast<index_t>(measure[0]),
+               static_cast<index_t>(measure[1]), measure[2]);
       }
     }
-    // measure the Wilson loop in the temporal direction
-    if (params.measure_wilson_loop_temporal) {
-      if (KLFT_VERBOSITY > 0) {
-        printf("temporal Wilson loop:\n");
-        printf("L, T, W_temp\n");
-      }
-      std::vector<Kokkos::Array<real_t,3>> temp_measurements;
-      WilsonLoop_temporal<rank, Nc>(g_in, params.W_temp_L_T_pairs,
-                                    temp_measurements);
-      if (KLFT_VERBOSITY > 0) {
-        for (const auto &measure : temp_measurements) {
-          printf("%d, %d, %11.6f\n", static_cast<index_t>(measure[0]), static_cast<index_t>(measure[1]), measure[2]);
-        }
-      }
-      params.W_temp_measurements.push_back(temp_measurements);
+    params.W_temp_measurements.push_back(temp_measurements);
+  }
+  // measure the Wilson loop in the mu-nu plane
+  if (params.measure_wilson_loop_mu_nu) {
+    if (KLFT_VERBOSITY > 1) {
+      printf("Wilson loop in the mu-nu plane:\n");
+      printf("mu, nu, Lmu, Lnu, W_mu_nu\n");
     }
-    // measure the Wilson loop in the mu-nu plane
-    if (params.measure_wilson_loop_mu_nu) {
-      if (KLFT_VERBOSITY > 0) {
-        printf("Wilson loop in the mu-nu plane:\n");
-        printf("mu, nu, Lmu, Lnu, W_mu_nu\n");
-      }
-      std::vector<Kokkos::Array<real_t,5>> temp_measurements;
-      for (const auto &pair_mu_nu : params.W_mu_nu_pairs) {
-        const index_t mu = pair_mu_nu[0];
-        const index_t nu = pair_mu_nu[1];
-        WilsonLoop_mu_nu<rank, Nc>(g_in, mu, nu,
-                          params.W_Lmu_Lnu_pairs, temp_measurements);
-        if (KLFT_VERBOSITY > 0) {
-          for (const auto &measure : temp_measurements) {
-            printf("%d, %d, %d, %d, %11.6f\n", static_cast<index_t>(measure[0]), static_cast<index_t>(measure[1]),
-                    static_cast<index_t>(measure[2]), static_cast<index_t>(measure[3]), measure[4]);
-          }
+    std::vector<Kokkos::Array<real_t, 5>> temp_measurements;
+    for (const auto& pair_mu_nu : params.W_mu_nu_pairs) {
+      const index_t mu = pair_mu_nu[0];
+      const index_t nu = pair_mu_nu[1];
+      WilsonLoop_mu_nu<rank, Nc>(g_in, mu, nu, params.W_Lmu_Lnu_pairs,
+                                 temp_measurements);
+      if (KLFT_VERBOSITY > 1) {
+        for (const auto& measure : temp_measurements) {
+          printf("%d, %d, %d, %d, %11.6f\n", static_cast<index_t>(measure[0]),
+                 static_cast<index_t>(measure[1]),
+                 static_cast<index_t>(measure[2]),
+                 static_cast<index_t>(measure[3]), measure[4]);
         }
       }
-      params.W_mu_nu_measurements.push_back(temp_measurements);
     }
-    // add the step to the measurement steps
-    params.measurement_steps.push_back(step);
-    return;
+    params.W_mu_nu_measurements.push_back(temp_measurements);
   }
+  // add the step to the measurement steps
+  params.measurement_steps.push_back(step);
+  return;
+}
 
-  // flush the plaquette measurements to disk
-  inline void flushPlaquette(std::ofstream &file,
-                      const GaugeObservableParams &params,
-                      const bool HEADER = true) {
-    // check if the file is open
-    if (!file.is_open()) {
-      printf("Error: file is not open\n");
-      return;
-    }
-    // check if plaquette measurements are available
-    if (!params.measure_plaquette) {
-      printf("Error: no plaquette measurements available\n");
-      return;
-    }
-    if (HEADER) file << "# step, plaquette\n";
-    for (size_t i = 0; i < params.measurement_steps.size(); ++i) {
-      file << params.measurement_steps[i] << ", "
-           << params.plaquette_measurements[i] << "\n";
-    }
+// flush the plaquette measurements to disk
+inline void flushPlaquette(std::ofstream& file,
+                           const GaugeObservableParams& params,
+                           const bool HEADER = true) {
+  // check if the file is open
+  if (!file.is_open()) {
+    printf("Error: file is not open\n");
+    return;
   }
-  
-  // flush the temporal Wilson loop measurements to disk
-  inline void flushWilsonLoopTemporal(std::ofstream &file,
-                          const GaugeObservableParams &params,
-                          const bool HEADER = true) {
-    // check if the file is open
-    if (!file.is_open()) {
-      printf("Error: file is not open\n");
-      return;
-    }
-    // check if temporal Wilson loop measurements are available
-    if (!params.measure_wilson_loop_temporal) {
-      printf("Error: no temporal Wilson loop measurements available\n");
-      return;
-    }
-    if (HEADER) file << "# step, L, T, W_temp\n";
-    for (size_t i = 0; i < params.measurement_steps.size(); ++i) {
-      for (const auto &measurement : params.W_temp_measurements[i]) {
-        file << params.measurement_steps[i] << ", "
-             << measurement[0] << ", "
-             << measurement[1] << ", "
-             << measurement[2] << "\n";
-      }
-    }
+  // check if plaquette measurements are available
+  if (!params.measure_plaquette) {
+    printf("Error: no plaquette measurements available\n");
+    return;
+  }
+  if (HEADER)
+    file << "# step, plaquette\n";
+  for (size_t i = 0; i < params.measurement_steps.size(); ++i) {
+    file << params.measurement_steps[i] << ", "
+         << params.plaquette_measurements[i] << "\n";
   }
+}
 
-  // flush the mu-nu Wilson loop measurements to disk
-  inline void flushWilsonLoopMuNu(std::ofstream &file,
-                           const GaugeObservableParams &params,
-                           const bool HEADER = true) {
-    // check if the file is open
-    if (!file.is_open()) {
-      printf("Error: file is not open\n");
-      return;
-    }
-    // check if mu-nu Wilson loop measurements are available
-    if (!params.measure_wilson_loop_mu_nu) {
-      printf("Error: no mu-nu Wilson loop measurements available\n");
-      return;
-    }
-    if (HEADER) file << "# step, mu, nu, Lmu, Lnu, W_mu_nu\n";
-    for (size_t i = 0; i < params.measurement_steps.size(); ++i) {
-      for (const auto &measurement : params.W_mu_nu_measurements[i]) {
-        file << params.measurement_steps[i] << ", "
-             << measurement[0] << ", "
-             << measurement[1] << ", "
-             << measurement[2] << ", "
-             << measurement[3] << ", "
-             << measurement[4] << "\n";
-      }
+// flush the temporal Wilson loop measurements to disk
+inline void flushWilsonLoopTemporal(std::ofstream& file,
+                                    const GaugeObservableParams& params,
+                                    const bool HEADER = true) {
+  // check if the file is open
+  if (!file.is_open()) {
+    printf("Error: file is not open\n");
+    return;
+  }
+  // check if temporal Wilson loop measurements are available
+  if (!params.measure_wilson_loop_temporal) {
+    printf("Error: no temporal Wilson loop measurements available\n");
+    return;
+  }
+  if (HEADER)
+    file << "# step, L, T, W_temp\n";
+  for (size_t i = 0; i < params.measurement_steps.size(); ++i) {
+    for (const auto& measurement : params.W_temp_measurements[i]) {
+      file << params.measurement_steps[i] << ", " << measurement[0] << ", "
+           << measurement[1] << ", " << measurement[2] << "\n";
     }
   }
+}
 
-  // define a global function to flush all measurements
-  inline void flushAllGaugeObservables(const GaugeObservableParams &params,
+// flush the mu-nu Wilson loop measurements to disk
+inline void flushWilsonLoopMuNu(std::ofstream& file,
+                                const GaugeObservableParams& params,
                                 const bool HEADER = true) {
-    // check if write_to_file is enabled
-    if (!params.write_to_file) {
-      printf("write_to_file is not enabled\n");
-      return;
-    }
-    // flush plaquette measurements
-    if (params.plaquette_filename != "") {
-      std::ofstream file(params.plaquette_filename, std::ios::app);
-      flushPlaquette(file, params, HEADER);
-      file.close();
-    }
-    // flush temporal Wilson loop measurements
-    if (params.W_temp_filename != "") {
-      std::ofstream file(params.W_temp_filename, std::ios::app);
-      flushWilsonLoopTemporal(file, params, HEADER);
-      file.close();
-    }
-    // flush mu-nu Wilson loop measurements
-    if (params.W_mu_nu_filename != "") {
-      std::ofstream file(params.W_mu_nu_filename, std::ios::app);
-      flushWilsonLoopMuNu(file, params, HEADER);
-      file.close();
+  // check if the file is open
+  if (!file.is_open()) {
+    printf("Error: file is not open\n");
+    return;
+  }
+  // check if mu-nu Wilson loop measurements are available
+  if (!params.measure_wilson_loop_mu_nu) {
+    printf("Error: no mu-nu Wilson loop measurements available\n");
+    return;
+  }
+  if (HEADER)
+    file << "# step, mu, nu, Lmu, Lnu, W_mu_nu\n";
+  for (size_t i = 0; i < params.measurement_steps.size(); ++i) {
+    for (const auto& measurement : params.W_mu_nu_measurements[i]) {
+      file << params.measurement_steps[i] << ", " << measurement[0] << ", "
+           << measurement[1] << ", " << measurement[2] << ", " << measurement[3]
+           << ", " << measurement[4] << "\n";
     }
-    // ...
-    // add more flush functions for other observables here
   }
+}
 
-  // function to clear all measurements
-  inline void clearAllGaugeObservables(GaugeObservableParams &params) {
-    params.measurement_steps.clear();
-    params.plaquette_measurements.clear();
-    params.W_temp_measurements.clear();
-    params.W_mu_nu_measurements.clear();
-    // ...
-    // add more clear functions for other observables here
+// define a global function to flush all measurements
+inline void flushAllGaugeObservables(const GaugeObservableParams& params,
+                                     const std::string& output_directory,
+                                     const bool HEADER = true,
+                                     const int& p = std::cout.precision()) {
+  std::setprecision(p);
+  // check if write_to_file is enabled
+  if (!params.write_to_file) {
+    printf("write_to_file is not enabled\n");
+    return;
+  }
+  // flush plaquette measurements
+  if (params.plaquette_filename != "") {
+    std::ofstream file(output_directory + params.plaquette_filename,
+                       std::ios::app);
+    flushPlaquette(file, params, HEADER);
+    file.close();
+  }
+  // flush temporal Wilson loop measurements
+  if (params.W_temp_filename != "") {
+    std::ofstream file(output_directory + params.W_temp_filename,
+                       std::ios::app);
+    flushWilsonLoopTemporal(file, params, HEADER);
+    file.close();
   }
+  // flush mu-nu Wilson loop measurements
+  if (params.W_mu_nu_filename != "") {
+    std::ofstream file(output_directory + params.W_mu_nu_filename,
+                       std::ios::app);
+    flushWilsonLoopMuNu(file, params, HEADER);
+    file.close();
+  }
+  // ...
+  // add more flush functions for other observables here
+}
+
+// function to clear all measurements
+inline void clearAllGaugeObservables(GaugeObservableParams& params) {
+  params.measurement_steps.clear();
+  params.plaquette_measurements.clear();
+  params.W_temp_measurements.clear();
+  params.W_mu_nu_measurements.clear();
+  // ...
+  // add more clear functions for other observables here
+}
 
-}
\ No newline at end of file
+}  // namespace klft
\ No newline at end of file
diff --git a/include/GaugePlaquette.hpp b/include/GaugePlaquette.hpp
index 89ad7ba..2557186 100644
--- a/include/GaugePlaquette.hpp
+++ b/include/GaugePlaquette.hpp
@@ -21,121 +21,116 @@
 
 #pragma once
 #include "FieldTypeHelper.hpp"
-#include "IndexHelper.hpp"
 #include "SUN.hpp"
 #include "Tuner.hpp"
+#include "IndexHelper.hpp"
 
-namespace klft {
-
-// define a function to calculate the gauge plaquette
-// U_{mu nu} (x) = Tr[ U_mu(x) U_nu(x+mu) U_mu^dagger(x+nu) U_nu^dagger(x) ]
-// for SU(N) gauge group
+namespace klft
+{
+  
+  // define a function to calculate the gauge plaquette
+  // U_{mu nu} (x) = Tr[ U_mu(x) U_nu(x+mu) U_mu^dagger(x+nu) U_nu^dagger(x) ]
+  // for SU(N) gauge group
 
-// first define the necessary functor
-template <size_t rank, size_t Nc> struct GaugePlaq {
-  // this kernel is defined for rank = Nd
-  constexpr static const size_t Nd = rank;
-  // define the gauge field type
-  using GaugeFieldType = typename DeviceGaugeFieldType<rank, Nc>::type;
-  const GaugeFieldType g_in;
-  // define the field type
-  using FieldType = typename DeviceFieldType<rank>::type;
-  FieldType plaq_per_site;
-  const IndexArray<rank> dimensions;
-  GaugePlaq(const GaugeFieldType &g_in, FieldType &plaq_per_site,
-            const IndexArray<rank> &dimensions)
-      : g_in(g_in), plaq_per_site(plaq_per_site), dimensions(dimensions) {
-  } // TODO: g_in does copy construction, this needs to be changed
+  // first define the necessary functor
+  template <size_t rank, size_t Nc>
+  struct GaugePlaq {
+    // this kernel is defined for rank = Nd
+    constexpr static const size_t Nd = rank;
+    // define the gauge field type
+    using GaugeFieldType = typename DeviceGaugeFieldType<rank, Nc>::type;
+    const GaugeFieldType g_in;
+    // define the field type
+    using FieldType = typename DeviceFieldType<rank>::type;
+    FieldType plaq_per_site;
+    const IndexArray<rank> dimensions;
+    GaugePlaq(const GaugeFieldType &g_in, FieldType &plaq_per_site,
+              const IndexArray<rank> &dimensions)
+      : g_in(g_in), plaq_per_site(plaq_per_site),
+        dimensions(dimensions) {}
 
-  template <typename... Indices>
-  KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
-    // temp SUN matrices to store products
-    SUN<Nc> lmu, lnu;
-    // reduction variable for all mu and nu
-    complex_t tmunu(0.0, 0.0);
+    template <typename... Indices>
+    KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
+      // temp SUN matrices to store products
+      SUN<Nc> lmu, lnu;
+      // reduction variable for all mu and nu
+      complex_t tmunu(0.0, 0.0);
 
-#pragma unroll
-    for (index_t mu = 0; mu < Nd; ++mu) {
-#pragma unroll
-      for (index_t nu = 0; nu < Nd; ++nu) {
-        if (nu > mu) {
-          // build plaquette in two halves
-          // U_{mu nu} (x) = Tr[ lmu * lnu^dagger ]
-          // lmu = U_mu(x) * U_nu(x+mu)
-          lmu =
-              g_in(Idcs..., mu) *
-              g_in(shift_index_plus<rank, size_t>(
-                       Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, dimensions),
-                   nu);
-          // lnu = U_nu(x) * U_mu(x+nu)
-          lnu =
-              g_in(Idcs..., nu) *
-              g_in(shift_index_plus<rank, size_t>(
-                       Kokkos::Array<size_t, rank>{Idcs...}, nu, 1, dimensions),
-                   mu);
-// multiply the 2 half plaquettes
-// lmu * lnu^dagger
-// take the trace
-#pragma unroll
-          for (index_t c1 = 0; c1 < Nc; ++c1) {
-#pragma unroll
-            for (index_t c2 = 0; c2 < Nc; ++c2) {
-              tmunu += lmu[c1][c2] * Kokkos::conj(lnu[c1][c2]);
+      #pragma unroll
+      for(index_t mu = 0; mu < Nd; ++mu) {
+        #pragma unroll
+        for(index_t nu = 0; nu < Nd; ++nu) {
+          if(nu > mu) {
+            // build plaquette in two halves
+            // U_{mu nu} (x) = Tr[ lmu * lnu^dagger ]
+            // lmu = U_mu(x) * U_nu(x+mu)
+            lmu = g_in(Idcs..., mu) * g_in(shift_index_plus<rank,size_t>(Kokkos::Array<size_t,rank>{Idcs...}, mu, 1, dimensions), nu);
+            // lnu = U_nu(x) * U_mu(x+nu)
+            lnu = g_in(Idcs..., nu) * g_in(shift_index_plus<rank,size_t>(Kokkos::Array<size_t,rank>{Idcs...}, nu, 1, dimensions), mu);
+            // multiply the 2 half plaquettes
+            // lmu * lnu^dagger
+            // take the trace
+            #pragma unroll
+            for(index_t c1 = 0; c1 < Nc; ++c1) {
+              #pragma unroll
+              for(index_t c2 = 0; c2 < Nc; ++c2) {
+                tmunu += lmu[c1][c2] * Kokkos::conj(lnu[c1][c2]);
+              }
             }
           }
         }
       }
+      // store the result in the temporary field
+      plaq_per_site(Idcs...) = tmunu;
     }
-    // store the result in the temporary field
-    plaq_per_site(Idcs...) = tmunu;
-  }
-};
 
-template <size_t rank, size_t Nc>
-real_t GaugePlaquette(const typename DeviceGaugeFieldType<rank, Nc>::type &g_in,
-                      const bool normalize = true) {
-  // this kernel is defined for rank = Nd
-  constexpr static const size_t Nd = rank;
-  // final return variable
-  complex_t plaq = 0.0;
-  // get the start and end indices
-  // this is temporary solution
-  // ideally, we want to have a policy factory
-  IndexArray<rank> start;
-  IndexArray<rank> end;
-  for (index_t i = 0; i < rank; ++i) {
-    start[i] = 0;
-    end[i] = g_in.dimensions[i];
-  }
+  };
+
+  template <size_t rank, size_t Nc>
+  real_t GaugePlaquette(const typename DeviceGaugeFieldType<rank, Nc>::type &g_in,
+                        const bool normalize = true) {
+    // this kernel is defined for rank = Nd
+    constexpr static const size_t Nd = rank;
+    // final return variable
+    complex_t plaq = 0.0;
+    // get the start and end indices
+    // this is temporary solution
+    // ideally, we want to have a policy factory
+    const auto & dimensions = g_in.field.layout().dimension;
+    IndexArray<rank> start;
+    IndexArray<rank> end;
+    for (index_t i = 0; i < rank; ++i) {
+      start[i] = 0;
+      end[i] = dimensions[i];
+    }
 
-  // temporary field for storing results per site
-  // direct reduction is slow
-  // this field will be summed over in the end
-  using FieldType = typename DeviceFieldType<rank>::type;
-  FieldType plaq_per_site(end, complex_t(0.0, 0.0));
+    // temporary field for storing results per site
+    // direct reduction is slow
+    // this field will be summed over in the end
+    using FieldType = typename DeviceFieldType<rank>::type;
+    FieldType plaq_per_site(end, complex_t(0.0, 0.0));
 
-  // define the functor
-  GaugePlaq<rank, Nc> gaugePlaquette(g_in, plaq_per_site, end);
+    // define the functor
+    GaugePlaq<rank, Nc> gaugePlaquette(g_in, plaq_per_site, end);
 
-  // tune and launch the kernel
-  tune_and_launch_for<rank>("GaugePlaquette_GaugeField", start, end,
-                            gaugePlaquette);
-  Kokkos::fence();
+    // tune and launch the kernel
+    tune_and_launch_for<rank>("GaugePlaquette_GaugeField", start, end, gaugePlaquette);
+    Kokkos::fence();
 
-  // sum over all sites
-  plaq = plaq_per_site.sum();
-  Kokkos::fence();
+    // sum over all sites
+    plaq = plaq_per_site.sum();
+    Kokkos::fence();
 
-  // normalization
-  if (normalize) {
-    real_t norm = 1.0;
-    for (index_t i = 0; i < rank; ++i) {
-      norm *= static_cast<real_t>(end[i]);
+    // normalization
+    if (normalize) {
+      real_t norm = 1.0;
+      for (index_t i = 0; i < rank; ++i) {
+        norm *= static_cast<real_t>(end[i]);
+      }
+      norm *= static_cast<real_t>((Nd*(Nd - 1)/2)*Nc);
+      plaq /= norm;
     }
-    norm *= static_cast<real_t>((Nd * (Nd - 1) / 2) * Nc);
-    plaq /= norm;
-  }
 
-  return Kokkos::real(plaq);
-}
-} // namespace klft
+    return Kokkos::real(plaq);
+  }
+}
\ No newline at end of file
diff --git a/include/Gauge_Util.hpp b/include/Gauge_Util.hpp
index 1bc1439..f7c92a0 100644
--- a/include/Gauge_Util.hpp
+++ b/include/Gauge_Util.hpp
@@ -203,7 +203,7 @@ auto stapleField(const typename DGaugeFieldType::type &g_in)
       DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
   constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
 
-  typename DGaugeFieldType::type g_out(g_in.field);
+  typename DGaugeFieldType::type g_out(g_in.dimensions, 0);
 
   // get the start and end indices
   const auto &dimensions = g_in.field.layout().dimension;
@@ -251,6 +251,7 @@ auto stapleField(const typename DGaugeFieldType::type &g_in)
   Kokkos::fence();
   // return the output field
   return ConstGaugeFieldType<Nd, Nc>(g_out.field);
+  Kokkos::fence();
 }
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/HMC.hpp b/include/HMC.hpp
index 4fe93bd..ed26340 100644
--- a/include/HMC.hpp
+++ b/include/HMC.hpp
@@ -1,18 +1,20 @@
 #pragma once
+#include <random>
+
+#include "AdjointFieldHelper.hpp"
+#include "FermionMonomial.hpp"
+#include "FermionParams.hpp"
 #include "GLOBAL.hpp"
 #include "GaugeMonomial.hpp"
 #include "HMC_Params.hpp"
 #include "HamiltonianField.hpp"
 #include "Integrator.hpp"
-#include "Kokkos_Core_fwd.hpp"
 #include "Monomial.hpp"
-#include <random>
-
 namespace klft {
 
 template <typename DGaugeFieldType, typename DAdjFieldType, class RNG>
 class HMC {
-public:
+ public:
   // template argument deduction and safety
   static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
   static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
@@ -26,8 +28,8 @@ public:
   using AdjFieldType = typename DAdjFieldType::type;
 
   struct randomize_momentum_s {};
-  const HMCParams &params;
-  HamiltonianField<DGaugeFieldType, DAdjFieldType> &hamiltonian_field;
+  Integrator_Params params;
+  HamiltonianField<DGaugeFieldType, DAdjFieldType>& hamiltonian_field;
   std::vector<std::unique_ptr<Monomial<DGaugeFieldType, DAdjFieldType>>>
       monomials;
   std::shared_ptr<Integrator> integrator;
@@ -35,18 +37,19 @@ public:
   std::mt19937 mt;
   std::uniform_real_distribution<real_t> dist;
   real_t delta_H;
-  GaugeFieldType gauge_old;
 
   HMC() = default;
 
-  HMC(const HMCParams &params_,
-      HamiltonianField<DGaugeFieldType, DAdjFieldType> &hamiltonian_field_,
+  HMC(const Integrator_Params params_,
+      HamiltonianField<DGaugeFieldType, DAdjFieldType>& hamiltonian_field_,
       std::shared_ptr<Integrator> integrator_, RNG rng_,
       std::uniform_real_distribution<real_t> dist_, std::mt19937 mt_)
-      : params(params_), rng(rng_), dist(dist_), mt(mt_),
+      : params(params_),
+        rng(rng_),
+        dist(dist_),
+        mt(mt_),
         hamiltonian_field(hamiltonian_field_),
-        integrator(std::move(integrator_)),
-        gauge_old(hamiltonian_field_.gauge_field) {}
+        integrator(std::move(integrator_)) {}
 
   void add_gauge_monomial(const real_t _beta, const unsigned int _time_scale) {
     monomials.emplace_back(
@@ -59,52 +62,82 @@ public:
         std::make_unique<KineticMonomial<DGaugeFieldType, DAdjFieldType>>(
             _time_scale));
   }
-
-  void reset_gauge_field() {
-    Kokkos::deep_copy(hamiltonian_field.gauge_field.field, gauge_old.field);
-    Kokkos::DefaultExecutionSpace{}.fence();
+  template <typename DiracOperator, typename Solver, typename DSpinorFieldType>
+  void add_fermion_monomial(
+      typename DSpinorFieldType::type& spinorField,
+      diracParams<DeviceFermionFieldTypeTraits<DSpinorFieldType>::Rank,
+
+                  DeviceFermionFieldTypeTraits<DSpinorFieldType>::RepDim>&
+          params_,
+      const real_t& tol_, RNG& rng, const unsigned int _time_scale) {
+    monomials.emplace_back(
+        std::make_unique<
+            FermionMonomial<DiracOperator, Solver, RNG, DSpinorFieldType,
+                            DGaugeFieldType, DAdjFieldType>>(
+            spinorField, params_, tol_, rng, _time_scale));
   }
 
-  bool hmc_step(const bool &reverse = false) {
-
-    if (not reverse) {
-      hamiltonian_field.template randomize_momentum<RNG>(rng);
-      Kokkos::fence();
-    }
-
-    Kokkos::deep_copy(Kokkos::DefaultExecutionSpace{}, gauge_old.field,
-                      hamiltonian_field.gauge_field.field);
-    Kokkos::DefaultExecutionSpace{}.fence();
-
+  bool hmc_step(const bool& check_Reversibility = false) {
+    Kokkos::fence();
+    hamiltonian_field.randomize_momentum(rng);
+    // print_SUNAdj(hamiltonian_field.adjoint_field(0, 0, 0, 0, 0),
+    //              "Randomized Momentum");
+
+    Kokkos::fence();
+    GaugeFieldType gauge_old(hamiltonian_field.gauge_field.dimensions, rng,
+                             0.1);
+    Kokkos::deep_copy(gauge_old.field, hamiltonian_field.gauge_field.field);
+    Kokkos::fence();
     for (int i = 0; i < monomials.size(); ++i) {
       monomials[i]->heatbath(hamiltonian_field);
     }
     integrator->integrate(params.tau, false);
-
     delta_H = 0.0;
     for (int i = 0; i < monomials.size(); ++i) {
       monomials[i]->accept(hamiltonian_field);
-      real_t dH = monomials[i]->get_delta_H();
-      DEBUG_LOG("dh " << i << ": " << dH);
-      delta_H += dH;
-    }
+      delta_H += monomials[i]->get_delta_H();
+      if (KLFT_VERBOSITY > 2) {
+        monomials[i]->print();
+      }
 
+      // Kokkos::printf("delta_H_monomial: %.20f\n",
+      // monomials[i]->get_delta_H());
+    }
+    // Kokkos::printf("delta_H_ges %.20f \n", delta_H);
     bool accept = true;
     if (delta_H > 0.0) {
-      real_t rand = dist(mt);
-      real_t threshold = Kokkos::exp(-delta_H);
-      if (rand > threshold) {
+      if (dist(mt) > Kokkos::exp(-delta_H)) {
         accept = false;
       }
     }
-
+    if (check_Reversibility) {
+      GaugeFieldType gauge_save(hamiltonian_field.gauge_field.dimensions, rng,
+                                0.1);
+      Kokkos::deep_copy(gauge_save.field, hamiltonian_field.gauge_field.field);
+      Kokkos::fence();
+      for (int i = 0; i < monomials.size(); ++i) {
+        monomials[i]->reset();
+        monomials[i]->heatbath(hamiltonian_field);
+      }
+      real_t delta_H_revers = 0;
+      flip_sign<DAdjFieldType>(hamiltonian_field.adjoint_field);
+      integrator->integrate(params.tau, false);
+      for (int i = 0; i < monomials.size(); ++i) {
+        monomials[i]->accept(hamiltonian_field);
+        delta_H_revers += monomials[i]->get_delta_H();
+        if (KLFT_VERBOSITY > 0) {
+          printf("ReverseCheck Monomial\n");
+          monomials[i]->print();
+        }
+      }
+      Kokkos::printf("Deltadelta_H_ges %.20f \n", delta_H + delta_H_revers);
+      Kokkos::deep_copy(hamiltonian_field.gauge_field.field, gauge_save.field);
+    }
     if (!accept) {
-      reset_gauge_field();
-    } else {
+      Kokkos::deep_copy(hamiltonian_field.gauge_field.field, gauge_old.field);
     }
 
     return accept;
   }
 };
-
-} // namespace klft
+}  // namespace klft
diff --git a/include/HMC_Params.hpp b/include/HMC_Params.hpp
index a2a6831..11a3613 100644
--- a/include/HMC_Params.hpp
+++ b/include/HMC_Params.hpp
@@ -18,38 +18,29 @@
 //
 //******************************************************************************/
 
-// this file defines metropolis parameters for simulating different fields and
-// actions
-
+// this file defines all Paramets structs used in the HMC
 #pragma once
 #include "GLOBAL.hpp"
 
 namespace klft {
 
 struct HMCParams {
-
   // general parameters
-  index_t Ndims; // number of dimensions of the simulated system
-  index_t L0;    // length of the first dimension
-  index_t L1;    // length of the second dimension
-  index_t L2;    // length of the third dimension
-  index_t L3;    // length of the fourth dimension
+  index_t Ndims;  // number of dimensions of the simulated system
+  index_t L0;     // length of the first dimension
+  index_t L1;     // length of the second dimension
+  index_t L2;     // length of the third dimension
+  index_t L3;     // length of the fourth dimension
   // hard cutoff at 4 for now, since we have not
   // implemented any 5D cases yet
   // more dimensions can and will be added when necessary
-  real_t tau;          // integration "time" for the hmc
-  real_t rngDelta;     // integration "time" for the hmc
-  index_t seed;        // seed for the random number generator
-  index_t nsteps;      // number of hmc steps
-  index_t nstepsGauge; // number of integration steps in gaugefield integration
+  real_t rngDelta;  // integration "time" for the hmc
+  index_t seed;     // seed for the random number generator
   bool coldStart;
 
   // parameters specific to the GaugeField
-  size_t Nd; // number of mu degrees of freedom
-  size_t Nc; // number of color degrees of freedom
-
-  // parameters specific to the Wilson action
-  real_t beta; // inverse coupling constant
+  size_t Nd;  // number of mu degrees of freedom
+  size_t Nc;  // number of color degrees of freedom
 
   // add more parameters above this line as needed
   // ...
@@ -63,18 +54,13 @@ struct HMCParams {
     L1 = 4;
     L2 = 4;
     L3 = 4;
-    tau = 1.0;
     seed = 1234;
-    nsteps = 10;
-    nstepsGauge = 20;
     rngDelta = 1.0;
     coldStart = false;
 
     Nd = 4;
     Nc = 2;
 
-    beta = 1.0;
-
     // set default values to newly added parameters
     // above this line
     // ...
@@ -89,18 +75,96 @@ struct HMCParams {
       printf("L1: %d\n", L1);
       printf("L2: %d\n", L2);
       printf("L3: %d\n", L3);
-      printf("tau: %.3f\n", tau);
-      printf("coldStart: %B\n", coldStart);
+
+      printf("coldStart: %b", coldStart);
       printf("rngDelta: %.3f\n", rngDelta);
       printf("seed: %d\n", seed);
-      printf("nsteps: %d\n", nsteps);
-      printf("nstepsGauge: %d\n", nstepsGauge);
+
       printf("GaugeField Parameters:\n");
       printf("Nd: %zu\n", Nd);
       printf("Nc: %zu\n", Nc);
       printf("Wilson Action Parameters:\n");
-      printf("beta: %.4f\n", beta);
     }
   }
 };
-} // namespace klft
+
+struct GaugeMonomial_Params {
+  real_t beta;
+  index_t level;  // level of integration
+  // GaugeMonomial_Params(real_t _beta = 1.0) : beta(_beta) {}
+  GaugeMonomial_Params() = default;
+  void print() const {
+    if (KLFT_VERBOSITY > 0) {
+      printf("Gauge Monomial Parameters:\n");
+      printf("  level: %d\n", level);
+      printf("  beta: %.10f\n", beta);
+    }
+  }
+};
+
+struct FermionMonomial_Params {
+  index_t level;             // level of integration
+  std::string fermion_type;  // type of fermion, e.g. Wilson, Staggered
+  std::string Solver;
+  size_t RepDim;
+  real_t kappa;
+  real_t tol;
+  // FermionMonomial_Params(const std::string& _fermion_type = "HWilson",
+  //                        const std::string& _Solver = "CG", size_t _RepDim =
+  //                        4, real_t _kappa = 0.1, real_t _tol = 1e-6)
+  //     : fermion_type(_fermion_type),
+  //       Solver(_Solver),
+  //       RepDim(_RepDim),
+  //       kappa(_kappa),
+  //       tol(_tol) {}
+  FermionMonomial_Params() = default;
+  void print() const {
+    if (KLFT_VERBOSITY > 0) {
+      printf("Fermion Parameters:\n");
+      printf("  Level: %d\n", level);
+      printf("  Fermion Type: %s\n", fermion_type.c_str());
+      printf("  Solver: %s\n", Solver.c_str());
+      printf("  RepDim: %zu\n", RepDim);
+      printf("  Kappa: %.20f\n", kappa);
+      printf("  Tolerance: %.20f\n", tol);
+    }
+  }
+};
+struct Integrator_Monomial_Params {
+  // defines Kind of monomial, i.e. gauge, fermions
+  std::string
+      type;       // defines the type of integrator to use for now only Leapfrog
+  index_t level;  // level of integration
+  index_t steps;  // num of steps
+  // Integrator_Monomial_Params(const std::string& _Kind,
+  //                            const std::string& _type = "Leapfrog",
+  //                            index_t _level = 0, index_t _steps = 20)
+  //     : Kind(_Kind), type(_type), level(_level), steps(_steps) {}
+  Integrator_Monomial_Params() = default;
+};
+
+struct Integrator_Params {
+  real_t tau;      // integration "time" for the hmc
+  index_t nsteps;  // number of hmc steps
+  std::vector<Integrator_Monomial_Params> monomials;
+
+  // Integrator_Params(real_t _tau = 1.0, index_t _nsteps = 10,
+  //                   std::vector<Integrator_Monomial_Params> _monomials,
+  //                   Integrator_Monomial_Params _fermionMonomial)
+  //     : tau(_tau), nsteps(_nsteps), monomials(_monomials) {}
+  Integrator_Params() = default;
+  void print() const {
+    if (KLFT_VERBOSITY > 0) {
+      printf("Integrator Parameters:\n");
+      printf("  tau: %.3f\n", tau);
+      printf("  nsteps: %d\n", nsteps);
+      for (auto& monomial : monomials) {
+        printf("  Monomial:\n");
+        printf("    Type: %s\n", monomial.type.c_str());
+        printf("    Level: %d\n", monomial.level);
+        printf("    Steps: %d\n", monomial.steps);
+      }
+    }
+  }
+};
+}  // namespace klft
diff --git a/include/HamiltonianField.hpp b/include/HamiltonianField.hpp
index c4ab963..61e39d6 100644
--- a/include/HamiltonianField.hpp
+++ b/include/HamiltonianField.hpp
@@ -1,25 +1,39 @@
 #pragma once
+#include "AdjointFieldHelper.hpp"
 #include "FieldTypeHelper.hpp"
 #include "GLOBAL.hpp"
 #include "Kokkos_Macros.hpp"
-#include "Tuner.hpp"
-#include "decl/Kokkos_Declare_OPENMP.hpp"
 #include "impl/Kokkos_Profiling.hpp"
 
 namespace klft {
 
-template <typename DAdjFieldType> struct KineticEnergyFunctor {
+template <typename DGaugeFieldType, typename DAdjFieldType>
+struct HamiltonianField {
+  // template argument deduction and safety
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
   static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
-  constexpr static size_t Nc = DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc;
-  constexpr static size_t rank = DeviceAdjFieldTypeTraits<DAdjFieldType>::rank;
+  constexpr static size_t rank =
+      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
+  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
+  static_assert((rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank) &&
+                (Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc));
+
+  using GaugeField = typename DGaugeFieldType::type;
   using AdjointField = typename DAdjFieldType::type;
-  const AdjointField adjoint_field;
 
-  KineticEnergyFunctor(const AdjointField &field) : adjoint_field(field) {}
+  GaugeField gauge_field;
+  AdjointField adjoint_field;
+  struct EKin {};
+
+  HamiltonianField() = delete;
+
+  HamiltonianField(GaugeField &_gauge_field, AdjointField &_adjoint_field)
+      : gauge_field(_gauge_field), adjoint_field(_adjoint_field) {}
 
-  KOKKOS_INLINE_FUNCTION
-  void operator()(index_t i0, index_t i1, index_t i2, index_t i3,
-                  real_t &rtn) const {
+  // Rank-4 version
+  KOKKOS_INLINE_FUNCTION void operator()(EKin, index_t i0, index_t i1,
+                                         index_t i2, index_t i3,
+                                         real_t &rtn) const {
     real_t tmp = 0.0;
     for (index_t mu = 0; mu < 4; ++mu) {
       tmp += 0.5 * norm2<Nc>(adjoint_field(i0, i1, i2, i3, mu));
@@ -28,8 +42,8 @@ template <typename DAdjFieldType> struct KineticEnergyFunctor {
   }
 
   // Rank-3 version
-  KOKKOS_INLINE_FUNCTION void operator()(index_t i0, index_t i1, index_t i2,
-                                         real_t &rtn) const {
+  KOKKOS_INLINE_FUNCTION void operator()(EKin, index_t i0, index_t i1,
+                                         index_t i2, real_t &rtn) const {
     real_t tmp = 0.0;
     for (index_t mu = 0; mu < 3; ++mu) {
       tmp += 0.5 * norm2<Nc>(adjoint_field(i0, i1, i2, mu));
@@ -38,7 +52,7 @@ template <typename DAdjFieldType> struct KineticEnergyFunctor {
   }
 
   // Rank-2 version
-  KOKKOS_INLINE_FUNCTION void operator()(index_t i0, index_t i1,
+  KOKKOS_INLINE_FUNCTION void operator()(EKin, index_t i0, index_t i1,
                                          real_t &rtn) const {
     real_t tmp = 0.0;
     for (index_t mu = 0; mu < 2; ++mu) {
@@ -46,58 +60,18 @@ template <typename DAdjFieldType> struct KineticEnergyFunctor {
     }
     rtn += tmp;
   }
-};
-
-template <typename DGaugeFieldType, typename DAdjFieldType>
-struct HamiltonianField {
-  // template argument deduction and safety
-  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
-  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
-  constexpr static size_t rank =
-      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
-  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
-  static_assert((rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank) &&
-                (Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc));
-
-  using GaugeField = typename DGaugeFieldType::type;
-  using AdjointField = typename DAdjFieldType::type;
-
-  HamiltonianField() = delete;
-
-  HamiltonianField(GaugeField g, AdjointField a)
-      : gauge_field((g)), adjoint_field((a)) {}
 
   real_t kinetic_energy() {
     real_t kinetic_energy = 0.0;
-    constexpr size_t r = rank; // for clarity
-    const auto &dim = adjoint_field.dimensions;
-    auto functor = KineticEnergyFunctor<DAdjFieldType>(adjoint_field);
-
-    if constexpr (r == 4) {
-      Kokkos::MDRangePolicy<Kokkos::Rank<4>> rp(
-          {0, 0, 0, 0}, {dim[0], dim[1], dim[2], dim[3]});
-      Kokkos::parallel_reduce("kinetic_energy", rp, functor, kinetic_energy);
-    } else if constexpr (r == 3) {
-      Kokkos::MDRangePolicy<Kokkos::Rank<3>> rp({0, 0, 0},
-                                                {dim[0], dim[1], dim[2]});
-      Kokkos::parallel_reduce("kinetic_energy", rp, functor, kinetic_energy);
-    } else if constexpr (r == 2) {
-      Kokkos::MDRangePolicy<Kokkos::Rank<2>> rp({0, 0}, {dim[0], dim[1]});
-      Kokkos::parallel_reduce("kinetic_energy", rp, functor, kinetic_energy);
-    } else {
-      static_assert(r <= 4, "Unsupported rank in kinetic_energy");
-    }
-
-    Kokkos::fence();
+    auto rp = Kokkos::MDRangePolicy<EKin, Kokkos::Rank<rank>>(
+        IndexArray<rank>{0}, adjoint_field.dimensions);
+    Kokkos::parallel_reduce("kinetic_energy", rp, *this, kinetic_energy);
     return kinetic_energy;
   }
 
   template <class RNG> void randomize_momentum(RNG &rng) {
-    adjoint_field.template randomize_field<RNG>(rng);
+    randomize_field<DAdjFieldType, RNG>(adjoint_field, rng);
   }
-
-  GaugeField gauge_field;
-  AdjointField adjoint_field;
 };
 
 } // namespace klft
diff --git a/include/IndexHelper.hpp b/include/IndexHelper.hpp
index 665d46d..d7b39d7 100644
--- a/include/IndexHelper.hpp
+++ b/include/IndexHelper.hpp
@@ -22,74 +22,106 @@
 #pragma once
 #include "GLOBAL.hpp"
 
-namespace klft
-{
+namespace klft {
 
-  // return x + shift  mu
-  template <size_t rank, typename indexType>
-  constexpr
-  KOKKOS_FORCEINLINE_FUNCTION
-  Kokkos::Array<index_t,rank> shift_index_plus(const Kokkos::Array<indexType,rank> &idx,
-                                          const index_t mu, const index_t shift,
-                                          const IndexArray<rank> &dimensions) {
-    // make sure mu makes sense
-    assert(mu < rank && mu >= 0);
-    Kokkos::Array<index_t,rank> new_idx;
-    #pragma unroll
-    for (index_t i = 0; i < rank; ++i) {
-      new_idx[i] = static_cast<index_t>(idx[i]);
-    }
-    new_idx[mu] = (idx[mu] + shift) % dimensions[mu];
-    return new_idx;
+// return x + shift  mu
+template <size_t rank, typename indexType>
+constexpr KOKKOS_FORCEINLINE_FUNCTION Kokkos::Array<index_t, rank>
+shift_index_plus(const Kokkos::Array<indexType, rank> &idx, const index_t mu,
+                 const index_t shift, const IndexArray<rank> &dimensions) {
+  // make sure mu makes sense
+  assert(mu < rank && mu >= 0);
+  Kokkos::Array<index_t, rank> new_idx;
+#pragma unroll
+  for (index_t i = 0; i < rank; ++i) {
+    new_idx[i] = static_cast<index_t>(idx[i]);
   }
+  new_idx[mu] = (idx[mu] + shift) % dimensions[mu];
+  return new_idx;
+}
 
-  // return x - shift mu
-  template <size_t rank, typename indexType>
-  constexpr
-  KOKKOS_FORCEINLINE_FUNCTION
-  Kokkos::Array<index_t,rank> shift_index_minus(const Kokkos::Array<indexType,rank> &idx,
-                                          const index_t mu, const index_t shift,
-                                          const IndexArray<rank> &dimensions) {
-    // make sure mu makes sense
-    assert(mu < rank && mu >= 0);
-    Kokkos::Array<index_t,rank> new_idx;
-    #pragma unroll
-    for (index_t i = 0; i < rank; ++i) {
-      new_idx[i] = static_cast<index_t>(idx[i]);
-    }
-    new_idx[mu] = (idx[mu] - shift + dimensions[mu]) % dimensions[mu];
-    return new_idx;
+// return x - shift mu
+template <size_t rank, typename indexType>
+constexpr KOKKOS_FORCEINLINE_FUNCTION Kokkos::Array<index_t, rank>
+shift_index_minus(const Kokkos::Array<indexType, rank> &idx, const index_t mu,
+                  const index_t shift, const IndexArray<rank> &dimensions) {
+  // make sure mu makes sense
+  assert(mu < rank && mu >= 0);
+  Kokkos::Array<index_t, rank> new_idx;
+#pragma unroll
+  for (index_t i = 0; i < rank; ++i) {
+    new_idx[i] = static_cast<index_t>(idx[i]);
   }
+  new_idx[mu] = (idx[mu] - shift + dimensions[mu]) % dimensions[mu];
+  return new_idx;
+}
 
-  // return index based on odd/even sublattice
-  // this does not check if the index is valid
-  // it is assumed that all of idx is
-  // less than half of the dimensional extents
-  template <size_t rank, typename indexType>
-  constexpr
-  KOKKOS_FORCEINLINE_FUNCTION
-  Kokkos::Array<index_t,rank> index_odd_even(const Kokkos::Array<indexType,rank> &idx,
-                                          const Kokkos::Array<bool,rank> &oddeven) {
-    Kokkos::Array<index_t,rank> new_idx;
-    #pragma unroll
-    for (index_t i = 0; i < rank; ++i) {
-      new_idx[i] = oddeven[i] ?
-        static_cast<index_t>(2*idx[i] + 1) : 
-        static_cast<index_t>(2*idx[i]);
-    }
-    return new_idx;
+// return index based on odd/even sublattice
+// this does not check if the index is valid
+// it is assumed that all of idx is
+// less than half of the dimensional extents
+template <size_t rank, typename indexType>
+constexpr KOKKOS_FORCEINLINE_FUNCTION Kokkos::Array<index_t, rank>
+index_odd_even(const Kokkos::Array<indexType, rank> &idx,
+               const Kokkos::Array<bool, rank> &oddeven) {
+  Kokkos::Array<index_t, rank> new_idx;
+#pragma unroll
+  for (index_t i = 0; i < rank; ++i) {
+    new_idx[i] = oddeven[i] ? static_cast<index_t>(2 * idx[i] + 1)
+                            : static_cast<index_t>(2 * idx[i]);
   }
+  return new_idx;
+}
 
-  // return an array of boolean values
-  template <size_t rank, typename indexType>
-  constexpr
-  KOKKOS_FORCEINLINE_FUNCTION
-  Kokkos::Array<bool,rank> oddeven_array(const indexType &val) {
-    Kokkos::Array<bool,rank> oddeven;
-    for (index_t i = 0; i < rank; ++i) {
-      oddeven[rank - 1 - i] = (val & (1 << i)) != 0;
-    }
-    return oddeven;
+// return an array of boolean values
+template <size_t rank, typename indexType>
+constexpr KOKKOS_FORCEINLINE_FUNCTION Kokkos::Array<bool, rank> oddeven_array(
+    const indexType &val) {
+  Kokkos::Array<bool, rank> oddeven;
+  for (index_t i = 0; i < rank; ++i) {
+    oddeven[rank - 1 - i] = (val & (1 << i)) != 0;
   }
+  return oddeven;
+}
 
-}
\ No newline at end of file
+// shifts index by shift*mu and gives scaler for bc
+template <size_t rank, typename indexType>
+constexpr KOKKOS_FORCEINLINE_FUNCTION
+    Kokkos::pair<Kokkos::Array<index_t, rank>, real_t>
+    shift_index_plus_bc(const Kokkos::Array<indexType, rank> &idx,
+                        const index_t mu, const index_t shift,
+                        const index_t bc_dim, const real_t bc_value,
+                        const IndexArray<rank> &dimensions) {
+  // make sure mu makes sense
+  assert(mu < rank && mu >= 0);
+  Kokkos::Array<index_t, rank> new_idx;
+#pragma unroll
+  for (index_t i = 0; i < rank; ++i) {
+    new_idx[i] = static_cast<index_t>(idx[i]);
+  }
+  new_idx[mu] = (idx[mu] + shift) % dimensions[mu];
+  real_t sign = (mu == bc_dim && idx[mu] > new_idx[mu]) ? bc_value : 1.0;
+  return {new_idx, sign};
+}
+
+// shifts index by shift*mu and gives scaler for bc
+template <size_t rank, typename indexType>
+constexpr KOKKOS_FORCEINLINE_FUNCTION
+    Kokkos::pair<Kokkos::Array<index_t, rank>, real_t>
+    shift_index_minus_bc(const Kokkos::Array<indexType, rank> &idx,
+                         const index_t mu, const index_t shift,
+                         const index_t bc_dim, const real_t bc_value,
+                         const IndexArray<rank> &dimensions) {
+  // make sure mu makes sense
+  assert(mu < rank && mu >= 0);
+  Kokkos::Array<index_t, rank> new_idx;
+#pragma unroll
+  for (index_t i = 0; i < rank; ++i) {
+    new_idx[i] = static_cast<index_t>(idx[i]);
+  }
+  new_idx[mu] = (idx[mu] - shift + dimensions[mu]) % dimensions[mu];
+  real_t sign = (mu == bc_dim && idx[mu] < new_idx[mu]) ? bc_value : 1.0;
+  return {new_idx, sign};
+}
+
+}  // namespace klft
\ No newline at end of file
diff --git a/include/InputParser.hpp b/include/InputParser.hpp
index c1040bf..65ed622 100644
--- a/include/InputParser.hpp
+++ b/include/InputParser.hpp
@@ -1,44 +1,23 @@
-//******************************************************************************/
-//
-// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
-//
-// KLFT is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// KLFT is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
-//
-//******************************************************************************/
-
-// this file defines input parser for running different simulations
-// we are going to overload the the fuction parseInputFile for all
-// different Param structs
-
 #pragma once
+#include <yaml-cpp/yaml.h>
+
+#include "FermionParams.hpp"
 #include "GaugeObservable.hpp"
 #include "HMC_Params.hpp"
 #include "Metropolis_Params.hpp"
 #include "SimulationLogging.hpp"
-#include <yaml-cpp/yaml.h>
 
 namespace klft {
 
 // get MetropolisParams from input file
-inline bool parseInputFile(const std::string &filename,
-                           MetropolisParams &metropolisParams) {
+inline int parseInputFile(const std::string& filename,
+                          MetropolisParams& metropolisParams) {
   try {
     YAML::Node config = YAML::LoadFile(filename);
 
     // Parse MetropolisParams
     if (config["MetropolisParams"]) {
-      const auto &mp = config["MetropolisParams"];
+      const auto& mp = config["MetropolisParams"];
       // general parameters
       metropolisParams.Ndims = mp["Ndims"].as<index_t>(4);
       metropolisParams.L0 = mp["L0"].as<index_t>(32);
@@ -61,21 +40,21 @@ inline bool parseInputFile(const std::string &filename,
       return false;
     }
     return true;
-  } catch (const YAML::Exception &e) {
+  } catch (const YAML::Exception& e) {
     printf("Error parsing input file: %s\n", e.what());
     return false;
   }
 }
 
 // get GaugeObservableParams from input file
-inline bool parseInputFile(const std::string &filename,
-                           GaugeObservableParams &gaugeObservableParams) {
+inline int parseInputFile(const std::string& filename,
+                          GaugeObservableParams& gaugeObservableParams) {
   try {
     YAML::Node config = YAML::LoadFile(filename);
 
     // Parse GaugeObservableParams
     if (config["GaugeObservableParams"]) {
-      const auto &gp = config["GaugeObservableParams"];
+      const auto& gp = config["GaugeObservableParams"];
       // interval between measurements
       gaugeObservableParams.measurement_interval =
           gp["measurement_interval"].as<size_t>(0);
@@ -91,7 +70,7 @@ inline bool parseInputFile(const std::string &filename,
 
       // pairs of (L,T) for the temporal Wilson loop
       if (gp["W_temp_L_T_pairs"]) {
-        for (const auto &pair : gp["W_temp_L_T_pairs"]) {
+        for (const auto& pair : gp["W_temp_L_T_pairs"]) {
           gaugeObservableParams.W_temp_L_T_pairs.push_back(
               IndexArray<2>({pair[0].as<index_t>(), pair[1].as<index_t>()}));
         }
@@ -99,7 +78,7 @@ inline bool parseInputFile(const std::string &filename,
 
       // pairs of (mu,nu) for the mu-nu Wilson loop
       if (gp["W_mu_nu_pairs"]) {
-        for (const auto &pair : gp["W_mu_nu_pairs"]) {
+        for (const auto& pair : gp["W_mu_nu_pairs"]) {
           gaugeObservableParams.W_mu_nu_pairs.push_back(
               IndexArray<2>({pair[0].as<index_t>(), pair[1].as<index_t>()}));
         }
@@ -107,7 +86,7 @@ inline bool parseInputFile(const std::string &filename,
 
       // pairs of (Lmu,Lnu) for the Wilson loop
       if (gp["W_Lmu_Lnu_pairs"]) {
-        for (const auto &pair : gp["W_Lmu_Lnu_pairs"]) {
+        for (const auto& pair : gp["W_Lmu_Lnu_pairs"]) {
           gaugeObservableParams.W_Lmu_Lnu_pairs.push_back(
               IndexArray<2>({pair[0].as<index_t>(), pair[1].as<index_t>()}));
         }
@@ -131,59 +110,146 @@ inline bool parseInputFile(const std::string &filename,
       return false;
     }
     return true;
-  } catch (const YAML::Exception &e) {
+  } catch (const YAML::Exception& e) {
     printf("(GaugeObservableParams) Error parsing input file: %s\n", e.what());
     return false;
   }
 }
 
-// get HMCParams from input file
-inline bool parseInputFile(const std::string &filename, HMCParams &hmcParams) {
+inline bool parseInputFile(const std::string& filename, HMCParams& hmcParams) {
   try {
     YAML::Node config = YAML::LoadFile(filename);
 
     // Parse MetropolisParams
     if (config["HMCParams"]) {
-      const auto &mp = config["HMCParams"];
+      const auto& mp = config["HMCParams"];
       // general parameters
       hmcParams.Ndims = mp["Ndims"].as<index_t>(4);
       hmcParams.L0 = mp["L0"].as<index_t>(32);
       hmcParams.L1 = mp["L1"].as<index_t>(32);
       hmcParams.L2 = mp["L2"].as<index_t>(32);
       hmcParams.L3 = mp["L3"].as<index_t>(32);
-      hmcParams.tau = mp["tau"].as<real_t>(1.0);
       hmcParams.seed = mp["seed"].as<index_t>(1234);
-      hmcParams.nsteps = mp["nsteps"].as<index_t>(10);
-      hmcParams.nstepsGauge = mp["nstepsGauge"].as<index_t>(20);
+
       hmcParams.rngDelta = mp["rngDelta"].as<double>(1.0);
       hmcParams.coldStart = mp["coldStart"].as<bool>(false);
       // parameters specific to the GaugeField
       hmcParams.Nd = mp["Nd"].as<size_t>(4);
       hmcParams.Nc = mp["Nc"].as<size_t>(2);
-      // parameters specific to the Wilson action
-      hmcParams.beta = mp["beta"].as<double>(1.0);
-      // ...
-      // add more parameters above this as needed
     } else {
       printf("Error: HMCParams not found in input file\n");
       return false;
     }
     return true;
-  } catch (const YAML::Exception &e) {
+  } catch (const YAML::Exception& e) {
     printf("(HMC Params) Error parsing input file: %s\n", e.what());
     return false;
   }
 }
 
+inline int parseInputFile(const std::string& filename,
+                          GaugeMonomial_Params& gmparams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse HMCParams
+    if (config["Gauge Monomial"]) {
+      const auto& mp = config["Gauge Monomial"];
+      gmparams.level = mp["level"].as<index_t>(1);
+      gmparams.beta = mp["beta"].as<real_t>(1.0);
+    } else {
+      printf(
+          "Error: You have to provide a  Gauge Monomial  in the input file\n");
+      // TODO: Change back
+      // return false;
+    }
+  } catch (const YAML::Exception& e) {
+    printf("(Gauge Monomial) Error parsing input file: %s\n", e.what());
+    return false;
+  }
+  return true;
+}
+
+inline int parseInputFile(const std::string& filename,
+                          FermionMonomial_Params& fermionParams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse FermionParams
+    if (config["Fermion Monomial"]) {
+      const auto& fp = config["Fermion Monomial"];
+      fermionParams.level = fp["level"].as<index_t>(0);
+      fermionParams.fermion_type = fp["fermion"].as<std::string>("HWilson");
+      fermionParams.Solver = fp["solver"].as<std::string>("CG");
+      fermionParams.RepDim = fp["RepDim"].as<size_t>(4);
+      fermionParams.kappa = fp["kappa"].as<real_t>(0.1);
+
+      fermionParams.tol = fp["tol"].as<real_t>(1e-8);
+    } else {
+      // No Fermions
+      return -1;
+    }
+    return true;
+  } catch (const YAML::Exception& e) {
+    printf("(Fermion Params) Error parsing input file: %s\n", e.what());
+    return false;
+  }
+}
+
+inline int parseInputFile(const std::string& filename,
+                          Integrator_Params& intParams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse Integrator_Params
+    if (config["Integrator"]) {
+      const auto& ip = config["Integrator"];
+
+      intParams.tau = ip["tau"] ? ip["tau"].as<real_t>() : 0.01;
+      intParams.nsteps = ip["nSteps"] ? ip["nSteps"].as<index_t>() : 10;
+
+      if (ip["Monomials"]) {
+        const auto& monomials = ip["Monomials"];
+        if (!monomials.IsSequence()) {
+          printf("Error: 'Monomials' must be a YAML sequence\n");
+          return false;
+        }
+
+        for (const auto& mon : monomials) {
+          auto mono = mon.as<Integrator_Monomial_Params>();
+          intParams.monomials.push_back(mono);
+        }
+        // Sort monomials by level (descending)
+        std::sort(intParams.monomials.begin(), intParams.monomials.end(),
+                  [](const Integrator_Monomial_Params& a,
+                     const Integrator_Monomial_Params& b) {
+                    return a.level < b.level;
+                  });
+      } else {
+        printf("Warning: No monomials found\n");
+      }
+
+    } else {
+      printf("Error: Integrator parameters not found in input file\n");
+      return false;
+    }
+
+    return true;
+  } catch (const YAML::Exception& e) {
+    printf("YAML Error:  %s\n", e.what());
+    return false;
+  }
+}
+
 // get SimulationLoggingParams from input file
-inline bool parseInputFile(const std::string &filename,
-                           SimulationLoggingParams &simParams) {
+inline int parseInputFile(const std::string& filename,
+                          SimulationLoggingParams& simParams) {
   try {
     YAML::Node config = YAML::LoadFile(filename);
 
     // Parse MetropolisParams
     if (config["SimulationLoggingParams"]) {
-      const auto &mp = config["SimulationLoggingParams"];
+      const auto& mp = config["SimulationLoggingParams"];
       // general parameters
       simParams.log_interval = mp["log_interval"].as<size_t>(0);
       simParams.log_filename = mp["log_filename"].as<std::string>("");
@@ -198,9 +264,76 @@ inline bool parseInputFile(const std::string &filename,
       return false;
     }
     return true;
-  } catch (const YAML::Exception &e) {
+  } catch (const YAML::Exception& e) {
     printf("(HMC Params) Error parsing input file: %s\n", e.what());
     return false;
   }
 }
-} // namespace klft
+inline int parseSanityChecks(const Integrator_Params& iparams,
+                             const GaugeMonomial_Params& gmparams,
+                             const FermionMonomial_Params& fparams,
+                             const int resParsef) {
+  // Check if the integrator has at least one monomial
+  if (iparams.monomials.empty()) {
+    printf("Error: Integrator must have at least one monomial\n");
+    return false;
+  }
+
+  // Check if the gauge monomial parameters are set
+  if (gmparams.beta <= 0) {
+    printf("Error: Gauge Monomial beta must be positive\n");
+    // TODO: Change back
+    //  return false;
+  }
+  printf("resParsef: %d\n", resParsef);
+  if (!(resParsef <= 0)) {
+    if (fparams.fermion_type.empty()) {
+      printf("Error: Fermion Monomial type must be specified\n");
+      return false;
+    }
+    if (!(fparams.fermion_type == "HWilson" ||
+          fparams.fermion_type == "Wilson")) {
+      printf("Error: Unsupported Fermion Monomial type: %s\n",
+             fparams.fermion_type.c_str());
+      return false;
+    }
+    // Check for correct solver
+    if (!(fparams.Solver == "CG" && fparams.fermion_type == "HWilson")) {
+      printf(
+          "Error: Unsupported Fermion Monomial solver: %s for Fermion Type: "
+          "%s\n",
+          fparams.Solver.c_str(), fparams.fermion_type.c_str());
+      return false;
+    }
+
+    // Check if the fermion monomial parameters are set
+    if (fparams.RepDim != 4 && fparams.RepDim != 2) {
+      printf("Error: Fermion Monomial RepDim must be 2 or 4\n");
+      return false;
+    }
+    // Check if the fermion monomial parameters are set
+    // if (fparams.kappa < 0) {
+    //   printf("Error: Fermion Monomial kappa must be positive\n");
+    //   return false;
+    // }
+  }
+  return true;
+  //
+}
+
+}  // namespace klft
+namespace YAML {
+template <>
+struct convert<klft::Integrator_Monomial_Params> {
+  static int decode(const Node& node, klft::Integrator_Monomial_Params& rhs) {
+    if (!node["level"]) {
+      printf("Monomial missing required field 'level'\n");
+      return false;
+    }
+    rhs.type = node["Type"] ? node["Type"].as<std::string>() : "Leapfrog";
+    rhs.level = node["level"] ? node["level"].as<klft::index_t>() : 0;
+    rhs.steps = node["steps"] ? node["steps"].as<klft::index_t>() : 20;
+    return true;
+  }
+};
+}  // namespace YAML
diff --git a/include/InputParser.hpp.old b/include/InputParser.hpp.old
new file mode 100644
index 0000000..67712f5
--- /dev/null
+++ b/include/InputParser.hpp.old
@@ -0,0 +1,222 @@
+//******************************************************************************/
+//
+// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
+//
+// KLFT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// KLFT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
+//
+//******************************************************************************/
+
+// this file defines input parser for running different simulations
+// we are going to overload the the fuction parseInputFile for all
+// different Param structs
+
+#pragma once
+#include <yaml-cpp/yaml.h>
+
+#include "FermionParams.hpp"
+#include "GaugeObservable.hpp"
+#include "HMC_Params.hpp"
+#include "Metropolis_Params.hpp"
+
+namespace klft {
+
+// get MetropolisParams from input file
+inline bool parseInputFile(const std::string& filename,
+                           MetropolisParams& metropolisParams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse MetropolisParams
+    if (config["MetropolisParams"]) {
+      const auto& mp = config["MetropolisParams"];
+      // general parameters
+      metropolisParams.Ndims = mp["Ndims"].as<index_t>(4);
+      metropolisParams.L0 = mp["L0"].as<index_t>(32);
+      metropolisParams.L1 = mp["L1"].as<index_t>(32);
+      metropolisParams.L2 = mp["L2"].as<index_t>(32);
+      metropolisParams.L3 = mp["L3"].as<index_t>(32);
+      metropolisParams.nHits = mp["nHits"].as<index_t>(10);
+      metropolisParams.nSweep = mp["nSweep"].as<index_t>(1000);
+      metropolisParams.seed = mp["seed"].as<index_t>(1234);
+      // parameters specific to the GaugeField
+      metropolisParams.Nd = mp["Nd"].as<size_t>(4);
+      metropolisParams.Nc = mp["Nc"].as<size_t>(2);
+      // parameters specific to the Wilson action
+      metropolisParams.beta = mp["beta"].as<double>(1.0);
+      metropolisParams.delta = mp["delta"].as<double>(0.1);
+      // ...
+      // add more parameters above this as needed
+    } else {
+      printf("Error: MetropolisParams not found in input file\n");
+      return false;
+    }
+    return true;
+  } catch (const YAML::Exception& e) {
+    printf("Error parsing input file: %s\n", e.what());
+    return false;
+  }
+}
+
+// get GaugeObservableParams from input file
+inline bool parseInputFile(const std::string& filename,
+                           GaugeObservableParams& gaugeObservableParams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse GaugeObservableParams
+    if (config["GaugeObservableParams"]) {
+      const auto& gp = config["GaugeObservableParams"];
+      // interval between measurements
+      gaugeObservableParams.measurement_interval =
+          gp["measurement_interval"].as<size_t>(0);
+      // whether to measure the plaquette
+      gaugeObservableParams.measure_plaquette =
+          gp["measure_plaquette"].as<bool>(false);
+      // whether to measure the temporal Wilson loop
+      gaugeObservableParams.measure_wilson_loop_temporal =
+          gp["measure_wilson_loop_temporal"].as<bool>(false);
+      // whether to measure the mu-nu Wilson loop
+      gaugeObservableParams.measure_wilson_loop_mu_nu =
+          gp["measure_wilson_loop_mu_nu"].as<bool>(false);
+
+      // pairs of (L,T) for the temporal Wilson loop
+      if (gp["W_temp_L_T_pairs"]) {
+        for (const auto& pair : gp["W_temp_L_T_pairs"]) {
+          gaugeObservableParams.W_temp_L_T_pairs.push_back(
+              IndexArray<2>({pair[0].as<index_t>(), pair[1].as<index_t>()}));
+        }
+      }
+
+      // pairs of (mu,nu) for the mu-nu Wilson loop
+      if (gp["W_mu_nu_pairs"]) {
+        for (const auto& pair : gp["W_mu_nu_pairs"]) {
+          gaugeObservableParams.W_mu_nu_pairs.push_back(
+              IndexArray<2>({pair[0].as<index_t>(), pair[1].as<index_t>()}));
+        }
+      }
+
+      // pairs of (Lmu,Lnu) for the Wilson loop
+      if (gp["W_Lmu_Lnu_pairs"]) {
+        for (const auto& pair : gp["W_Lmu_Lnu_pairs"]) {
+          gaugeObservableParams.W_Lmu_Lnu_pairs.push_back(
+              IndexArray<2>({pair[0].as<index_t>(), pair[1].as<index_t>()}));
+        }
+      }
+
+      // filenames for the measurements
+      gaugeObservableParams.plaquette_filename =
+          gp["plaquette_filename"].as<std::string>("");
+      gaugeObservableParams.W_temp_filename =
+          gp["W_temp_filename"].as<std::string>("");
+      gaugeObservableParams.W_mu_nu_filename =
+          gp["W_mu_nu_filename"].as<std::string>("");
+
+      // whether to write to file
+      gaugeObservableParams.write_to_file = gp["write_to_file"].as<bool>(false);
+
+      // ...
+      // add more parameters above this line as needed
+    } else {
+      printf("Error: GaugeObservableParams not found in input file\n");
+      return false;
+    }
+    return true;
+  } catch (const YAML::Exception& e) {
+    printf("(GaugeObservableParams) Error parsing input file: %s\n", e.what());
+    return false;
+  }
+}
+
+// get HMCParams from input file
+inline bool parseInputFile(const std::string& filename, HMCParams& hmcParams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse MetropolisParams
+    if (config["HMCParams"]) {
+      const auto& mp = config["HMCParams"];
+      // general parameters
+      hmcParams.Ndims = mp["Ndims"].as<index_t>(4);
+      hmcParams.L0 = mp["L0"].as<index_t>(32);
+      hmcParams.L1 = mp["L1"].as<index_t>(32);
+      hmcParams.L2 = mp["L2"].as<index_t>(32);
+      hmcParams.L3 = mp["L3"].as<index_t>(32);
+      hmcParams.tau = mp["tau"].as<real_t>(1.0);
+      hmcParams.seed = mp["seed"].as<index_t>(1234);
+      hmcParams.nsteps = mp["nsteps"].as<index_t>(10);
+      hmcParams.nstepsGauge = mp["nstepsGauge"].as<index_t>(20);
+      hmcParams.rngDelta = mp["rngDelta"].as<double>(1.0);
+      hmcParams.coldStart = mp["coldStart"].as<bool>(false);
+      // parameters specific to the GaugeField
+      hmcParams.Nd = mp["Nd"].as<size_t>(4);
+      hmcParams.Nc = mp["Nc"].as<size_t>(2);
+      // parameters specific to the Wilson action
+      hmcParams.beta = mp["beta"].as<double>(1.0);
+      // ...
+      // add more parameters above this as needed
+    } else {
+      printf("Error: HMCParams not found in input file\n");
+      return false;
+    }
+    return true;
+  } catch (const YAML::Exception& e) {
+    printf("(HMC Params) Error parsing input file: %s\n", e.what());
+    return false;
+  }
+}
+inline bool parseInputFile(const std::string& filename,
+                           FermionParams& fermionParams) {
+  try {
+    YAML::Node config = YAML::LoadFile(filename);
+
+    // Parse FermionParams
+    if (config["FermionParams"]) {
+      const auto& fp = config["FermionParams"];
+      auto fermionType = fp["fermion"].as<std::string>("Wilson");
+      if (fermionType != "wilson" || fermionType != "HWilson") {
+        printf("Error: Unsupported fermion type '%s'\n", fermionType.c_str());
+        return false;
+      }
+
+      fermionParams.fermion_type = fermionType;
+      auto solverType = fp["solver"].as<std::string>("CG");
+      if (solverType != "CG") {
+        printf("Error: Unsupported solver type '%s'\n", solverType.c_str());
+        return false;
+      } else {
+        if (fermionType != "HWilson") {
+          printf("Error: Only HWilson fermion type supports CG solver\n");
+          return false;
+        }
+      }
+
+      fermionParams.rank = fp["Nd"].as<size_t>(4);
+      fermionParams.Nc = fp["Nc"].as<size_t>(2);
+      fermionParams.RepDim = fp["RepDim"].as<size_t>(4);
+      fermionParams.kappa = fp["mass"].as<real_t>(0.1);
+      fermionParams.tol = fp["tol"].as<real_t>(1e-8);
+
+      // ...
+      // add more parameters above this line as needed
+    } else {
+      printf("Error: FermionParams not found in input file\n");
+      return false;
+    }
+    return true;
+  } catch (const YAML::Exception& e) {
+    printf("(Fermion Params) Error parsing input file: %s\n", e.what());
+    return false;
+  }
+}
+}  // namespace klft
diff --git a/include/Integrator.hpp b/include/Integrator.hpp
index 56e6824..0bc6746 100644
--- a/include/Integrator.hpp
+++ b/include/Integrator.hpp
@@ -8,7 +8,7 @@ typedef enum IntegratorType_s { LEAPFROG = 0, LP_LEAPFROG } IntegratorType;
 
 // template <class UpdatePosition, class UpdateMomentum>
 class Integrator : public std::enable_shared_from_this<Integrator> {
-public:
+ public:
   Integrator() = delete;
   virtual ~Integrator() = default;
 
@@ -16,8 +16,11 @@ public:
              std::shared_ptr<Integrator> nested_,
              std::shared_ptr<UpdatePosition> update_q_,
              std::shared_ptr<UpdateMomentum> update_p_)
-      : n_steps(n_steps_), outermost(outermost_), nested(nested_),
-        update_q(update_q_), update_p(update_p_) {};
+      : n_steps(n_steps_),
+        outermost(outermost_),
+        nested(nested_),
+        update_q(update_q_),
+        update_p(update_p_) {};
 
   virtual void integrate(const real_t tau, const bool last_step) const = 0;
   virtual void halfstep(const real_t tau) const = 0;
@@ -30,8 +33,8 @@ public:
 };
 
 // template <class UpdatePosition, class UpdateMomentum>
-class LeapFrog : public Integrator { // <UpdatePosition, UpdateMomentum> {
-public:
+class LeapFrog : public Integrator {  // <UpdatePosition, UpdateMomentum> {
+ public:
   LeapFrog() = delete;
 
   LeapFrog(const size_t n_steps_, const bool outermost_,
@@ -45,13 +48,13 @@ public:
   void halfstep(const real_t tau) const override {
     const real_t eps = tau / n_steps;
     update_p->update(eps * 0.5);
-    if (nested)
-      nested->halfstep(eps);
+    if (nested) nested->halfstep(eps);
   }
 
   void integrate(const real_t tau, const bool last_step) const override {
-    if (outermost)
+    if (outermost) {
       halfstep(tau);
+    }
     const real_t eps = tau / n_steps;
     for (size_t i = 0; i < n_steps - 1; ++i) {
       if (nested) {
@@ -70,12 +73,10 @@ public:
     } else {
       update_q->update(eps);
     }
-    if (!last_step && !outermost)
-      update_p->update(eps);
-    if (outermost)
-      halfstep(tau);
+    if (!last_step && !outermost) update_p->update(eps);
+    if (outermost) halfstep(tau);
   }
 
-}; // class LeapFrog
+};  // class LeapFrog
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/Metropolis.hpp b/include/Metropolis.hpp
index 28bbcb4..c837408 100644
--- a/include/Metropolis.hpp
+++ b/include/Metropolis.hpp
@@ -40,7 +40,8 @@ namespace klft {
 // by default, the function must return the number of
 // accepted updates
 
-template <size_t rank, size_t Nc, class RNG> struct MetropolisGaugeField {
+template <size_t rank, size_t Nc, class RNG>
+struct MetropolisGaugeField {
   // we strictly work with Nd = rank
   constexpr static const size_t Nd = rank;
   // define the gauge field type
@@ -58,13 +59,18 @@ template <size_t rank, size_t Nc, class RNG> struct MetropolisGaugeField {
   // sublattice definitions
   const Kokkos::Array<bool, rank> oddeven;
   // constructor
-  MetropolisGaugeField(const GaugeFieldType &g_in,
-                       const MetropolisParams &params,
-                       const IndexArray<rank> &dimensions,
-                       const ScalarFieldType &nAccepted,
-                       const Kokkos::Array<bool, rank> &oddeven, const RNG &rng)
-      : g_in(g_in), params(params), oddeven(oddeven), rng(rng),
-        dimensions(dimensions), nAccepted(nAccepted) {}
+  MetropolisGaugeField(const GaugeFieldType& g_in,
+                       const MetropolisParams& params,
+                       const IndexArray<rank>& dimensions,
+                       const ScalarFieldType& nAccepted,
+                       const Kokkos::Array<bool, rank>& oddeven,
+                       const RNG& rng)
+      : g_in(g_in),
+        params(params),
+        oddeven(oddeven),
+        rng(rng),
+        dimensions(dimensions),
+        nAccepted(nAccepted) {}
 
   template <typename... Indices>
   KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
@@ -114,12 +120,13 @@ template <size_t rank, size_t Nc, class RNG> struct MetropolisGaugeField {
 // metropolis sweep for SUN gauge fields
 // returns acceptance rate
 template <size_t rank, size_t Nc, class RNG>
-real_t sweep_Metropolis(typename DeviceGaugeFieldType<rank, Nc>::type &g_in,
-                        const MetropolisParams &params, const RNG &rng) {
+real_t sweep_Metropolis(typename DeviceGaugeFieldType<rank, Nc>::type& g_in,
+                        const MetropolisParams& params,
+                        const RNG& rng) {
   // this works strictly for Nd = rank
   constexpr static const size_t Nd = rank;
   // get start and end indices
-  const auto &dimensions = g_in.field.layout().dimension;
+  const auto& dimensions = g_in.field.layout().dimension;
   IndexArray<rank> start;
   IndexArray<rank> end;
   for (index_t i = 0; i < Nd; ++i) {
@@ -156,9 +163,9 @@ real_t sweep_Metropolis(typename DeviceGaugeFieldType<rank, Nc>::type &g_in,
       printf("Current number of accepted steps: %11.6f\n", nAccepted.sum());
     }
     // launch the kernel
-    tune_and_launch_for<rank>("sweep_Metropolis_GaugeField_sublat_" +
-                                  std::to_string(i),
-                              start, end, metropolis);
+    tune_and_launch_for<rank>(
+        "sweep_Metropolis_GaugeField_sublat_" + std::to_string(i), start, end,
+        metropolis);
     Kokkos::fence();
   }
   // reduce the number of accepted updates
@@ -177,13 +184,15 @@ real_t sweep_Metropolis(typename DeviceGaugeFieldType<rank, Nc>::type &g_in,
 }
 
 template <size_t rank, size_t Nc, class RNG, class GaugeFieldType>
-int run_metropolis(GaugeFieldType &g_in,
-                   const MetropolisParams &metropolisParams,
-                   GaugeObservableParams &gaugeObsParams, const RNG &rng) {
+int run_metropolis(GaugeFieldType& g_in,
+                   const MetropolisParams& metropolisParams,
+                   GaugeObservableParams& gaugeObsParams,
+                   const RNG& rng,
+                   const std::string& output_directory) {
   // this algorithm is strictly for Nd = rank
   constexpr const size_t Nd = rank;
   // get the dimensions
-  const auto &dimensions = g_in.dimensions;
+  const auto& dimensions = g_in.dimensions;
   // first we check that all the parameters are correct
   assert(metropolisParams.Ndims == Nd);
   assert(metropolisParams.Nd == Nd);
@@ -215,7 +224,7 @@ int run_metropolis(GaugeFieldType &g_in,
     measureGaugeObservables<rank, Nc>(g_in, gaugeObsParams, step);
   }
   // flush the measurements to the files
-  flushAllGaugeObservables(gaugeObsParams);
+  flushAllGaugeObservables(gaugeObsParams, output_directory);
 
   return 0;
 }
@@ -223,49 +232,58 @@ int run_metropolis(GaugeFieldType &g_in,
 // define run_metropolis for all dimensionalities
 // and gauge groups
 // 2D U(1)
-template int run_metropolis<2, 1>(deviceGaugeField2D<2, 1> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<2, 1>(deviceGaugeField2D<2, 1>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 2D SU(2)
-template int run_metropolis<2, 2>(deviceGaugeField2D<2, 2> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<2, 2>(deviceGaugeField2D<2, 2>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 2D SU(3)
-template int run_metropolis<2, 3>(deviceGaugeField2D<2, 3> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<2, 3>(deviceGaugeField2D<2, 3>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 3D U(1)
-template int run_metropolis<3, 1>(deviceGaugeField3D<3, 1> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<3, 1>(deviceGaugeField3D<3, 1>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 3D SU(2)
-template int run_metropolis<3, 2>(deviceGaugeField3D<3, 2> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<3, 2>(deviceGaugeField3D<3, 2>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 3D SU(3)
-template int run_metropolis<3, 3>(deviceGaugeField3D<3, 3> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<3, 3>(deviceGaugeField3D<3, 3>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 4D U(1)
-template int run_metropolis<4, 1>(deviceGaugeField<4, 1> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<4, 1>(deviceGaugeField<4, 1>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 4D SU(2)
-template int run_metropolis<4, 2>(deviceGaugeField<4, 2> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<4, 2>(deviceGaugeField<4, 2>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 // 4D SU(3)
-template int run_metropolis<4, 3>(deviceGaugeField<4, 3> &g_in,
-                                  const MetropolisParams &metropolisParams,
-                                  GaugeObservableParams &gaugeObsParams,
-                                  const RNGType &rng);
+template int run_metropolis<4, 3>(deviceGaugeField<4, 3>& g_in,
+                                  const MetropolisParams& metropolisParams,
+                                  GaugeObservableParams& gaugeObsParams,
+                                  const RNGType& rng,
+                                  const std::string& output_directory);
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/Monomial.hpp b/include/Monomial.hpp
index 6b3bf64..7a4ec2e 100644
--- a/include/Monomial.hpp
+++ b/include/Monomial.hpp
@@ -10,8 +10,9 @@ typedef enum MonomialType_s {
   KLFT_MONOMIAL_KINETIC
 } MonomialType;
 
-template <typename DGaugeFieldType, typename DAdjFieldType> class Monomial {
-public:
+template <typename DGaugeFieldType, typename DAdjFieldType>
+class Monomial {
+ public:
   // template argument deduction and safety
   static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
   static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
@@ -36,13 +37,14 @@ public:
   virtual MonomialType get_monomial_type() { return monomial_type; }
   virtual void heatbath(HamiltonianField<DGaugeFieldType, DAdjFieldType> h) = 0;
   virtual void accept(HamiltonianField<DGaugeFieldType, DAdjFieldType> h) = 0;
+  virtual void print() = 0;
 
   void reset() {
     H_old = 0.0;
     H_new = 0.0;
   }
 
-  void set_time_scale(const unsigned int &_time_scale) {
+  void set_time_scale(const unsigned int& _time_scale) {
     time_scale = _time_scale;
   }
 
@@ -53,7 +55,7 @@ public:
 
 template <typename DGaugeFieldType, typename DAdjFieldType>
 class KineticMonomial : public Monomial<DGaugeFieldType, DAdjFieldType> {
-public:
+ public:
   KineticMonomial(unsigned int _time_scale)
       : Monomial<DGaugeFieldType, DAdjFieldType>(_time_scale) {
     Monomial<DGaugeFieldType, DAdjFieldType>::monomial_type =
@@ -63,8 +65,13 @@ public:
     Monomial<DGaugeFieldType, DAdjFieldType>::H_old = h.kinetic_energy();
   }
   void accept(HamiltonianField<DGaugeFieldType, DAdjFieldType> h) override {
+    // print_SUNAdj(h.adjoint_field(0, 0, 0, 0, 0),
+    //              " SUNAdj accept step Momentum Monomial");
     Monomial<DGaugeFieldType, DAdjFieldType>::H_new = h.kinetic_energy();
   }
+  void print() override {
+    printf("Kinetic Monomial: %.20f\n", this->get_delta_H());
+  }
 };
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/SUN.hpp b/include/SUN.hpp
index d321366..2157269 100644
--- a/include/SUN.hpp
+++ b/include/SUN.hpp
@@ -23,10 +23,22 @@
 #include "GLOBAL.hpp"
 
 namespace klft {
+template <size_t Nc>
+KOKKOS_FORCEINLINE_FUNCTION void print_SUN(
+    const SUN<Nc>& a, const std::string& name = "SUN Matrix") {
+  printf("%s:\n", name.c_str());
+  for (size_t i = 0; i < Nc; i++) {
+    for (size_t j = 0; j < Nc; j++) {
+      double re = a[i][j].real();
+      double im = a[i][j].imag();
+      printf("[%zu,%zu] = (% .20f, % .20f i)\n", i, j, re, im);
+    }
+  }
+}
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const SUN<Nc> &a,
-                                              const SUN<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const SUN<Nc>& a,
+                                              const SUN<Nc>& b) {
   SUN<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
@@ -43,14 +55,14 @@ KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const SUN<Nc> &a,
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUN<Nc> &a, const SUN<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUN<Nc>& a, const SUN<Nc>& b) {
   SUN<Nc> c = a * b;
   a = c;
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator+(const SUN<Nc> &a,
-                                              const SUN<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator+(const SUN<Nc>& a,
+                                              const SUN<Nc>& b) {
   SUN<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
@@ -63,7 +75,7 @@ KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator+(const SUN<Nc> &a,
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION void operator+=(SUN<Nc> &a, const SUN<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator+=(SUN<Nc>& a, const SUN<Nc>& b) {
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
 #pragma unroll
@@ -74,8 +86,8 @@ KOKKOS_FORCEINLINE_FUNCTION void operator+=(SUN<Nc> &a, const SUN<Nc> &b) {
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator-(const SUN<Nc> &a,
-                                              const SUN<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator-(const SUN<Nc>& a,
+                                              const SUN<Nc>& b) {
   SUN<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
@@ -88,7 +100,7 @@ KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator-(const SUN<Nc> &a,
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION void operator-=(SUN<Nc> &a, const SUN<Nc> &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator-=(SUN<Nc>& a, const SUN<Nc>& b) {
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
 #pragma unroll
@@ -99,7 +111,7 @@ KOKKOS_FORCEINLINE_FUNCTION void operator-=(SUN<Nc> &a, const SUN<Nc> &b) {
 }
 
 template <size_t Nc, typename Tin>
-KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const SUN<Nc> &a, const Tin &b) {
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const SUN<Nc>& a, const Tin& b) {
   SUN<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
@@ -112,7 +124,7 @@ KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const SUN<Nc> &a, const Tin &b) {
 }
 
 template <size_t Nc, typename Tin>
-KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUN<Nc> &a, const Tin &b) {
+KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUN<Nc>& a, const Tin& b) {
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
 #pragma unroll
@@ -121,9 +133,22 @@ KOKKOS_FORCEINLINE_FUNCTION void operator*=(SUN<Nc> &a, const Tin &b) {
     }
   }
 }
+template <size_t Nc>
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const complex_t& a,
+                                              const SUN<Nc>& b) {
+  SUN<Nc> c;
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nc; ++j) {
+      c[i][j] = a * b[i][j];
+    }
+  }
+  return c;
+}
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> conj(const SUN<Nc> &a) {
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> conj(const SUN<Nc>& a) {
   SUN<Nc> c;
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
@@ -136,7 +161,7 @@ KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> conj(const SUN<Nc> &a) {
 }
 
 template <size_t Nc>
-KOKKOS_FORCEINLINE_FUNCTION complex_t trace(const SUN<Nc> &a) {
+KOKKOS_FORCEINLINE_FUNCTION complex_t trace(const SUN<Nc>& a) {
   complex_t c(0.0, 0.0);
 #pragma unroll
   for (size_t i = 0; i < Nc; ++i) {
@@ -144,13 +169,64 @@ KOKKOS_FORCEINLINE_FUNCTION complex_t trace(const SUN<Nc> &a) {
   }
   return c;
 }
+KOKKOS_FORCEINLINE_FUNCTION SUN<1> traceLessAntiHermitian(const SUN<1>& a) {
+  SUN<1> res;
+  res[0][0] = complex_t(0, a[0][0].imag());
+  return res;
+}
+KOKKOS_FORCEINLINE_FUNCTION SUN<2> traceLessAntiHermitian(const SUN<2>& M) {
+  SUN<2> A;
+  complex_t trace = 0.0;
+
+#pragma unroll
+  for (int i = 0; i < 2; ++i) {
+    for (int j = 0; j < 2; ++j) {
+      A[i][j] = 0.5 * (M[i][j] - conj(M[j][i]));  // anti-Hermitian part
+    }
+    trace += A[i][i];
+  }
+
+  complex_t correction = trace / 2.0;
+  for (int i = 0; i < 2; ++i) {
+    A[i][i] -= correction;  // ensure traceless
+  }
+
+  return A;
+}
+
+template <size_t Nc>
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> traceLessAntiHermitian(const SUN<Nc>& a) {
+  SUN<Nc> res;
+  complex_t trace = 0.0;
+
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nc; ++j) {
+      res[i][j] = 0.5 * (a[i][j] - conj(a[j][i]));
+    }
+  }
+
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+    trace += res[i][i];
+  }
+
+  complex_t tr_avg = trace / static_cast<real_t>(Nc);
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+    res[i][i] -= tr_avg;
+  }
+
+  return res;
+}
 
 // random SUN matrix generator
 // need to be defined for each Nc
 
 // template <size_t N = Nc, typename std::enable_if<N == 1, int>::type = 0,
 template <class RNG>
-KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<1> &r, RNG &generator,
+KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<1>& r, RNG& generator,
                                          real_t delta) {
   // SUN<1> r;
   r[0][0] = Kokkos::exp(
@@ -161,7 +237,7 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<1> &r, RNG &generator,
 
 // template <size_t N = Nc, typename std::enable_if<N == 2, int>::type = 0,
 template <class RNG>
-KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<2> &r, RNG &generator,
+KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<2>& r, RNG& generator,
                                          real_t delta) {
   // SUN<2> r;
   real_t alpha =
@@ -180,7 +256,7 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<2> &r, RNG &generator,
 
 // template <size_t N = Nc, typename std::enable_if<N == 3, int>::type = 0,
 template <class RNG>
-KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<3> &r, RNG &generator,
+KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<3>& r, RNG& generator,
                                          real_t delta) {
   // SUN<3> r;
   real_t r1[6], r2[6], norm, fact;
@@ -191,8 +267,7 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<3> &r, RNG &generator,
     }
     norm = Kokkos::sqrt(r1[0] * r1[0] + r1[1] * r1[1] + r1[2] * r1[2] +
                         r1[3] * r1[3] + r1[4] * r1[4] + r1[5] * r1[5]);
-    if (1.0 != (1.0 + norm))
-      break;
+    if (1.0 != (1.0 + norm)) break;
   }
   fact = 1.0 / norm;
   z1[0] = fact * complex_t(r1[0], r1[1]);
@@ -205,8 +280,7 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<3> &r, RNG &generator,
       }
       norm = Kokkos::sqrt(r2[0] * r2[0] + r2[1] * r2[1] + r2[2] * r2[2] +
                           r2[3] * r2[3] + r2[4] * r2[4] + r2[5] * r2[5]);
-      if (1.0 != (1.0 + norm))
-        break;
+      if (1.0 != (1.0 + norm)) break;
     }
     fact = 1.0 / norm;
     z2[0] = fact * complex_t(r2[0], r2[1]);
@@ -221,8 +295,7 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<3> &r, RNG &generator,
         Kokkos::sqrt(z2[0].real() * z2[0].real() + z2[0].imag() * z2[0].imag() +
                      z2[1].real() * z2[1].real() + z2[1].imag() * z2[1].imag() +
                      z2[2].real() * z2[2].real() + z2[2].imag() * z2[2].imag());
-    if (1.0 != (1.0 + norm))
-      break;
+    if (1.0 != (1.0 + norm)) break;
   }
   fact = 1.0 / norm;
   z2[0] *= fact;
@@ -247,7 +320,7 @@ KOKKOS_FORCEINLINE_FUNCTION void randSUN(SUN<3> &r, RNG &generator,
 // this also must be defined for each Nc
 
 KOKKOS_FORCEINLINE_FUNCTION
-SUN<1> restoreSUN(const SUN<1> &a) {
+SUN<1> restoreSUN(const SUN<1>& a) {
   SUN<1> c;
   c[0][0] = a[0][0] / Kokkos::sqrt(a[0][0].real() * a[0][0].real() +
                                    a[0][0].imag() * a[0][0].imag());
@@ -255,13 +328,13 @@ SUN<1> restoreSUN(const SUN<1> &a) {
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-void restoreSUN(SUN<1> &a) {
+void restoreSUN(SUN<1>& a) {
   a[0][0] /= Kokkos::sqrt(a[0][0].real() * a[0][0].real() +
                           a[0][0].imag() * a[0][0].imag());
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-SUN<2> restoreSUN(const SUN<2> &a) {
+SUN<2> restoreSUN(const SUN<2>& a) {
   SUN<2> c;
   real_t norm = Kokkos::sqrt(
       a[0][0].real() * a[0][0].real() + a[0][0].imag() * a[0][0].imag() +
@@ -274,7 +347,7 @@ SUN<2> restoreSUN(const SUN<2> &a) {
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-void restoreSUN(SUN<2> &a) {
+void restoreSUN(SUN<2>& a) {
   real_t norm = Kokkos::sqrt(
       a[0][0].real() * a[0][0].real() + a[0][0].imag() * a[0][0].imag() +
       a[0][1].real() * a[0][1].real() + a[0][1].imag() * a[0][1].imag());
@@ -285,7 +358,7 @@ void restoreSUN(SUN<2> &a) {
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-SUN<3> restoreSUN(const SUN<3> &a) {
+SUN<3> restoreSUN(const SUN<3>& a) {
   SUN<3> c;
   real_t norm0 = Kokkos::sqrt((Kokkos::conj(a[0][0]) * a[0][0] +
                                Kokkos::conj(a[0][1]) * a[0][1] +
@@ -311,7 +384,7 @@ SUN<3> restoreSUN(const SUN<3> &a) {
 }
 
 KOKKOS_FORCEINLINE_FUNCTION
-void restoreSUN(SUN<3> &a) {
+void restoreSUN(SUN<3>& a) {
   real_t norm0 = Kokkos::sqrt((Kokkos::conj(a[0][0]) * a[0][0] +
                                Kokkos::conj(a[0][1]) * a[0][1] +
                                Kokkos::conj(a[0][2]) * a[0][2])
@@ -334,30 +407,4 @@ void restoreSUN(SUN<3> &a) {
   a[1][2] = Kokkos::conj((a[2][0] * a[0][1]) - (a[2][1] * a[0][0]));
 }
 
-// use the Frobenius norm to measure the defect of a unitary matrix
-
-KOKKOS_FORCEINLINE_FUNCTION real_t unitary_defect(const SUN<1> &elem) {
-  return real_t(0.0); // this is not a problem for U1
-}
-
-KOKKOS_FORCEINLINE_FUNCTION real_t unitary_defect(const SUN<2> &elem) {
-  const complex_t a = elem[0][0];
-  const complex_t b = elem[0][1];
-  const complex_t c = elem[1][0];
-  const complex_t d = elem[1][1];
-
-  const real_t ret00 =
-      Kokkos::abs(a) * Kokkos::abs(a) + Kokkos::abs(b) * Kokkos::abs(b) - 1.0;
-  const real_t ret11 =
-      Kokkos::abs(c) * Kokkos::abs(c) + Kokkos::abs(d) * Kokkos::abs(d) - 1.0;
-  const complex_t ret01 = a * Kokkos::conj(c) + b * Kokkos::conj(d);
-
-  return Kokkos::sqrt(ret00 * ret00 + ret11 * ret11 +
-                      real_t(2.0) * Kokkos::abs(ret01) * Kokkos::abs(ret01));
-}
-
-KOKKOS_FORCEINLINE_FUNCTION real_t unitary_defect(const SUN<3> &elem) {
-  return real_t(0.0); // TODO: implement for SU3
-}
-
-} // namespace klft
+}  // namespace klft
\ No newline at end of file
diff --git a/include/SimulationLogging.hpp b/include/SimulationLogging.hpp
index 0477b13..f0bde9e 100644
--- a/include/SimulationLogging.hpp
+++ b/include/SimulationLogging.hpp
@@ -1,13 +1,14 @@
 #pragma once
-#include "GLOBAL.hpp"
 #include <fstream>
 
+#include "GLOBAL.hpp"
+
 namespace klft {
 // define a struct to hold parameters related to the simulation logging
 struct SimulationLoggingParams {
-  size_t log_interval;      // interval between logs
-  std::string log_filename; // filename for the log
-  bool write_to_file;       // whether to write logs to file
+  size_t log_interval;       // interval between logs
+  std::string log_filename;  // filename for the log
+  bool write_to_file;        // whether to write logs to file
 
   // define flags for the different types of logs
   bool log_delta_H;
@@ -24,51 +25,57 @@ struct SimulationLoggingParams {
 
   // constructor to initialize the parameters
   SimulationLoggingParams()
-      : log_interval(0), write_to_file(false), log_delta_H(false),
-        log_acceptance(false), log_accept(false), log_time(false) {}
+      : log_interval(0),
+        write_to_file(false),
+        log_delta_H(false),
+        log_acceptance(false),
+        log_accept(false),
+        log_time(false) {}
 };
 
 // define a function to log simulation information
-inline void
-addLogData(SimulationLoggingParams &params, const size_t step,
-           const real_t _delta_H = 0.0, const real_t _acceptance = 0.0,
-           const bool _accept = false,
-           const real_t _time =
-               0.0) { // TODO: add overloads for different passed parameters
+inline void addLogData(
+    SimulationLoggingParams& params,
+    const size_t step,
+    const real_t _delta_H = 0.0,
+    const real_t _acceptance = 0.0,
+    const bool _accept = false,
+    const real_t _time =
+        0.0) {  // TODO: add overloads for different passed parameters
   if (params.log_interval == 0 || step % params.log_interval != 0 ||
       step == 0) {
     return;
   }
 
-  if (KLFT_VERBOSITY > 0) {
+  if (KLFT_VERBOSITY > 1) {
     printf("Logging Simulation Data\n");
     printf("step: %zu\n", step);
   }
 
   if (params.log_delta_H) {
     params.delta_H.push_back(_delta_H);
-    if (KLFT_VERBOSITY > 0) {
+    if (KLFT_VERBOSITY > 1) {
       printf("delta_H: %11.6f\n", _delta_H);
     }
   }
 
   if (params.log_acceptance) {
     params.acceptance.push_back(_acceptance);
-    if (KLFT_VERBOSITY > 0) {
+    if (KLFT_VERBOSITY > 1) {
       printf("acceptance: %11.6f\n", _acceptance);
     }
   }
 
   if (params.log_accept) {
     params.accept.push_back(_accept);
-    if (KLFT_VERBOSITY > 0) {
+    if (KLFT_VERBOSITY > 1) {
       printf("accept: %s\n", params.accept.back() ? "true" : "false");
     }
   }
 
   if (params.log_time) {
     params.time.push_back(_time);
-    if (KLFT_VERBOSITY > 0) {
+    if (KLFT_VERBOSITY > 1) {
       printf("time: %11.6f\n", _time);
     }
   }
@@ -76,7 +83,8 @@ addLogData(SimulationLoggingParams &params, const size_t step,
   params.log_steps.push_back(step);
 }
 
-inline void flushSimulationLogs(const SimulationLoggingParams &params,
+inline void flushSimulationLogs(const SimulationLoggingParams& params,
+                                const std::string& output_directory,
                                 const bool HEADER = true) {
   // check if write_to_file is enabled
   if (!params.write_to_file) {
@@ -87,7 +95,7 @@ inline void flushSimulationLogs(const SimulationLoggingParams &params,
   }
 
   // open the log file
-  std::ofstream file(params.log_filename, std::ios::app);
+  std::ofstream file(output_directory + params.log_filename, std::ios::app);
   if (!file.is_open()) {
     printf("Error: could not open log file %s\n", params.log_filename.c_str());
     return;
@@ -133,4 +141,4 @@ inline void flushSimulationLogs(const SimulationLoggingParams &params,
   file.close();
 }
 
-} // namespace klft
+}  // namespace klft
\ No newline at end of file
diff --git a/include/Solver.hpp b/include/Solver.hpp
new file mode 100644
index 0000000..9ebc7c3
--- /dev/null
+++ b/include/Solver.hpp
@@ -0,0 +1,132 @@
+//******************************************************************************/
+//
+// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
+//
+// KLFT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// KLFT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
+//
+//******************************************************************************/
+#pragma once
+#include "FieldTypeHelper.hpp"
+#include "GDiracOperator.hpp"
+#include "GLOBAL.hpp"
+#include "SpinorFieldLinAlg.hpp"
+namespace klft {
+
+template <typename Derived, typename DSpinorFieldType, typename DGaugeFieldType>
+class Solver {
+  // template argument deduction and safety
+  static_assert(isDeviceFermionFieldType<DSpinorFieldType>::value);
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  constexpr static size_t rank =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Rank;
+  constexpr static size_t Nc =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::RepDim;
+  static_assert((rank == DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank) &&
+                (Nc == DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc));
+
+ public:
+  using SpinorFieldType = typename DSpinorFieldType::type;
+  using GaugeFieldType = typename DGaugeFieldType::type;
+  const SpinorFieldType b;
+  SpinorFieldType x;  // Solution to DiracOP*x=b
+  DiracOperator<Derived, DSpinorFieldType, DGaugeFieldType> dirac_op;
+  Solver(
+      const SpinorFieldType& b, SpinorFieldType& x,
+      const DiracOperator<Derived, DSpinorFieldType, DGaugeFieldType>& dirac_op)
+      : b(b), x(x), dirac_op(dirac_op) {}
+
+  virtual void solve(const SpinorFieldType& x0, const real_t& tol) = 0;
+};
+// // Deduction guide for Solver
+// template <typename Operator, typename SpinorType>
+// Solver(const SpinorType&, SpinorType&, const Operator&)
+//     -> Solver<typename Operator::Derived,
+//               SpinorType::rank,
+//               SpinorType::Nc,
+//               SpinorType::RepDim>;
+
+template <typename Derived, typename DSpinorFieldType, typename DGaugeFieldType>
+class CGSolver : public Solver<Derived, DSpinorFieldType, DGaugeFieldType> {
+ public:
+  using SpinorFieldType = typename DSpinorFieldType::type;
+  using GaugeFieldType = typename DGaugeFieldType::type;
+  constexpr static size_t rank =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Rank;
+  constexpr static size_t Nc =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DSpinorFieldType>::RepDim;
+  CGSolver() = delete;
+  CGSolver(const SpinorFieldType& b, SpinorFieldType& x,
+           DiracOperator<Derived, DSpinorFieldType, DGaugeFieldType>& dirac_op)
+      : Solver<Derived, DSpinorFieldType, DGaugeFieldType>(b, x, dirac_op) {}
+
+  void solve(const SpinorFieldType& x0, const real_t& tol) override {
+    SpinorFieldType xk(this->dirac_op.params.dimensions, complex_t(0.0, 0.0));
+    Kokkos::deep_copy(xk.field, x0.field);  // x_0
+
+    SpinorFieldType rk = spinor_sub_mul<rank, Nc, RepDim>(
+        this->b,
+        this->dirac_op.applyDdagger(this->dirac_op.applyD(
+            xk)),  // check if this is the right vector to apply dirac_op
+        1.0);      // r_0
+    SpinorFieldType pk(this->dirac_op.params.dimensions, complex_t(0.0, 0.0));
+    Kokkos::deep_copy(pk.field, rk.field);  // p_0                        // d_0
+    real_t rk_norm = spinor_norm<rank, Nc, RepDim>(rk);  //\delta_0
+    int num_iter = 0;
+    while (rk_norm > tol) {
+      const SpinorFieldType apk =
+          this->dirac_op.applyDdagger(this->dirac_op.applyD(pk));  // z = Ad_k
+      const complex_t rkrk = spinor_dot_product<rank, Nc, RepDim>(rk, rk);
+      const complex_t alpha = (rkrk / spinor_dot_product<rank, Nc, RepDim>(
+                                          pk, apk));  // Always real
+      xk = spinor_add_mul<rank, Nc, RepDim>(xk, pk, alpha);
+      rk = spinor_sub_mul<rank, Nc, RepDim>(rk, apk, alpha);
+      const complex_t beta =
+          (spinor_dot_product<rank, Nc, RepDim>(rk, rk) / rkrk);
+      pk = spinor_add_mul<rank, Nc, RepDim>(rk, pk, beta);
+      // Check if swapping is needed of pk and rk, should be correct
+
+      rk_norm = spinor_norm<rank, Nc, RepDim>(rk);
+      num_iter++;
+      if (KLFT_VERBOSITY > 1) {
+        printf("CG Iteration %d: rk_norm = %.15f\n", num_iter, rk_norm);
+        if (KLFT_VERBOSITY > 3) {
+          printf("Norm of (b - A*x) %.15f\n",
+                 spinor_norm<rank, Nc, RepDim>(spinor_sub_mul<rank, Nc, RepDim>(
+                     this->b,
+                     this->dirac_op.applyDdagger(this->dirac_op.applyD(xk)),
+                     1.0)));
+        }
+      }
+    }
+    const real_t ex_res =
+        spinor_norm<rank, Nc, RepDim>(spinor_sub_mul<rank, Nc, RepDim>(
+            this->b, this->dirac_op.applyDdagger(this->dirac_op.applyD(xk)),
+            1.0));
+
+    if (Kokkos::abs(ex_res / spinor_norm<rank, Nc, RepDim>(xk)) > tol) {
+      printf("Roundoff Error, relaunching CG solver with new initial guess\n");
+      this->solve(xk, tol);
+    } else {
+      if (KLFT_VERBOSITY > 1) {
+        printf("CG solver converged in %d iterations\n", num_iter);
+      }
+      this->x = xk;
+    }
+  }
+};
+}  // namespace klft
\ No newline at end of file
diff --git a/include/Spinor.hpp b/include/Spinor.hpp
new file mode 100644
index 0000000..1d3466d
--- /dev/null
+++ b/include/Spinor.hpp
@@ -0,0 +1,246 @@
+//******************************************************************************/
+//
+// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
+//
+// KLFT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// KLFT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
+//
+//******************************************************************************/
+
+// define Spinor operations
+
+#pragma once
+#include "GLOBAL.hpp"
+#include "GammaMatrix.hpp"
+
+namespace klft {
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator*(
+    const SUN<Nc>& U,
+    const Spinor<Nc, Nd>& spinor) {
+  Spinor<Nc, Nd> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nc; j++) {
+#pragma unroll
+      for (size_t k = 0; k < Nd; k++) {
+        res[i][k] += U[i][j] * spinor[j][k];
+      }
+    }
+  }
+  return res;
+}
+// *= makes no sense f spinor gauge link
+
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator*(
+    const complex_t& scalar,
+    const Spinor<Nc, Nd>& spinor) {
+  Spinor<Nc, Nd> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; j++) {
+      res[i][j] = spinor[i][j] * scalar;
+    }
+  }
+  return res;
+}
+// this is for construction of the force matrix, no implicit conjugation,
+// however this would be better for performance
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION SUN<Nc> operator*(const Spinor<Nc, Nd>& a,
+                                              const Spinor<Nc, Nd>& b) {
+  SUN<Nc> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nc; ++j) {
+      res[i][j] = complex_t(0.0, 0.0);
+      for (size_t k = 0; k < Nd; ++k) {
+        res[i][j] += a[i][k] * (b[j][k]);
+      }
+    }
+  }
+  return res;
+}
+
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator*=(Spinor<Nc, Nd>& spinor,
+                                                      const complex_t& scalar) {
+  Spinor<Nc, Nd> res = scalar * spinor;
+  spinor = res;
+  return spinor;
+}
+
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator*(
+    const real_t& scalar,
+    const Spinor<Nc, Nd>& spinor) {
+  Spinor<Nc, Nd> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; j++) {
+      res[i][j] = scalar * spinor[i][j];
+    }
+  }
+  return res;
+}
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator*=(Spinor<Nc, Nd>& spinor,
+                                                      const real_t& scalar) {
+  Spinor<Nc, Nd> res = scalar * spinor;
+  spinor = res;
+  return spinor;
+}
+
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator+(
+    const Spinor<Nc, Nd>& spinor1,
+    const Spinor<Nc, Nd>& spinor2) {
+  Spinor<Nc, Nd> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; j++) {
+      res[i][j] = spinor2[i][j] + spinor1[i][j];
+    }
+  }
+  return res;
+}
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator+=(
+    Spinor<Nc, Nd>& spinor1,
+    const Spinor<Nc, Nd>& spinor2) {
+  Spinor<Nc, Nd> res = spinor1 + spinor2;
+  spinor1 = res;
+  return spinor1;
+}
+
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator-(
+    const Spinor<Nc, Nd>& spinor1,
+    const Spinor<Nc, Nd>& spinor2) {
+  Spinor<Nc, Nd> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; j++) {
+      res[i][j] = spinor1[i][j] - spinor2[i][j];
+    }
+  }
+  return res;
+}
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator-=(
+    Spinor<Nc, Nd>& spinor1,
+    const Spinor<Nc, Nd>& spinor2) {
+  Spinor<Nc, Nd> res = spinor1 - spinor2;
+  spinor1 = res;
+  return spinor1;
+}
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION real_t sqnorm(const Spinor<Nc, Nd>& spinor) {
+  real_t res = 0;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; j++) {
+      res += spinor[i][j].imag() * spinor[i][j].imag() +
+             spinor[i][j].real() * spinor[i][j].real();
+    }
+  }
+  return res;
+}
+
+// Define Gamma Spinor interaction
+// Dirac index and gamma matrix have to have the same dimension
+
+// This is ineficnet because of the sparsity of the gamma matrices
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> operator*(
+    const GammaMat<Nd>& matrix,
+    const Spinor<Nc, Nd>& spinor) {
+  Spinor<Nc, Nd> c;
+#pragma unroll
+  for (size_t i = 0; i < Nc; i++) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; j++) {
+      complex_t val = 0;
+#pragma unroll
+      for (size_t k = 0; k < Nd; k++) {
+        val += matrix(j, k) * spinor[i][k];
+      }
+      c[i][j] = val;
+    }
+  }
+  return c;
+}
+
+// Random generation of Spinors
+template <size_t Nc, size_t Nd, class RNG>
+KOKKOS_FORCEINLINE_FUNCTION void randSpinor(Spinor<Nc, Nd>& r,
+                                            RNG& generator,
+                                            const real_t& mean,
+                                            const real_t& var) {
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; ++j) {
+      r[i][j] =
+          complex_t(generator.normal(mean, var), generator.normal(mean, var));
+    }
+  }
+}
+
+// calculate a^\dagger b
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION complex_t
+spinor_inner_prod(const Spinor<Nc, Nd>& a, const Spinor<Nc, Nd>& b) {
+  complex_t res(0.0, 0.0);
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; ++j) {
+      res += conj(a[i][j]) * b[i][j];
+    }
+  }
+  return res;
+}
+template <size_t Nc, size_t Nd>
+KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, Nd> conj(const Spinor<Nc, Nd>& a) {
+  Spinor<Nc, Nd> res;
+#pragma unroll
+  for (size_t i = 0; i < Nc; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < Nd; ++j) {
+      res[i][j] = conj(a[i][j]);
+    }
+  }
+  return res;
+}
+template <size_t Nc, size_t Nd>
+void print_spinor_int(const Spinor<Nc, Nd>& s, const char* name = "Spinor") {
+  printf("%s:\n", name);
+  for (size_t c = 0; c < Nc; ++c) {
+    printf("  Color %zu:\n", c);
+    for (size_t d = 0; d < Nd; ++d) {
+      double re = s[c][d].real();
+      double im = s[c][d].imag();
+      printf("    [%zu] = (% .20f, % .20f i)\n", d, re, im);
+    }
+  }
+}
+}  // namespace klft
\ No newline at end of file
diff --git a/include/SpinorField.hpp b/include/SpinorField.hpp
new file mode 100644
index 0000000..7d0f496
--- /dev/null
+++ b/include/SpinorField.hpp
@@ -0,0 +1,173 @@
+//******************************************************************************/
+//
+// This file is part of the Kokkos Lattice Field Theory (KLFT) library.
+//
+// KLFT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// KLFT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with KLFT.  If not, see <http://www.gnu.org/licenses/>.
+//
+//******************************************************************************/
+
+// define structs for initializing SUN field
+
+#pragma once
+#include "GLOBAL.hpp"
+#include "Tuner.hpp"
+// Nc number of colors
+// RepDim Dimension of Gamma matrices, Nd = RepDim
+namespace klft {
+template <size_t _Nc, size_t _RepDim>
+struct deviceSpinorField {
+  static const size_t rank = 4;  // SpinorField is always 4D
+  static const size_t Nc = _Nc;
+  static const size_t RepDim =
+      _RepDim;  // RepDim is the dimension of the Gamma matrices
+  deviceSpinorField() = default;
+
+  // initialize all sites to a given value
+
+  deviceSpinorField(const index_t L0, const index_t L1, const index_t L2,
+                    const index_t L3, const complex_t init)
+      : dimensions({L0, L1, L2, L3}) {
+    do_init(L0, L1, L2, L3, field, init);
+  }
+
+  deviceSpinorField(const IndexArray<4>& dimensions, const complex_t init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            init);
+  }
+
+  // initialize all sites to given Spinor
+  deviceSpinorField(const index_t L0, const index_t L1, const index_t L2,
+                    const index_t L3, const Spinor<Nc, RepDim>& init)
+      : dimensions({L0, L1, L2, L3}) {
+    do_init(L0, L1, L2, L3, field, init);
+  }
+  deviceSpinorField(const IndexArray<4>& dimensions,
+                    const Spinor<Nc, RepDim>& init)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            init);
+  }
+
+  // initialize all latice size to random value drawn from a Normal Distribution
+  // N(mean,var)
+  template <class RNG>
+  deviceSpinorField(const IndexArray<4>& dimensions, RNG& rng,
+                    const real_t& mean, const real_t& var)
+      : dimensions(dimensions) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            rng, mean, var);
+  }
+
+  // initialize all latice size to random value drawn from a Normal Distribution
+  // N(mean,var)
+  template <class RNG>
+  deviceSpinorField(const index_t L0, const index_t L1, const index_t L2,
+                    const index_t L3, RNG& rng, const real_t& mean,
+                    const real_t& var)
+      : dimensions({L0, L1, L2, L3}) {
+    do_init(dimensions[0], dimensions[1], dimensions[2], dimensions[3], field,
+            rng, mean, var);
+  }
+
+  // Initialize SpinorField with Single Value
+  void do_init(const index_t L0, const index_t L1, const index_t L2,
+               const index_t L3, SpinorField<Nc, RepDim>& V,
+               const complex_t init) {
+    Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
+    tune_and_launch_for<4>(
+        "init_deviceSpinorField", IndexArray<4>{0, 0, 0, 0},
+        IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+#pragma unroll
+          for (index_t c1 = 0; c1 < Nc; ++c1) {
+#pragma unroll
+            for (index_t c2 = 0; c2 < RepDim; ++c2) {
+              V(i0, i1, i2, i3)[c1][c2] = init;
+            }
+          }
+        });
+    Kokkos::fence();
+  }
+  void do_init(const index_t L0, const index_t L1, const index_t L2,
+               const index_t L3, SpinorField<Nc, RepDim>& V,
+               const Spinor<Nc, RepDim>& init) {
+    Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
+    tune_and_launch_for<4>(
+        "init_deviceSpinorField", IndexArray<4>{0, 0, 0, 0},
+        IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) { V(i0, i1, i2, i3) = init; });
+    Kokkos::fence();
+  }
+  template <class RNG>
+  void do_init(const index_t L0, const index_t L1, const index_t L2,
+               const index_t L3, SpinorField<Nc, RepDim>& V, RNG& rng,
+               const real_t& mean, const real_t& std) {
+    Kokkos::realloc(Kokkos::WithoutInitializing, V, L0, L1, L2, L3);
+    tune_and_launch_for<4>(
+        "init_deviceSpinorField", IndexArray<4>{0, 0, 0, 0},
+        IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+          auto generator = rng.get_state();
+#pragma unroll
+          for (index_t c1 = 0; c1 < Nc; ++c1) {
+#pragma unroll
+            for (index_t c2 = 0; c2 < RepDim; ++c2) {
+              V(i0, i1, i2, i3)
+              [c1][c2] = complex_t(generator.normal(mean, std),
+                                   generator.normal(mean, std));
+            }
+          }
+          // free state here corrct in l.138 of GaugeField it isn't done.
+          rng.free_state(generator);
+        });
+    Kokkos::fence();
+  }
+
+  SpinorField<Nc, RepDim> field;
+  IndexArray<4> dimensions;
+
+  // define accessors
+  template <typename indexType>
+  KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, RepDim>& operator()(
+      const indexType i0, const indexType i1, const indexType i2,
+      const indexType i3) const {
+    return field(i0, i1, i2, i3);
+  }
+
+  template <typename indexType>
+  KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, RepDim>& operator()(
+      const indexType i0, const indexType i1, const indexType i2,
+      const indexType i3) {
+    return field(i0, i1, i2, i3);
+  }
+
+  // define accessors with 4D Kokkos array
+  template <typename indexType>
+  KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, RepDim>& operator()(
+      const Kokkos::Array<indexType, 4> site) const {
+    return field(site[0], site[1], site[2], site[3]);
+  }
+
+  template <typename indexType>
+  KOKKOS_FORCEINLINE_FUNCTION Spinor<Nc, RepDim>& operator()(
+      const Kokkos::Array<indexType, 4> site) {
+    return field(site[0], site[1], site[2], site[3]);
+  }
+};
+
+}  // namespace klft
\ No newline at end of file
diff --git a/include/SpinorFieldLinAlg.hpp b/include/SpinorFieldLinAlg.hpp
new file mode 100644
index 0000000..4b649c7
--- /dev/null
+++ b/include/SpinorFieldLinAlg.hpp
@@ -0,0 +1,175 @@
+#pragma once
+#include "FieldTypeHelper.hpp"
+#include "GLOBAL.hpp"
+#include "Spinor.hpp"
+#include "Tuner.hpp"
+
+//  For  now in an external file, should be in SpinorField.hpp
+namespace klft {
+
+template <size_t rank, size_t Nc, size_t RepDim>
+struct SpinorDotProduct {
+  using SpinorFieldType =
+      typename DeviceSpinorFieldType<rank, Nc, RepDim>::type;
+  const SpinorFieldType a;
+  const SpinorFieldType b;
+  using FieldType = typename DeviceFieldType<rank>::type;
+  FieldType dot_product_per_site;
+
+  const IndexArray<rank> dimensions;
+  SpinorDotProduct(const SpinorFieldType& a, const SpinorFieldType& b,
+                   FieldType& dot_product_per_site,
+                   const IndexArray<rank>& dimensions)
+      : a(a),
+        b(b),
+        dot_product_per_site(dot_product_per_site),
+        dimensions(dimensions) {}
+
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
+    complex_t temp_result = spinor_inner_prod(a(Idcs...), b(Idcs...));
+    dot_product_per_site(Idcs...) = temp_result;
+  }
+};
+
+template <size_t rank, size_t Nc, size_t RepDim>
+KOKKOS_FORCEINLINE_FUNCTION complex_t spinor_dot_product(
+    const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& a,
+    const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& b) {
+  assert(a.dimensions == b.dimensions);
+  static_assert(
+      Kokkos::SpaceAccessibility<
+          typename decltype(a.field)::execution_space,
+          typename decltype(b.field)::memory_space>::accessible,
+      "Execution space of A cannot access memory space of B");  // allow only
+                                                                // device-device
+                                                                // or host-host
+                                                                // interaction
+  complex_t result = 0.0;
+  IndexArray<rank> start;
+  IndexArray<rank> end;
+  for (index_t i = 0; i < rank; ++i) {
+    start[i] = 0;
+    end[i] = a.dimensions[i];
+  }
+  // temporary field for storing results per site
+  // direct reduction is slow
+  // this field will be summed over in the end
+  using FieldType = typename DeviceFieldType<rank>::type;
+  FieldType dot_product_per_site(end, complex_t(0.0, 0.0));
+  SpinorDotProduct<rank, Nc, RepDim> SDP(a, b, dot_product_per_site, end);
+
+  tune_and_launch_for<rank>("SpinorField_dot_product", start, end, SDP);
+  Kokkos::fence();
+  result = dot_product_per_site.sum();
+  Kokkos::fence();
+  return result;
+}
+
+template <size_t rank, size_t Nc, size_t RepDim>
+struct SpinorNorm {
+  using SpinorFieldType =
+      typename DeviceSpinorFieldType<rank, Nc, RepDim>::type;
+  const SpinorFieldType a;
+  using FieldType = typename DeviceScalarFieldType<rank>::type;
+  FieldType norm_per_site;
+  const IndexArray<rank> dimensions;
+
+  SpinorNorm(const SpinorFieldType& a, FieldType& norm_per_site,
+             const IndexArray<rank>& dimensions)
+      : a(a), norm_per_site(norm_per_site), dimensions(dimensions) {}
+
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
+    real_t temp_result = sqnorm(a(Idcs...));
+    norm_per_site(Idcs...) = temp_result;
+  }
+};
+
+template <size_t rank, size_t Nc, size_t RepDim>
+KOKKOS_FORCEINLINE_FUNCTION real_t spinor_norm_sq(
+    const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& a) {
+  real_t result = 0.0;
+  IndexArray<rank> start;
+  IndexArray<rank> end;
+  for (index_t i = 0; i < rank; ++i) {
+    start[i] = 0;
+    end[i] = a.dimensions[i];
+  }
+  // temporary field for storing results per site
+  // direct reduction is slow
+  // this field will be summed over in the end
+  using FieldType = typename DeviceScalarFieldType<rank>::type;
+  real_t init = 0;
+  FieldType norm_per_site(end, init);
+  SpinorNorm<rank, Nc, RepDim> norm(a, norm_per_site, end);
+
+  tune_and_launch_for<rank>("SpinorField_norm", start, end, norm);
+  Kokkos::fence();
+  result = norm_per_site.sum();
+  Kokkos::fence();
+  return result;
+}
+template <size_t rank, size_t Nc, size_t RepDim>
+KOKKOS_FORCEINLINE_FUNCTION real_t
+spinor_norm(const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& a) {
+  return Kokkos::sqrt(spinor_norm_sq<rank, Nc, RepDim>(a));
+}
+
+template <size_t rank, size_t Nc, size_t RepDim>
+struct SpinorAddMul {
+  using SpinorFieldType =
+      typename DeviceSpinorFieldType<rank, Nc, RepDim>::type;
+  const SpinorFieldType a;
+  const SpinorFieldType b;
+  const complex_t alpha;
+  SpinorFieldType c;
+  const IndexArray<rank> dimensions;
+  SpinorAddMul(const SpinorFieldType& a, const SpinorFieldType& b,
+               SpinorFieldType& c, const complex_t& alpha,
+               const IndexArray<rank>& dimensions)
+      : a(a), b(b), c(c), alpha(alpha), dimensions(dimensions) {}
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
+    c(Idcs...) = (a(Idcs...) + (alpha * b(Idcs...)));
+  }
+};
+template <size_t rank, size_t Nc, size_t RepDim>
+typename DeviceSpinorFieldType<rank, Nc,
+                               RepDim>::type KOKKOS_FORCEINLINE_FUNCTION
+spinor_add_mul(const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& a,
+               const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& b,
+               const complex_t& alpha) {
+  assert(a.dimensions == b.dimensions);
+  static_assert(
+      Kokkos::SpaceAccessibility<
+          typename decltype(a.field)::execution_space,
+          typename decltype(b.field)::memory_space>::accessible,
+      "Execution space of A cannot access memory space of B");  // allow only
+                                                                // device-device
+                                                                // or host-host
+                                                                // interaction
+  IndexArray<rank> start;
+  IndexArray<rank> end;
+  for (index_t i = 0; i < rank; ++i) {
+    start[i] = 0;
+    end[i] = a.dimensions[i];
+  }
+  using SpinorFieldType =
+      typename DeviceSpinorFieldType<rank, Nc, RepDim>::type;
+  SpinorFieldType c(end, complex_t(0.0, 0.0));
+  SpinorAddMul<rank, Nc, RepDim> add(a, b, c, alpha, end);
+
+  tune_and_launch_for<rank>("SpinorField_add", start, end, add);
+  Kokkos::fence();
+  return c;
+}
+template <size_t rank, size_t Nc, size_t RepDim>
+typename DeviceSpinorFieldType<rank, Nc, RepDim>::type spinor_sub_mul(
+    const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& a,
+    const typename DeviceSpinorFieldType<rank, Nc, RepDim>::type& b,
+    const complex_t& alpha) {
+  return spinor_add_mul<rank, Nc, RepDim>(a, b, -alpha);
+}
+
+}  // namespace klft
\ No newline at end of file
diff --git a/include/Tuner.hpp b/include/Tuner.hpp
index 1703a13..19c70bc 100644
--- a/include/Tuner.hpp
+++ b/include/Tuner.hpp
@@ -24,8 +24,10 @@
 // in cudaspace
 
 #pragma once
-#include "GLOBAL.hpp"
 #include <fstream>
+#include <iostream>
+
+#include "GLOBAL.hpp"
 
 // define how many times the kernel is run to tune
 #ifndef STREAM_NTIMES
@@ -38,18 +40,19 @@ namespace klft {
 // to store tuned tiling so that tuning is not repeated
 // over multiple kernel calls
 template <class FunctorType>
-size_t get_Functor_hash(const FunctorType &functor) {
+size_t get_Functor_hash(const FunctorType& functor) {
   // this is a very naive hash function
   // should be replaced with a better one
-  return std::hash<const void *>{}(&functor);
+  return std::hash<const void*>{}(&functor);
 }
 
 // define a hash table to look up the tuned tiling
 // this is a very naive hash table
 // should be replaced with a better one
-template <size_t rank> struct TuningHashTable {
+template <size_t rank>
+struct TuningHashTable {
   std::unordered_map<std::string, IndexArray<rank>> table;
-  void insert(const std::string key, const IndexArray<rank> &value) {
+  void insert(const std::string key, const IndexArray<rank>& value) {
     table[key] = value;
   }
   IndexArray<rank> get(const std::string key) { return table[key]; }
@@ -64,13 +67,27 @@ inline TuningHashTable<4> tuning_hash_table_4D;
 inline TuningHashTable<3> tuning_hash_table_3D;
 inline TuningHashTable<2> tuning_hash_table_2D;
 
-template <size_t rank, class FunctorType>
-void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
-                         const IndexArray<rank> &end,
-                         const FunctorType &functor) {
+// Only for debugging purposes
+// template <typename T>
+// void WhatEver(void) {
+//   if constexpr (std::is_void_v<T> == false) {
+//     T t;
+//     std::cout << "Worktag used in tune and launch" << __PRETTY_FUNCTION__
+//               << std::endl;
+
+//     return;
+//   }
+//   std::cout << "No worktag used in tune and launch" << std::endl;
+// }
+
+template <size_t rank, class WorkTag = void, class FunctorType>
+void tune_and_launch_for(std::string functor_id, const IndexArray<rank>& start,
+                         const IndexArray<rank>& end,
+                         const FunctorType& functor) {
+  // WhatEver<WorkTag>();
   // launch kernel if tuning is disabled
   if (!KLFT_TUNING) {
-    const auto policy = Policy<rank>(start, end);
+    const auto policy = Policy<rank, WorkTag>(start, end);
     Kokkos::parallel_for(policy, functor);
     return;
   }
@@ -81,8 +98,9 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
     start_uid += std::to_string(start[i]) + "_";
     end_uid += std::to_string(end[i]) + "_";
   }
-  const std::string functor_uid = functor_id + "_rank_" + std::to_string(rank) +
-                                  "_start_" + start_uid + "end_" + end_uid;
+  const std::string functor_uid = functor_id + "_" + typeid(WorkTag).name() +
+                                  "_rank_" + std::to_string(rank) + "_start_" +
+                                  start_uid + "end_" + end_uid;
   if constexpr (rank == 4) {
     if (tuning_hash_table_4D.contains(functor_uid)) {
       auto tiling = tuning_hash_table_4D.get(functor_uid);
@@ -90,7 +108,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
         printf("Tuning found for kernel %s, tiling: %d %d %d %d\n",
                functor_uid.c_str(), tiling[0], tiling[1], tiling[2], tiling[3]);
       }
-      auto policy = Policy<rank>(start, end, tiling);
+      auto policy = Policy<rank, WorkTag>(start, end, tiling);
       Kokkos::parallel_for(policy, functor);
       return;
     }
@@ -101,7 +119,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
         printf("Tuning found for kernel %s, tiling: %d %d %d %d\n",
                functor_uid.c_str(), tiling[0], tiling[1], tiling[2], tiling[3]);
       }
-      auto policy = Policy<rank>(start, end, tiling);
+      auto policy = Policy<rank, WorkTag>(start, end, tiling);
       Kokkos::parallel_for(policy, functor);
       return;
     }
@@ -112,7 +130,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
         printf("Tuning found for kernel %s, tiling: %d %d %d %d\n",
                functor_uid.c_str(), tiling[0], tiling[1], tiling[2], tiling[3]);
       }
-      auto policy = Policy<rank>(start, end, tiling);
+      auto policy = Policy<rank, WorkTag>(start, end, tiling);
       Kokkos::parallel_for(policy, functor);
       return;
     }
@@ -125,7 +143,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
     printf("Start tuning for kernel %s\n", functor_uid.c_str());
   }
   // if not tuned, tune the functor
-  const auto policy = Policy<rank>(start, end);
+  const auto policy = Policy<rank, WorkTag>(start, end);
   IndexArray<rank> best_tiling;
   for (index_t i = 0; i < rank; i++) {
     best_tiling[i] = 1;
@@ -158,7 +176,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
       fast_ind = fast_ind / 2;
       fast_ind_tiles.push_back(fast_ind);
     }
-    for (auto &tile : fast_ind_tiles) {
+    for (auto& tile : fast_ind_tiles) {
       current_tiling = tile_one;
       current_tiling[0] = tile;
       index_t second_tile = max_tile / tile;
@@ -168,7 +186,8 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
           for (index_t i : {2, 1}) {
             current_tiling[2] = i;
             current_tiling[3] = i;
-            auto tune_policy = Policy<rank>(start, end, current_tiling);
+            auto tune_policy =
+                Policy<rank, WorkTag>(start, end, current_tiling);
             double min_time = std::numeric_limits<double>::max();
             for (int ii = 0; ii < STREAM_NTIMES; ii++) {
               timer.reset();
@@ -190,7 +209,8 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
           for (int64_t i : {2, 1}) {
             current_tiling[2] = i;
             current_tiling[3] = 1;
-            auto tune_policy = Policy<rank>(start, end, current_tiling);
+            auto tune_policy =
+                Policy<rank, WorkTag>(start, end, current_tiling);
             double min_time = std::numeric_limits<double>::max();
             for (int ii = 0; ii < STREAM_NTIMES; ii++) {
               timer.reset();
@@ -211,7 +231,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
         } else {
           current_tiling[2] = 1;
           current_tiling[3] = 1;
-          auto tune_policy = Policy<rank>(start, end, current_tiling);
+          auto tune_policy = Policy<rank, WorkTag>(start, end, current_tiling);
           double min_time = std::numeric_limits<double>::max();
           for (int ii = 0; ii < STREAM_NTIMES; ii++) {
             timer.reset();
@@ -248,7 +268,7 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
   }
   if (KLFT_VERBOSITY > 3) {
     double time_rec = std::numeric_limits<double>::max();
-    auto tune_policy = Policy<rank>(start, end);
+    auto tune_policy = Policy<rank, WorkTag>(start, end);
     for (int ii = 0; ii < STREAM_NTIMES; ii++) {
       timer.reset();
       Kokkos::parallel_for(tune_policy, functor);
@@ -259,9 +279,8 @@ void tune_and_launch_for(std::string functor_id, const IndexArray<rank> &start,
     printf("Speedup: %f\n", time_rec / best_time);
   }
   // run the kernel with the best tiling
-  auto tune_policy = Policy<rank>(start, end, best_tiling);
+  auto tune_policy = Policy<rank, WorkTag>(start, end, best_tiling);
   Kokkos::parallel_for(tune_policy, functor);
-  Kokkos::fence();
   return;
 };
 
@@ -274,23 +293,23 @@ inline void writeTuneCache(std::string cache_file_name) {
     return;
   }
   // write the hash tables to the file
-  for (const auto &entry : tuning_hash_table_4D.table) {
+  for (const auto& entry : tuning_hash_table_4D.table) {
     cache_file << 4 << " " << entry.first << " ";
-    for (const auto &value : entry.second) {
+    for (const auto& value : entry.second) {
       cache_file << value << " ";
     }
     cache_file << "\n";
   }
-  for (const auto &entry : tuning_hash_table_3D.table) {
+  for (const auto& entry : tuning_hash_table_3D.table) {
     cache_file << 3 << " " << entry.first << " ";
-    for (const auto &value : entry.second) {
+    for (const auto& value : entry.second) {
       cache_file << value << " ";
     }
     cache_file << "\n";
   }
-  for (const auto &entry : tuning_hash_table_2D.table) {
+  for (const auto& entry : tuning_hash_table_2D.table) {
     cache_file << 2 << " " << entry.first << " ";
-    for (const auto &value : entry.second) {
+    for (const auto& value : entry.second) {
       cache_file << value << " ";
     }
     cache_file << "\n";
@@ -361,4 +380,4 @@ inline void readTuneCache(std::string cache_file_name) {
   }
 }
 
-} // namespace klft
+}  // namespace klft
\ No newline at end of file
diff --git a/include/UpdateMomentum.hpp b/include/UpdateMomentum.hpp
index eb94a69..cd3d202 100644
--- a/include/UpdateMomentum.hpp
+++ b/include/UpdateMomentum.hpp
@@ -7,7 +7,7 @@
 namespace klft {
 
 class UpdateMomentum : public std::enable_shared_from_this<UpdateMomentum> {
-public:
+ public:
   UpdateMomentum() = delete;
   virtual ~UpdateMomentum() = default;
 
@@ -15,13 +15,13 @@ public:
   // using the given step size
   virtual void update(const real_t step_size) = 0;
 
-protected:
+ protected:
   explicit UpdateMomentum(int Tag) {}
 };
 
 template <typename DGaugeFieldType, typename DAdjFieldType>
 class UpdateMomentumGauge : public UpdateMomentum {
-public:
+ public:
   // template argument deduction and safety
   static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
   static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
@@ -43,10 +43,13 @@ public:
   UpdateMomentumGauge() = delete;
   ~UpdateMomentumGauge() = default;
 
-  UpdateMomentumGauge(GaugeFieldType gauge_field_, AdjFieldType adjoint_field_,
-                      const real_t &beta_)
-      : UpdateMomentum(0), gauge_field(gauge_field_),
-        adjoint_field(adjoint_field_), beta(beta_), eps(0.0) {}
+  UpdateMomentumGauge(GaugeFieldType &gauge_field_,
+                      AdjFieldType &adjoint_field_, const real_t &beta_)
+      : UpdateMomentum(0),
+        gauge_field(gauge_field_),
+        adjoint_field(adjoint_field_),
+        beta(beta_),
+        eps(0.0) {}
   // todo: Add Force as a function instead of it being incorporated into the
   // functor.
 
@@ -57,8 +60,8 @@ public:
     for (index_t mu = 0; mu < rank; ++mu) {
       adjoint_field(Idcs..., mu) -=
           this->eps *
-          ((this->beta / this->Nc) * traceT(this->gauge_field(Idcs..., mu) *
-                                            (this->staple_field(Idcs..., mu))));
+          ((this->beta / this->Nc) * (traceT(this->gauge_field(Idcs..., mu) *
+                                             this->staple_field(Idcs..., mu))));
     }
   }
 
@@ -68,6 +71,7 @@ public:
     for (size_t i = 0; i < rank; ++i) {
       start[i] = 0;
     }
+
     // launch the kernels
     staple_field = stapleField<DGaugeFieldType>(gauge_field);
     Kokkos::fence();
@@ -77,4 +81,4 @@ public:
   }
 };
 
-} // namespace klft
+}  // namespace klft
diff --git a/include/UpdatePosition.hpp b/include/UpdatePosition.hpp
index 6065d2d..7d9e6cd 100644
--- a/include/UpdatePosition.hpp
+++ b/include/UpdatePosition.hpp
@@ -5,7 +5,7 @@
 namespace klft {
 
 class UpdatePosition : public std::enable_shared_from_this<UpdatePosition> {
-public:
+ public:
   UpdatePosition() = delete;
   virtual ~UpdatePosition() = default;
 
@@ -13,13 +13,13 @@ public:
   // using the given step size
   virtual void update(const real_t step_size) = 0;
 
-protected:
+ protected:
   explicit UpdatePosition(int tag) {}
 };
 
 template <size_t rank, size_t Nc>
 class UpdatePositionGauge : public UpdatePosition {
-public:
+ public:
   using GaugeFieldType = typename DeviceGaugeFieldType<rank, Nc>::type;
   using AdjFieldType = typename DeviceAdjFieldType<rank, Nc>::type;
   GaugeFieldType gauge_field;
@@ -29,9 +29,12 @@ public:
   UpdatePositionGauge() = delete;
   ~UpdatePositionGauge() = default;
 
-  UpdatePositionGauge(GaugeFieldType gauge_field_, AdjFieldType adjoint_field_)
-      : UpdatePosition(0), gauge_field(gauge_field_),
-        adjoint_field(adjoint_field_), eps(0.0) {}
+  UpdatePositionGauge(GaugeFieldType& gauge_field_,
+                      AdjFieldType& adjoint_field_)
+      : UpdatePosition(0),
+        gauge_field(gauge_field_),
+        adjoint_field(adjoint_field_),
+        eps(0.0) {}
 
   template <typename... Indices>
   KOKKOS_FORCEINLINE_FUNCTION void operator()(const Indices... Idcs) const {
@@ -48,10 +51,12 @@ public:
     for (size_t i = 0; i < rank; ++i) {
       start[i] = 0;
     }
+    // print_SUN(gauge_field(0, 0, 0, 0, 0), "Before Guage Position update");
     // launch the kernel
     tune_and_launch_for<rank>("UpdatePositionGauge", start,
                               gauge_field.dimensions, *this);
     Kokkos::fence();
+    // print_SUN(gauge_field(0, 0, 0, 0, 0), "After Guage Position update");
   }
 };
-} // namespace klft
+}  // namespace klft
diff --git a/include/klft.hpp b/include/klft.hpp
index a88d3f4..7817f04 100644
--- a/include/klft.hpp
+++ b/include/klft.hpp
@@ -3,7 +3,9 @@
 
 namespace klft {
 
-int Metropolis(const std::string &input_file);
+int Metropolis(const std::string& input_file,
+               const std::string& output_directory);
 
-int HMC_execute(const std::string &input_file);
-} // namespace klft
+int HMC_execute(const std::string& input_file,
+                const std::string& output_directory);
+}  // namespace klft
diff --git a/include/updateMomentumFermion.hpp b/include/updateMomentumFermion.hpp
new file mode 100644
index 0000000..ad1eebd
--- /dev/null
+++ b/include/updateMomentumFermion.hpp
@@ -0,0 +1,153 @@
+#pragma once
+#include "FermionParams.hpp"
+#include "GDiracOperator.hpp"
+#include "IndexHelper.hpp"
+#include "SpinorFieldLinAlg.hpp"
+#include "UpdateMomentum.hpp"
+namespace klft {
+
+template <typename DFermionFieldType, typename DGaugeFieldType,
+          typename DAdjFieldType, class Derived, class Solver>
+class UpdateMomentumFermion : public UpdateMomentum {
+  static_assert(isDeviceFermionFieldType<DFermionFieldType>::value);
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
+  constexpr static size_t rank =
+      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
+  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
+  constexpr static size_t RepDim =
+      DeviceFermionFieldTypeTraits<DFermionFieldType>::RepDim;
+  static_assert(rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank &&
+                    rank ==
+                        DeviceFermionFieldTypeTraits<DFermionFieldType>::Rank &&
+                    Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc &&
+                    Nc == DeviceFermionFieldTypeTraits<DFermionFieldType>::Nc,
+                "Rank and Nc must match between gauge, adjoint, and fermion "
+                "field types.");
+
+ public:
+  // Define Tags for different Operators
+  struct HWilsonDiracOperatorTag {};
+
+  using FermionField = typename DFermionFieldType::type;
+  using GaugeFieldType = typename DeviceGaugeFieldType<rank, Nc>::type;
+  using AdjFieldType = typename DeviceAdjFieldType<rank, Nc>::type;
+  GaugeFieldType gauge_field;
+  AdjFieldType momentum;
+  const diracParams<rank, RepDim> params;
+  // \phi = D R, where R gaussian random field.
+  FermionField phi;
+
+  FermionField chi;
+  FermionField chi_alt;
+  const real_t tol;
+  real_t eps;
+
+  UpdateMomentumFermion() = delete;
+  ~UpdateMomentumFermion() = default;
+
+  UpdateMomentumFermion(FermionField& phi_, GaugeFieldType& gauge_field_,
+                        AdjFieldType& adjoint_field_,
+                        const diracParams<rank, RepDim>& params_,
+                        const real_t& tol_)
+      : UpdateMomentum(0),
+        phi(phi_),
+        gauge_field(gauge_field_),
+        momentum(adjoint_field_),
+        params(params_),
+        eps(0.0),
+        tol(tol_) {}
+
+  // Implemntation of the force correspondig to the Hermitian Wilson dirac
+  // Operator
+  //* S_F  = \phi^{\dagger} * M^{-1} * \phi
+  //* dS_F = - \phi^{\dagger} * M^{-1} * dM * M^{-1} * \phi = - \chi^{\dagger} *
+  // dM * \chi
+  //* where \chi = M^{-1} * \phi
+  //* and M = Q*Q^{\dagger}
+  // Using that dS_f = - \chi ^{\dagger} (\pdv{D}{U_\mu(x)}D^\dagger + D
+  // \pdv{D^\dagger}{U_\mu(x)})\chi which can be simplified to -\chi^\dagger
+  // (\pdv{D}{U_\mu(x)}D^\dagger+ (\pdv{D}{U_\mu(x)}D^\dagger)^\dagger) =
+  // -2Re(\chi^\dagger \pdv{D}{U_\mu(x)}D^\dagger \chi)
+
+  // The Derivative of the Hermtian Wilson Dirac Operator should be given as
+  // \pdv{D(x,y)}{U_\mu(z)} = - \kappa \gamma_5 \delta_{x,z} (1-\gamma_mu)T_i
+  // U_mu(z)\delta_{x+\mu,y}
+  // +\kappa \gamma_5 \delta_{x+\mu,y} (1+\gamma_\mu) t_i
+  // U_\mu(z)^\dagger\delta_{z,y} <- Have to Check this
+  template <typename... Indices>
+  KOKKOS_FORCEINLINE_FUNCTION void operator()(HWilsonDiracOperatorTag,
+                                              const Indices... Idcs) const {
+    // Update the momentum of the fermion field
+#pragma unroll
+    for (size_t mu = 0; mu < rank; ++mu) {
+      auto xm = shift_index_minus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+      auto xp = shift_index_plus_bc<rank, size_t>(
+          Kokkos::Array<size_t, rank>{Idcs...}, mu, 1, 3, -1,
+          this->params.dimensions);
+      auto first_term =
+          (xp.second * -this->params.kappa) *
+          ((this->params.gamma_id - this->params.gammas[mu]) *
+           (this->gauge_field(Idcs..., mu) * this->chi_alt(xp.first)));
+      auto second_term =
+          (xp.second * this->params.kappa) *
+          ((this->params.gamma_id + this->params.gammas[mu]) *
+           (conj(this->gauge_field(Idcs..., mu)) * this->chi_alt(Idcs...)));
+      // The first multiplication makes the force matrix
+      auto total_term =
+          conj(chi(Idcs...)) * (this->params.gamma5 * first_term) +
+          conj(chi(xp.first)) * (this->params.gamma5 * second_term);
+
+      auto derv = 2 * this->eps * total_term;
+      // if (Kokkos::Array<size_t, rank>{Idcs...} ==
+      //     Kokkos::Array<size_t, rank>{0, 0, 0, 0}) {
+      //   print_SUN(traceLessAntiHermitian(derv), "SUN Force Matrix ");
+      //   print_SUNAdj(traceT(traceLessAntiHermitian(derv)), "Adj Force
+      //   MAtrix");
+      // }
+
+      // Taking the Real part is handled by the traceT
+      momentum(Idcs..., mu) -= traceT(traceLessAntiHermitian(
+          derv));  // in leap frog therese the minus sign here
+    }
+  }
+
+  void update(const real_t step_size) override {
+    eps = step_size;
+
+    IndexArray<rank> start;
+    Derived D(gauge_field, this->params);
+    FermionField x(this->params.dimensions, complex_t(0.0, 0.0));
+    FermionField x0(this->params.dimensions, complex_t(0.0, 0.0));
+    // print_spinor_int(this->phi(0, 0, 0, 0),
+    //                  "Spinor s_in(0,0,0,0) in update Momentum Fermion");
+    Solver solver(this->phi, x, D);
+    if (KLFT_VERBOSITY > 4) {
+      printf("Solving insde updateMomentumFermion:");
+    }
+
+    solver.solve(x0, this->tol);
+    this->chi = solver.x;
+    this->chi_alt = D.applyDdagger(this->chi);
+    // print_spinor_int(solver.x(0, 0, 0, 0),
+    //                  "solver.x after solve (should be the same as chi)");
+    // print_spinor_int(this->chi(0, 0, 0, 0), "chi after solve");
+    // print_SUN(gauge_field(0, 0, 0, 0, 0), "In GaugeField in
+    // Fermionmomentum");
+    for (size_t i = 0; i < rank; ++i) {
+      start[i] = 0;
+    }
+    // auto before = this->momentum(0, 0, 0, 0, 0);
+
+    // launch the kernel
+    tune_and_launch_for<rank, HWilsonDiracOperatorTag>(
+        "UpdateMomentumFermion", start, gauge_field.dimensions, *this);
+    Kokkos::fence();
+    // print_SUNAdj(this->momentum(0, 0, 0, 0, 0), "SUNAdj after update
+    // Fermion");
+  }
+};
+
+}  // namespace klft
diff --git a/lib/HMC_exec.cpp b/lib/HMC_exec.cpp
index 0218a84..81aee71 100644
--- a/lib/HMC_exec.cpp
+++ b/lib/HMC_exec.cpp
@@ -1,16 +1,201 @@
-#include "HMC_exec.hpp"
+#include "../include/HMC.hpp"
 #include "../include/InputParser.hpp"
 #include "../include/klft.hpp"
 #include "AdjointSUN.hpp"
+#include "FermionParams.hpp"
 #include "FieldTypeHelper.hpp"
 #include "GaugeObservable.hpp"
 #include "HMC_Params.hpp"
-
+#include "Integrator.hpp"
+#include "SimulationLogging.hpp"
+#include "UpdateMomentum.hpp"
+#include "UpdatePosition.hpp"
+#include "updateMomentumFermion.hpp"
 using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
 
 namespace klft {
 
-int HMC_execute(const std::string &input_file) {
+// this will not work, have also give it the fields, for Fermions one has to do
+// more (probably)
+// Still need to add check for different Dirac Operators
+template <typename DGaugeFieldType,
+          typename DAdjFieldType,
+          typename DSpinorFieldType>
+std::shared_ptr<Integrator> createIntegrator(
+    typename DGaugeFieldType::type& g_in,
+    typename DAdjFieldType::type& a_in,
+    typename DSpinorFieldType::type& s_in,
+    const Integrator_Params& integratorParams,
+    const GaugeMonomial_Params& gaugeMonomialParams,
+    const FermionMonomial_Params& fermionParams,
+    const int& resParsef) {
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
+  constexpr static size_t rank =
+      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
+  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
+  static_assert((rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank) &&
+                (Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc));
+  constexpr const size_t Nd = rank;
+  using GaugeField = typename DGaugeFieldType::type;
+  using AdjointField = typename DAdjFieldType::type;
+  // Create the integrator based on the type
+  if (integratorParams.monomials.empty()) {
+    printf("Error: Integrator must have at least one monomial\n");
+    return nullptr;
+  }
+  // startingpoit of integrator chain
+  std::shared_ptr<Integrator> nested_integrator = nullptr;
+  for (const auto& monomial : integratorParams.monomials) {
+    std::shared_ptr<Integrator> integrator = nullptr;
+    if (monomial.level == 0) {
+      // if the level is 0, we create a new integrator with nullptr as inner
+      // integrator
+      if (gaugeMonomialParams.level == 0) {
+        UpdatePositionGauge<Nd, Nc> update_q(g_in, a_in);
+        UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType> update_p(
+            g_in, a_in, gaugeMonomialParams.beta);
+        if (monomial.type == "Leapfrog") {
+          integrator = std::make_shared<LeapFrog>(
+              monomial.steps,
+              monomial.level == integratorParams.monomials.back().level,
+              nullptr, std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+              std::make_shared<
+                  UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>>(
+                  update_p));
+        } else {
+          integrator = std::make_shared<LeapFrog>(
+              monomial.steps,
+              monomial.level == integratorParams.monomials.back().level,
+              nullptr, std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+              std::make_shared<
+                  UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>>(
+                  update_p));
+        }
+
+      } else if (fermionParams.level == 0 && resParsef > 0) {
+        // if the level is 0, we create a new integrator with nullptr as inner
+        // integrator
+        if (fermionParams.RepDim == 4) {
+          auto diracParams =
+              getDiracParams<rank>(g_in.dimensions, fermionParams);
+          UpdatePositionGauge<Nd, Nc> update_q(g_in, a_in);
+          UpdateMomentumFermion<
+              DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+              HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+              CGSolver<HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                       DSpinorFieldType, DGaugeFieldType>>
+              update_p(s_in, g_in, a_in, diracParams, fermionParams.tol);
+
+          if (monomial.type == "Leapfrog") {
+            integrator = std::make_shared<LeapFrog>(
+                monomial.steps,
+                monomial.level == integratorParams.monomials.back().level,
+                nullptr,
+                std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+                std::make_shared<UpdateMomentumFermion<
+                    DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+                    HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                    CGSolver<
+                        HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                        DSpinorFieldType, DGaugeFieldType>>>(update_p));
+
+          } else {
+            integrator = std::make_shared<LeapFrog>(
+                monomial.steps,
+                monomial.level == integratorParams.monomials.back().level,
+                nullptr,
+                std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+                std::make_shared<UpdateMomentumFermion<
+                    DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+                    HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                    CGSolver<
+                        HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                        DSpinorFieldType, DGaugeFieldType>>>(update_p));
+          }
+        } else {
+          printf("Error: Fermion RepDim must be 4\n");
+          return nullptr;
+        }
+      }
+      nested_integrator = integrator;
+    } else if (gaugeMonomialParams.level == monomial.level) {
+      // if the level is the same, we create a new integrator with the
+      // previous one as inner integrator
+      UpdatePositionGauge<Nd, Nc> update_q(g_in, a_in);
+      UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType> update_p(
+          g_in, a_in, gaugeMonomialParams.beta);
+      if (monomial.type == "Leapfrog") {
+        integrator = std::make_shared<LeapFrog>(
+            monomial.steps,
+            monomial.level == integratorParams.monomials.back().level,
+            nested_integrator,
+            std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+            std::make_shared<
+                UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>>(update_p));
+
+      } else {
+        integrator = std::make_shared<LeapFrog>(
+            monomial.steps,
+            monomial.level == integratorParams.monomials.back().level,
+            nested_integrator,
+            std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+            std::make_shared<
+                UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>>(update_p));
+      }
+
+    } else if (fermionParams.level == monomial.level && resParsef > 0) {
+      // if the level is 0, we create a new integrator with nullptr as inner
+      // integrator
+      if (fermionParams.RepDim == 4) {
+        auto diracParams = getDiracParams<rank>(g_in.dimensions, fermionParams);
+
+        UpdatePositionGauge<Nd, Nc> update_q(g_in, a_in);
+        UpdateMomentumFermion<
+            DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+            HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+            CGSolver<HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                     DSpinorFieldType, DGaugeFieldType>>
+            update_p(s_in, g_in, a_in, diracParams, fermionParams.tol);
+
+        if (monomial.type == "Leapfrog") {
+          integrator = std::make_shared<LeapFrog>(
+              monomial.steps,
+              monomial.level == integratorParams.monomials.back().level,
+              nested_integrator,
+              std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+              std::make_shared<UpdateMomentumFermion<
+                  DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+                  HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                  CGSolver<
+                      HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                      DSpinorFieldType, DGaugeFieldType>>>(update_p));
+        } else {
+          integrator = std::make_shared<LeapFrog>(
+              monomial.steps,
+              monomial.level == integratorParams.monomials.back().level,
+              nested_integrator,
+              std::make_shared<UpdatePositionGauge<Nd, Nc>>(update_q),
+              std::make_shared<UpdateMomentumFermion<
+                  DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+                  HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                  CGSolver<
+                      HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>,
+                      DSpinorFieldType, DGaugeFieldType>>>(update_p));
+        }
+      } else {
+        printf("Error: Fermion RepDim must be 4\n");
+        return nullptr;
+      }
+    }
+    nested_integrator = integrator;
+  }
+
+  return nested_integrator;
+}
+
+int HMC_execute(const std::string& input_file,
+                const std::string& output_directory) {
   // get verbosity from environment
   const int verbosity = std::getenv("KLFT_VERBOSITY")
                             ? std::atoi(std::getenv("KLFT_VERBOSITY"))
@@ -23,7 +208,7 @@ int HMC_execute(const std::string &input_file) {
   // if tuning is enbled, check if the user has set the
   // KLFT_CACHE_FILE environment variable
   if (tuning) {
-    const char *cache_file = std::getenv("KLFT_CACHE_FILE");
+    const char* cache_file = std::getenv("KLFT_CACHE_FILE");
     // if it exists, read the cache
     if (cache_file) {
       if (KLFT_VERBOSITY > 0) {
@@ -33,346 +218,172 @@ int HMC_execute(const std::string &input_file) {
     }
   }
   HMCParams hmcParams;
+  // parse the input file for HMC parameters
+  if (!parseInputFile(input_file, hmcParams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  Integrator_Params integratorParams;
   GaugeObservableParams gaugeObsParams;
-  SimulationLoggingParams simLogParams;
   if (!parseInputFile(input_file, gaugeObsParams)) {
     printf("Error parsing input file\n");
     return -1;
   }
-  if (!parseInputFile(input_file, hmcParams)) {
+  if (!parseInputFile(input_file, integratorParams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  FermionMonomial_Params fermionParams;
+  auto resParsef = parseInputFile(input_file, fermionParams);
+  if (resParsef == 0) {
+    printf("Error parsing input file\n");
+    return -1;
+  } else if (resParsef < 0) {
+    printf("Info: No Fermion Monomial detected, skipping\n");
+  }
+  GaugeMonomial_Params gaugeMonomialParams;
+  if (!parseInputFile(input_file, gaugeMonomialParams)) {
     printf("Error parsing input file\n");
     return -1;
   }
+  SimulationLoggingParams simLogParams;
   if (!parseInputFile(input_file, simLogParams)) {
     printf("Error parsing input file\n");
     return -1;
   }
+  if (!parseSanityChecks(integratorParams, gaugeMonomialParams, fermionParams,
+                         resParsef)) {
+    printf("Error in sanity checks\n");
+    return -1;
+  }
+
+  //   FermionParams fparams;
+  //   if (!parseInputFile(input_file, fparams)) {
+  //     printf("Error parsing input file\n");
+  //     return -1;
+  //   }
   // print the parameters
   hmcParams.print();
-  // initialize RNG
+  integratorParams.print();
+  //   gaugeObsParams.print();
+  if (resParsef > 0) {
+    fermionParams.print();
+  }
+
+  gaugeMonomialParams.print();
   RNGType rng(hmcParams.seed);
 
-  // initialize gauge field and run hmc
-  // based on the system parameters
-  // case 4D
-  if (hmcParams.coldStart) {
-    if (hmcParams.Ndims == 4) {
-      // case U(1)
-      if (hmcParams.Nc == 1) {
-        using DGaugeFieldType = DeviceGaugeFieldType<4, 1>;
-        using DAdjFieldType = DeviceAdjFieldType<4, 1>;
-        typename DGaugeFieldType::type dev_g_U1_4D(hmcParams.L0, hmcParams.L1,
-                                                   hmcParams.L2, hmcParams.L3,
-                                                   identitySUN<1>());
-        typename DAdjFieldType::type dev_a_U1_4D(hmcParams.L0, hmcParams.L1,
-                                                 hmcParams.L2, hmcParams.L3,
-                                                 traceT(identitySUN<1>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_U1_4D),
-            typename DAdjFieldType::type(dev_a_U1_4D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(2)
-      else if (hmcParams.Nc == 2) {
-        using DGaugeFieldType = DeviceGaugeFieldType<4, 2>;
-        using DAdjFieldType = DeviceAdjFieldType<4, 2>;
-        typename DGaugeFieldType::type dev_g_SU2_4D(hmcParams.L0, hmcParams.L1,
-                                                    hmcParams.L2, hmcParams.L3,
-                                                    identitySUN<2>());
-        typename DAdjFieldType::type dev_a_SU2_4D(hmcParams.L0, hmcParams.L1,
-                                                  hmcParams.L2, hmcParams.L3,
-                                                  traceT(identitySUN<2>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_SU2_4D),
-            typename DAdjFieldType::type(dev_a_SU2_4D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(3)
-      // else if (hmcParams.Nc == 3) {
-      //   using DGaugeFieldType = DeviceGaugeFieldType<4, 3>;
-      //   using DAdjFieldType = DeviceAdjFieldType<4, 3>;
-      //   typename DGaugeFieldType::type dev_g_SU3_4D(hmcParams.L0,
-      //   hmcParams.L1,
-      //                                              hmcParams.L2,
-      //                                              hmcParams.L3,
-      //                                              identitySUN<3>());
-      //   typename DAdjFieldType::type dev_a_SU3_4D(hmcParams.L0, hmcParams.L1,
-      //                                            hmcParams.L2, hmcParams.L3,
-      //                                            traceT(identitySUN<3>()));
-      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
-      //       typename DGaugeFieldType::type(dev_g_SU3_4D),
-      //       typename DAdjFieldType::type(dev_a_SU3_4D),
-      //       hmcParams, gaugeObsParams, simLogParams, rng);
-      // }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
-    }
-    // case 3D
-    else if (hmcParams.Ndims == 3) {
-      // case U(1)
-      if (hmcParams.Nc == 1) {
-        using DGaugeFieldType = DeviceGaugeFieldType<3, 1>;
-        using DAdjFieldType = DeviceAdjFieldType<3, 1>;
-        typename DGaugeFieldType::type dev_g_U1_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, identitySUN<1>());
-        typename DAdjFieldType::type dev_a_U1_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<1>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_U1_3D),
-            typename DAdjFieldType::type(dev_a_U1_3D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(2)
-      else if (hmcParams.Nc == 2) {
-        using DGaugeFieldType = DeviceGaugeFieldType<3, 2>;
-        using DAdjFieldType = DeviceAdjFieldType<3, 2>;
-        typename DGaugeFieldType::type dev_g_SU2_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, identitySUN<2>());
-        typename DAdjFieldType::type dev_a_SU2_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<2>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_SU2_3D),
-            typename DAdjFieldType::type(dev_a_SU2_3D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(3)
-      // else if (hmcParams.Nc == 3) {
-      //   using DGaugeFieldType = DeviceGaugeFieldType<3, 3>;
-      //   using DAdjFieldType = DeviceAdjFieldType<3, 3>;
-      //   typename DGaugeFieldType::type dev_g_SU3_3D(hmcParams.L0,
-      //   hmcParams.L1,
-      //                                              hmcParams.L2,
-      //                                              identitySUN<3>());
-      //   typename DAdjFieldType::type dev_a_SU3_3D(hmcParams.L0, hmcParams.L1,
-      //                                            hmcParams.L2,
-      //                                            traceT(identitySUN<3>()));
-      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
-      //       typename DGaugeFieldType::type(dev_g_SU3_3D),
-      //       typename DAdjFieldType::type(dev_a_SU3_3D),
-      //       hmcParams, gaugeObsParams, simLogParams, rng);
-      // }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
-    }
-    // case 2D
-    else if (hmcParams.Ndims == 2) {
-      // case U(1)
-      if (hmcParams.Nc == 1) {
-        using DGaugeFieldType = DeviceGaugeFieldType<2, 1>;
-        using DAdjFieldType = DeviceAdjFieldType<2, 1>;
-        typename DGaugeFieldType::type dev_g_U1_2D(hmcParams.L0, hmcParams.L1,
-                                                   identitySUN<1>());
-        typename DAdjFieldType::type dev_a_U1_2D(hmcParams.L0, hmcParams.L1,
-                                                 traceT(identitySUN<1>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_U1_2D),
-            typename DAdjFieldType::type(dev_a_U1_2D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(2)
-      else if (hmcParams.Nc == 2) {
-        using DGaugeFieldType = DeviceGaugeFieldType<2, 2>;
-        using DAdjFieldType = DeviceAdjFieldType<2, 2>;
-        typename DGaugeFieldType::type dev_g_SU2_2D(hmcParams.L0, hmcParams.L1,
-                                                    identitySUN<2>());
-        typename DAdjFieldType::type dev_a_SU2_2D(hmcParams.L0, hmcParams.L1,
-                                                  traceT(identitySUN<2>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_SU2_2D),
-            typename DAdjFieldType::type(dev_a_SU2_2D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(3)
-      // else if (hmcParams.Nc == 3) {
-      //   using DGaugeFieldType = DeviceGaugeFieldType<2, 3>;
-      //   using DAdjFieldType = DeviceAdjFieldType<2, 3>;
-      //   typename DGaugeFieldType::type dev_g_SU3_2D(hmcParams.L0,
-      //   hmcParams.L1,
-      //                                              identitySUN<3>());
-      //   typename DAdjFieldType::type dev_a_SU3_2D(hmcParams.L0, hmcParams.L1,
-      //                                            traceT(identitySUN<3>()));
-      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
-      //       typename DGaugeFieldType::type(dev_g_SU3_2D),
-      //       typename DAdjFieldType::type(dev_a_SU3_2D),
-      //       hmcParams, gaugeObsParams, simLogParams, rng);
-      // }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
-    }
-  } else {
-    if (hmcParams.Ndims == 4) {
-      // case U(1)
-      if (hmcParams.Nc == 1) {
-        using DGaugeFieldType = DeviceGaugeFieldType<4, 1>;
-        using DAdjFieldType = DeviceAdjFieldType<4, 1>;
-        typename DGaugeFieldType::type dev_g_U1_4D(hmcParams.L0, hmcParams.L1,
-                                                   hmcParams.L2, hmcParams.L3,
-                                                   rng, hmcParams.rngDelta);
-        typename DAdjFieldType::type dev_a_U1_4D(hmcParams.L0, hmcParams.L1,
-                                                 hmcParams.L2, hmcParams.L3,
-                                                 traceT(identitySUN<1>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_U1_4D),
-            typename DAdjFieldType::type(dev_a_U1_4D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(2)
-      else if (hmcParams.Nc == 2) {
-        using DGaugeFieldType = DeviceGaugeFieldType<4, 2>;
-        using DAdjFieldType = DeviceAdjFieldType<4, 2>;
-        typename DGaugeFieldType::type dev_g_SU2_4D(hmcParams.L0, hmcParams.L1,
-                                                    hmcParams.L2, hmcParams.L3,
-                                                    rng, hmcParams.rngDelta);
-        typename DAdjFieldType::type dev_a_SU2_4D(hmcParams.L0, hmcParams.L1,
-                                                  hmcParams.L2, hmcParams.L3,
-                                                  traceT(identitySUN<2>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_SU2_4D),
-            typename DAdjFieldType::type(dev_a_SU2_4D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(3)
-      // else if (hmcParams.Nc == 3) {
-      //   using DGaugeFieldType = DeviceGaugeFieldType<4, 3>;
-      //   using DAdjFieldType = DeviceAdjFieldType<4, 3>;
-      //   typename DGaugeFieldType::type dev_g_SU3_4D(hmcParams.L0,
-      //   hmcParams.L1,
-      //                                              hmcParams.L2,
-      //                                              hmcParams.L3, rng,
-      //                                              hmcParams.rngDelta);
-      //   typename DAdjFieldType::type dev_a_SU3_4D(hmcParams.L0, hmcParams.L1,
-      //                                            hmcParams.L2, hmcParams.L3,
-      //                                            traceT(identitySUN<3>()));
-      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
-      //       typename DGaugeFieldType::type(dev_g_SU3_4D),
-      //       typename DAdjFieldType::type(dev_a_SU3_4D),
-      //       hmcParams, gaugeObsParams, simLogParams, rng);
-      // }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
-    }
-    // case 3D
-    else if (hmcParams.Ndims == 3) {
-      // case U(1)
-      if (hmcParams.Nc == 1) {
-        using DGaugeFieldType = DeviceGaugeFieldType<3, 1>;
-        using DAdjFieldType = DeviceAdjFieldType<3, 1>;
-        typename DGaugeFieldType::type dev_g_U1_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, rng, hmcParams.rngDelta);
-        typename DAdjFieldType::type dev_a_U1_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<1>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_U1_3D),
-            typename DAdjFieldType::type(dev_a_U1_3D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(2)
-      else if (hmcParams.Nc == 2) {
-        using DGaugeFieldType = DeviceGaugeFieldType<3, 2>;
-        using DAdjFieldType = DeviceAdjFieldType<3, 2>;
-        typename DGaugeFieldType::type dev_g_SU2_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, rng, hmcParams.rngDelta);
-        typename DAdjFieldType::type dev_a_SU2_3D(
-            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<2>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_SU2_3D),
-            typename DAdjFieldType::type(dev_a_SU2_3D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(3)
-      // else if (hmcParams.Nc == 3) {
-      //   using DGaugeFieldType = DeviceGaugeFieldType<3, 3>;
-      //   using DAdjFieldType = DeviceAdjFieldType<3, 3>;
-      //   typename DGaugeFieldType::type dev_g_SU3_3D(hmcParams.L0,
-      //   hmcParams.L1,
-      //                                              hmcParams.L2,
-      //                                              rng, hmcParams.rngDelta);
-      //   typename DAdjFieldType::type dev_a_SU3_3D(hmcParams.L0, hmcParams.L1,
-      //                                            hmcParams.L2,
-      //                                            traceT(identitySUN<3>()));
-      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
-      //       typename DGaugeFieldType::type(dev_g_SU3_3D),
-      //       typename DAdjFieldType::type(dev_a_SU3_3D),
-      //       hmcParams, gaugeObsParams, simLogParams, rng);
-      // }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
-    }
-    // case 2D
-    else if (hmcParams.Ndims == 2) {
-      // case U(1)
-      if (hmcParams.Nc == 1) {
-        using DGaugeFieldType = DeviceGaugeFieldType<2, 1>;
-        using DAdjFieldType = DeviceAdjFieldType<2, 1>;
-        typename DGaugeFieldType::type dev_g_U1_2D(hmcParams.L0, hmcParams.L1,
-                                                   rng, hmcParams.rngDelta);
-        typename DAdjFieldType::type dev_a_U1_2D(hmcParams.L0, hmcParams.L1,
-                                                 traceT(identitySUN<1>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_U1_2D),
-            typename DAdjFieldType::type(dev_a_U1_2D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(2)
-      else if (hmcParams.Nc == 2) {
-        using DGaugeFieldType = DeviceGaugeFieldType<2, 2>;
-        using DAdjFieldType = DeviceAdjFieldType<2, 2>;
-        typename DGaugeFieldType::type dev_g_SU2_2D(hmcParams.L0, hmcParams.L1,
-                                                    rng, hmcParams.rngDelta);
-        typename DAdjFieldType::type dev_a_SU2_2D(hmcParams.L0, hmcParams.L1,
-                                                  traceT(identitySUN<2>()));
-        run_HMC<DGaugeFieldType, DAdjFieldType>(
-            typename DGaugeFieldType::type(dev_g_SU2_2D),
-            typename DAdjFieldType::type(dev_a_SU2_2D), hmcParams,
-            gaugeObsParams, simLogParams, rng);
-      }
-      // case SU(3)
-      // else if (hmcParams.Nc == 3) {
-      //   using DGaugeFieldType = DeviceGaugeFieldType<2, 3>;
-      //   using DAdjFieldType = DeviceAdjFieldType<2, 3>;
-      //   typename DGaugeFieldType::type dev_g_SU3_2D(hmcParams.L0,
-      //   hmcParams.L1,
-      //                                              rng, hmcParams.rngDelta);
-      //   typename DAdjFieldType::type dev_a_SU3_2D(hmcParams.L0, hmcParams.L1,
-      //                                            traceT(identitySUN<3>()));
-      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
-      //       typename DGaugeFieldType::type(dev_g_SU3_2D),
-      //       typename DAdjFieldType::type(dev_a_SU3_2D),
-      //       hmcParams, gaugeObsParams, simLogParams, rng);
-      // }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
-    }
+  // Start building the Fields
+  using DGaugeFieldType = DeviceGaugeFieldType<4, 2>;
+  using DAdjFieldType = DeviceAdjFieldType<4, 2>;
+  using DSpinorFieldType = DeviceSpinorFieldType<4, 2, 4>;
+  typename DGaugeFieldType::type g_in(hmcParams.L0, hmcParams.L1, hmcParams.L2,
+                                      hmcParams.L3, rng, hmcParams.rngDelta);
+  typename DAdjFieldType::type a_in(hmcParams.L0, hmcParams.L1, hmcParams.L2,
+                                    hmcParams.L3, traceT(identitySUN<2>()));
+  typename DSpinorFieldType::type s_in(hmcParams.L0, hmcParams.L1, hmcParams.L2,
+                                       hmcParams.L3, 0);
+  // typename DSpinorFieldType::type f_in(hmcParams.L0, hmcParams.L1,
+  // hmcParams.L2,
+  //                                      hmcParams.L3, complex_t(0.0, 0.0));
+
+  // Buid. the Integrator
+  auto testIntegrator =
+      createIntegrator<DGaugeFieldType, DAdjFieldType, DSpinorFieldType>(
+          g_in, a_in, s_in, integratorParams, gaugeMonomialParams,
+          fermionParams, resParsef);
+  using HField = HamiltonianField<DGaugeFieldType, DAdjFieldType>;
+  HField hamiltonian_field = HField(g_in, a_in);
+
+  // Warning Works only for the specific setup
+  // auto casted = std::dynamic_pointer_cast<UpdateMomentumFermion<
+  //     DSpinorFieldType, DGaugeFieldType, DAdjFieldType,
+  //     HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>>>(
+  //     testIntegrator->update_p);
+  // if (!testIntegrator) {
+  //   printf("Error creating integrator\n");
+  //   return -1;
+  // }
+  // auto& spinorField = casted->chi;
+  // using HField = HamiltonianField<DGaugeFieldType, DAdjFieldType>;
+  // using Update_Q = UpdatePositionGauge<4, 2>;
+  // using Update_P = UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>;
+
+  // HField hamiltonian_field = HField(g_in, a_in);
+  // Update_Q update_q(g_in, a_in);
+  // Update_P update_p(g_in, a_in, gaugeMonomialParams.beta);
+  // // the integrate might need to be passed into the run_HMC as an
+  // argument as it
+  // // contains a large amount of design decisions
+  // std::shared_ptr<LeapFrog> testIntegrator =
+  //     std::make_shared<LeapFrog>(integratorParams.monomials[0].steps,
+  //     true,
+  //                                nullptr,
+  //                                std::make_shared<Update_Q>(update_q),
+  //                                std::make_shared<Update_P>(update_p));
+  const auto& dimensions = g_in.dimensions;
+  // first we check that all the parameters are correct
+
+  // for test make stuff manually
+  // now define and run the hmc
+  std::mt19937 mt(hmcParams.seed);
+  std::uniform_real_distribution<real_t> dist(0.0, 1.0);
+  using HMC = HMC<DGaugeFieldType, DAdjFieldType, RNGType>;
+  HMC hmc(integratorParams, hamiltonian_field, testIntegrator, rng, dist, mt);
+  hmc.add_gauge_monomial(gaugeMonomialParams.beta, 0);
+  hmc.add_kinetic_monomial(0);
+  if (resParsef > 0) {
+    auto diracParams = getDiracParams<4>(g_in.dimensions, fermionParams);
+
+    using DiracOperator =
+        HWilsonDiracOperator<DSpinorFieldType, DGaugeFieldType>;
+    hmc.add_fermion_monomial<
+        DiracOperator,
+        CGSolver<DiracOperator, DSpinorFieldType, DGaugeFieldType>,
+        DSpinorFieldType>(s_in, diracParams, fermionParams.tol, rng, 0);
+    /* code */
   }
-  // if tuning is enabled, write the cache file
-  if (KLFT_TUNING) {
-    const char *cache_file = std::getenv("KLFT_CACHE_FILE");
-    if (cache_file) {
-      writeTuneCache(cache_file);
-    } else {
-      printf("KLFT_CACHE_FILE not set\n");
+
+  // timer to measure the time per step
+  Kokkos::Timer timer;
+  bool accept;
+  real_t acc_sum{0.0};
+  real_t acc_rate{0.0};
+  // hmc loop
+  for (size_t step = 0; step < integratorParams.nsteps; ++step) {
+    timer.reset();
+
+    // perform hmc_step
+    accept = hmc.hmc_step();
+
+    const real_t time = timer.seconds();
+    acc_sum += static_cast<real_t>(accept);
+    acc_rate = acc_sum / static_cast<real_t>(step + 1);
+
+    if (KLFT_VERBOSITY > 0) {
+      printf("Step: %ld, accepted: %ld, Acceptance rate: %f, Time: %f\n", step,
+             static_cast<size_t>(accept), acc_rate, time);
     }
+    // measure the gauge observables
+    measureGaugeObservables<4, 2>(g_in, gaugeObsParams, step);
+    addLogData(simLogParams, step, hmc.delta_H, acc_rate, accept, time);
+    // TODO:make flushAllGaugeObservables append the Observables to the
+    // files
+    // -> don't lose all progress when the simulation is interupted if (step
+    // % 50
+    // == 0) {
+    //   // flush every 50 steps as well to not lose data on program
+    //   interuption
+    //   // TODO: this should be set by the Params
+    //   flushAllGaugeObservables(gaugeObsParams);
+    // }
   }
-
+  // flush the measurements to the files
+  flushAllGaugeObservables(gaugeObsParams, output_directory);
+  flushSimulationLogs(simLogParams, output_directory);
+  printf("Total Acceptance rate: %f, Didn't Accept %f Configs", acc_rate,
+         acc_sum);
   return 0;
+  // return 1;
 }
-
-} // namespace klft
+}  // namespace klft
diff --git a/lib/HMC_exec.cpp.old b/lib/HMC_exec.cpp.old
new file mode 100644
index 0000000..0044701
--- /dev/null
+++ b/lib/HMC_exec.cpp.old
@@ -0,0 +1,349 @@
+#include "HMC_exec.hpp"
+
+#include "../include/InputParser.hpp"
+#include "../include/klft.hpp"
+#include "AdjointSUN.hpp"
+#include "FermionParams.hpp"
+#include "FieldTypeHelper.hpp"
+#include "GaugeObservable.hpp"
+#include "HMC_Params.hpp"
+
+using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
+
+namespace klft {
+
+int HMC_execute(const std::string& input_file) {
+  // get verbosity from environment
+  const int verbosity = std::getenv("KLFT_VERBOSITY")
+                            ? std::atoi(std::getenv("KLFT_VERBOSITY"))
+                            : 0;
+  setVerbosity(verbosity);
+  // get tuning from environment
+  const int tuning =
+      std::getenv("KLFT_TUNING") ? std::atoi(std::getenv("KLFT_TUNING")) : 0;
+  setTuning(tuning);
+  // if tuning is enbled, check if the user has set the
+  // KLFT_CACHE_FILE environment variable
+  if (tuning) {
+    const char* cache_file = std::getenv("KLFT_CACHE_FILE");
+    // if it exists, read the cache
+    if (cache_file) {
+      if (KLFT_VERBOSITY > 0) {
+        printf("Reading cache file: %s\n", cache_file);
+      }
+      readTuneCache(cache_file);
+    }
+  }
+  HMCParams hmcParams;
+  GaugeObservableParams gaugeObsParams;
+  if (!parseInputFile(input_file, gaugeObsParams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  if (!parseInputFile(input_file, hmcParams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  FermionParams fparams;
+  if (!parseInputFile(input_file, fparams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  // print the parameters
+  hmcParams.print();
+  fparams.print();
+  // initialize RNG
+  RNGType rng(hmcParams.seed);
+
+  // initialize gauge field and run hmc
+  // based on the system parameters
+  // case 4D
+  if (hmcParams.coldStart) {
+    if (hmcParams.Ndims == 4) {
+      // case U(1)
+      if (hmcParams.Nc == 1) {
+        using DGaugeFieldType = DeviceGaugeFieldType<4, 1>;
+        using DAdjFieldType = DeviceAdjFieldType<4, 1>;
+        typename DGaugeFieldType::type dev_g_U1_4D(hmcParams.L0, hmcParams.L1,
+                                                   hmcParams.L2, hmcParams.L3,
+                                                   identitySUN<1>());
+        typename DAdjFieldType::type dev_a_U1_4D(hmcParams.L0, hmcParams.L1,
+                                                 hmcParams.L2, hmcParams.L3,
+                                                 traceT(identitySUN<1>()));
+        
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_U1_4D, dev_a_U1_4D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(2)
+      else if (hmcParams.Nc == 2) {
+        using DGaugeFieldType = DeviceGaugeFieldType<4, 2>;
+        using DAdjFieldType = DeviceAdjFieldType<4, 2>;
+        typename DGaugeFieldType::type dev_g_SU2_4D(hmcParams.L0, hmcParams.L1,
+                                                    hmcParams.L2, hmcParams.L3,
+                                                    identitySUN<2>());
+        typename DAdjFieldType::type dev_a_SU2_4D(hmcParams.L0, hmcParams.L1,
+                                                  hmcParams.L2, hmcParams.L3,
+                                                  traceT(identitySUN<2>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_SU2_4D, dev_a_SU2_4D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(3)
+      // else if (hmcParams.Nc == 3) {
+      //   using DGaugeFieldType = DeviceGaugeFieldType<4, 3>;
+      //   using DAdjFieldType = DeviceAdjFieldType<4, 3>;
+      //   typename DGaugeFieldType::type dev_g_SU3_4D(hmcParams.L0,
+      //   hmcParams.L1,
+      //                                              hmcParams.L2,
+      //                                              hmcParams.L3,
+      //                                              identitySUN<3>());
+      //   typename DAdjFieldType::type dev_a_SU3_4D(hmcParams.L0, hmcParams.L1,
+      //                                            hmcParams.L2, hmcParams.L3,
+      //                                            traceT(identitySUN<3>()));
+      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
+      //       dev_g_SU3_4D, dev_a_SU3_4D, hmcParams, gaugeObsParams, rng);
+      // }
+      // case SU(N)
+      else {
+        printf("Error: Unsupported gauge group\n");
+        return -1;
+      }
+    }
+    // case 3D
+    else if (hmcParams.Ndims == 3) {
+      // case U(1)
+      if (hmcParams.Nc == 1) {
+        using DGaugeFieldType = DeviceGaugeFieldType<3, 1>;
+        using DAdjFieldType = DeviceAdjFieldType<3, 1>;
+        typename DGaugeFieldType::type dev_g_U1_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, identitySUN<1>());
+        typename DAdjFieldType::type dev_a_U1_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<1>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_U1_3D, dev_a_U1_3D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(2)
+      else if (hmcParams.Nc == 2) {
+        using DGaugeFieldType = DeviceGaugeFieldType<3, 2>;
+        using DAdjFieldType = DeviceAdjFieldType<3, 2>;
+        typename DGaugeFieldType::type dev_g_SU2_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, identitySUN<2>());
+        typename DAdjFieldType::type dev_a_SU2_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<2>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_SU2_3D, dev_a_SU2_3D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(3)
+      // else if (hmcParams.Nc == 3) {
+      //   using DGaugeFieldType = DeviceGaugeFieldType<3, 3>;
+      //   using DAdjFieldType = DeviceAdjFieldType<3, 3>;
+      //   typename DGaugeFieldType::type dev_g_SU3_3D(hmcParams.L0,
+      //   hmcParams.L1,
+      //                                              hmcParams.L2,
+      //                                              identitySUN<3>());
+      //   typename DAdjFieldType::type dev_a_SU3_3D(hmcParams.L0, hmcParams.L1,
+      //                                            hmcParams.L2,
+      //                                            traceT(identitySUN<3>()));
+      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
+      //       dev_g_SU3_3D, dev_a_SU3_3D, hmcParams, gaugeObsParams, rng);
+      // }
+      // case SU(N)
+      else {
+        printf("Error: Unsupported gauge group\n");
+        return -1;
+      }
+    }
+    // case 2D
+    else if (hmcParams.Ndims == 2) {
+      // case U(1)
+      if (hmcParams.Nc == 1) {
+        using DGaugeFieldType = DeviceGaugeFieldType<2, 1>;
+        using DAdjFieldType = DeviceAdjFieldType<2, 1>;
+        typename DGaugeFieldType::type dev_g_U1_2D(hmcParams.L0, hmcParams.L1,
+                                                   identitySUN<1>());
+        typename DAdjFieldType::type dev_a_U1_2D(hmcParams.L0, hmcParams.L1,
+                                                 traceT(identitySUN<1>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_U1_2D, dev_a_U1_2D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(2)
+      else if (hmcParams.Nc == 2) {
+        using DGaugeFieldType = DeviceGaugeFieldType<2, 2>;
+        using DAdjFieldType = DeviceAdjFieldType<2, 2>;
+        typename DGaugeFieldType::type dev_g_SU2_2D(hmcParams.L0, hmcParams.L1,
+                                                    identitySUN<2>());
+        typename DAdjFieldType::type dev_a_SU2_2D(hmcParams.L0, hmcParams.L1,
+                                                  traceT(identitySUN<2>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_SU2_2D, dev_a_SU2_2D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(3)
+      // else if (hmcParams.Nc == 3) {
+      //   using DGaugeFieldType = DeviceGaugeFieldType<2, 3>;
+      //   using DAdjFieldType = DeviceAdjFieldType<2, 3>;
+      //   typename DGaugeFieldType::type dev_g_SU3_2D(hmcParams.L0,
+      //   hmcParams.L1,
+      //                                              identitySUN<3>());
+      //   typename DAdjFieldType::type dev_a_SU3_2D(hmcParams.L0, hmcParams.L1,
+      //                                            traceT(identitySUN<3>()));
+      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
+      //       dev_g_SU3_2D, dev_a_SU3_2D, hmcParams, gaugeObsParams, rng);
+      // }
+      // case SU(N)
+      else {
+        printf("Error: Unsupported gauge group\n");
+        return -1;
+      }
+    }
+  } else {
+    if (hmcParams.Ndims == 4) {
+      // case U(1)
+      if (hmcParams.Nc == 1) {
+        using DGaugeFieldType = DeviceGaugeFieldType<4, 1>;
+        using DAdjFieldType = DeviceAdjFieldType<4, 1>;
+        typename DGaugeFieldType::type dev_g_U1_4D(hmcParams.L0, hmcParams.L1,
+                                                   hmcParams.L2, hmcParams.L3,
+                                                   rng, hmcParams.rngDelta);
+        typename DAdjFieldType::type dev_a_U1_4D(hmcParams.L0, hmcParams.L1,
+                                                 hmcParams.L2, hmcParams.L3,
+                                                 traceT(identitySUN<1>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_U1_4D, dev_a_U1_4D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(2)
+      else if (hmcParams.Nc == 2) {
+        using DGaugeFieldType = DeviceGaugeFieldType<4, 2>;
+        using DAdjFieldType = DeviceAdjFieldType<4, 2>;
+        typename DGaugeFieldType::type dev_g_SU2_4D(hmcParams.L0, hmcParams.L1,
+                                                    hmcParams.L2, hmcParams.L3,
+                                                    rng, hmcParams.rngDelta);
+        typename DAdjFieldType::type dev_a_SU2_4D(hmcParams.L0, hmcParams.L1,
+                                                  hmcParams.L2, hmcParams.L3,
+                                                  traceT(identitySUN<2>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_SU2_4D, dev_a_SU2_4D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(3)
+      // else if (hmcParams.Nc == 3) {
+      //   using DGaugeFieldType = DeviceGaugeFieldType<4, 3>;
+      //   using DAdjFieldType = DeviceAdjFieldType<4, 3>;
+      //   typename DGaugeFieldType::type dev_g_SU3_4D(hmcParams.L0,
+      //   hmcParams.L1,
+      //                                              hmcParams.L2,
+      //                                              hmcParams.L3, rng,
+      //                                              hmcParams.rngDelta);
+      //   typename DAdjFieldType::type dev_a_SU3_4D(hmcParams.L0, hmcParams.L1,
+      //                                            hmcParams.L2, hmcParams.L3,
+      //                                            traceT(identitySUN<3>()));
+      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
+      //       dev_g_SU3_4D, dev_a_SU3_4D, hmcParams, gaugeObsParams, rng);
+      // }
+      // case SU(N)
+      else {
+        printf("Error: Unsupported gauge group\n");
+        return -1;
+      }
+    }
+    // case 3D
+    else if (hmcParams.Ndims == 3) {
+      // case U(1)
+      if (hmcParams.Nc == 1) {
+        using DGaugeFieldType = DeviceGaugeFieldType<3, 1>;
+        using DAdjFieldType = DeviceAdjFieldType<3, 1>;
+        typename DGaugeFieldType::type dev_g_U1_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, rng, hmcParams.rngDelta);
+        typename DAdjFieldType::type dev_a_U1_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<1>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_U1_3D, dev_a_U1_3D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(2)
+      else if (hmcParams.Nc == 2) {
+        using DGaugeFieldType = DeviceGaugeFieldType<3, 2>;
+        using DAdjFieldType = DeviceAdjFieldType<3, 2>;
+        typename DGaugeFieldType::type dev_g_SU2_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, rng, hmcParams.rngDelta);
+        typename DAdjFieldType::type dev_a_SU2_3D(
+            hmcParams.L0, hmcParams.L1, hmcParams.L2, traceT(identitySUN<2>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_SU2_3D, dev_a_SU2_3D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(3)
+      // else if (hmcParams.Nc == 3) {
+      //   using DGaugeFieldType = DeviceGaugeFieldType<3, 3>;
+      //   using DAdjFieldType = DeviceAdjFieldType<3, 3>;
+      //   typename DGaugeFieldType::type dev_g_SU3_3D(hmcParams.L0,
+      //   hmcParams.L1,
+      //                                              hmcParams.L2,
+      //                                              rng, hmcParams.rngDelta);
+      //   typename DAdjFieldType::type dev_a_SU3_3D(hmcParams.L0, hmcParams.L1,
+      //                                            hmcParams.L2,
+      //                                            traceT(identitySUN<3>()));
+      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
+      //       dev_g_SU3_3D, dev_a_SU3_3D, hmcParams, gaugeObsParams, rng);
+      // }
+      // case SU(N)
+      else {
+        printf("Error: Unsupported gauge group\n");
+        return -1;
+      }
+    }
+    // case 2D
+    else if (hmcParams.Ndims == 2) {
+      // case U(1)
+      if (hmcParams.Nc == 1) {
+        using DGaugeFieldType = DeviceGaugeFieldType<2, 1>;
+        using DAdjFieldType = DeviceAdjFieldType<2, 1>;
+        typename DGaugeFieldType::type dev_g_U1_2D(hmcParams.L0, hmcParams.L1,
+                                                   rng, hmcParams.rngDelta);
+        typename DAdjFieldType::type dev_a_U1_2D(hmcParams.L0, hmcParams.L1,
+                                                 traceT(identitySUN<1>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_U1_2D, dev_a_U1_2D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(2)
+      else if (hmcParams.Nc == 2) {
+        using DGaugeFieldType = DeviceGaugeFieldType<2, 2>;
+        using DAdjFieldType = DeviceAdjFieldType<2, 2>;
+        typename DGaugeFieldType::type dev_g_SU2_2D(hmcParams.L0, hmcParams.L1,
+                                                    rng, hmcParams.rngDelta);
+        typename DAdjFieldType::type dev_a_SU2_2D(hmcParams.L0, hmcParams.L1,
+                                                  traceT(identitySUN<2>()));
+        run_HMC<DGaugeFieldType, DAdjFieldType>(dev_g_SU2_2D, dev_a_SU2_2D,
+                                                hmcParams, gaugeObsParams, rng);
+      }
+      // case SU(3)
+      // else if (hmcParams.Nc == 3) {
+      //   using DGaugeFieldType = DeviceGaugeFieldType<2, 3>;
+      //   using DAdjFieldType = DeviceAdjFieldType<2, 3>;
+      //   typename DGaugeFieldType::type dev_g_SU3_2D(hmcParams.L0,
+      //   hmcParams.L1,
+      //                                              rng, hmcParams.rngDelta);
+      //   typename DAdjFieldType::type dev_a_SU3_2D(hmcParams.L0, hmcParams.L1,
+      //                                            traceT(identitySUN<3>()));
+      //   run_HMC<DGaugeFieldType, DAdjFieldType>(
+      //       dev_g_SU3_2D, dev_a_SU3_2D, hmcParams, gaugeObsParams, rng);
+      // }
+      // case SU(N)
+      else {
+        printf("Error: Unsupported gauge group\n");
+        return -1;
+      }
+    }
+  }
+
+  // get gamma matricies
+
+  // if tuning is enabled, write the cache file
+  if (KLFT_TUNING) {
+    const char* cache_file = std::getenv("KLFT_CACHE_FILE");
+    if (cache_file) {
+      writeTuneCache(cache_file);
+    } else {
+      printf("KLFT_CACHE_FILE not set\n");
+    }
+  }
+
+  return 0;
+}
+
+}  // namespace klft
diff --git a/lib/HMC_exec.hpp b/lib/HMC_exec.hpp
deleted file mode 100644
index 030e5c5..0000000
--- a/lib/HMC_exec.hpp
+++ /dev/null
@@ -1,142 +0,0 @@
-
-#include "FieldTypeHelper.hpp"
-#include "GLOBAL.hpp"
-#include "GaugeFieldHelper.hpp"
-#include "GaugeObservable.hpp"
-#include "HMC.hpp"
-#include "HamiltonianField.hpp"
-#include "Integrator.hpp"
-#include "SimulationLogging.hpp"
-#include "UpdateMomentum.hpp"
-#include "UpdatePosition.hpp"
-#include <cstddef>
-#include <memory>
-
-using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
-
-namespace klft {
-
-template <typename DGaugeFieldType, typename DAdjFieldType, class RNG>
-int run_HMC(typename DGaugeFieldType::type g_in,
-            typename DAdjFieldType::type a_in, const HMCParams &hmcparams,
-            GaugeObservableParams &gaugeObsParams,
-            SimulationLoggingParams &simLogParams, const RNG &rng) {
-  // initiate and execute the HMC with the given parameters
-  printf("Executing HMC ...");
-  hmcparams.print();
-
-  // template argument deduction and safety
-  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
-  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
-  constexpr static size_t rank =
-      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
-  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
-  static_assert((rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank) &&
-                (Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc));
-  constexpr const size_t Nd = rank;
-  // get the dimensions
-
-  // define fields and update routines
-  using GaugeField = typename DGaugeFieldType::type;
-  using AdjointField = typename DAdjFieldType::type;
-  using HField = HamiltonianField<DGaugeFieldType, DAdjFieldType>;
-  using Update_Q = UpdatePositionGauge<Nd, Nc>;
-  using Update_P = UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>;
-
-  HField hamiltonian_field = HField(g_in, a_in);
-  // after the move, the gauge and adjoint fields are no longer valid
-  const auto &dimensions = hamiltonian_field.gauge_field.dimensions;
-  // first we check that all the parameters are correct
-  assert(hmcparams.Ndims == Nd);
-  assert(hmcparams.Nd == Nd);
-  assert(hmcparams.Nc == Nc);
-  assert(hmcparams.L0 == dimensions[0]);
-  assert(hmcparams.L1 == dimensions[1]);
-  if constexpr (Nd > 2) {
-    assert(hmcparams.L2 == dimensions[2]);
-  }
-  if constexpr (Nd > 3) {
-    assert(hmcparams.L3 == dimensions[3]);
-  }
-
-  Update_Q update_q(hamiltonian_field.gauge_field,
-                    hamiltonian_field.adjoint_field);
-  Update_P update_p(hamiltonian_field.gauge_field,
-                    hamiltonian_field.adjoint_field, hmcparams.beta);
-  // the integrate might need to be passed into the run_HMC as an argument as it
-  // contains a large amount of design decisions
-  std::shared_ptr<LeapFrog> leap_frog =
-      std::make_shared<LeapFrog>(hmcparams.nstepsGauge, true, nullptr,
-                                 std::make_shared<Update_Q>(update_q),
-                                 std::make_shared<Update_P>(update_p));
-
-  // now define and run the hmc
-  std::mt19937 mt(hmcparams.seed);
-  std::uniform_real_distribution<real_t> dist(0.0, 1.0);
-  using HMC = HMC<DGaugeFieldType, DAdjFieldType, RNG>;
-  HMC hmc(hmcparams, hamiltonian_field, leap_frog, rng, dist, mt);
-  hmc.add_gauge_monomial(hmcparams.beta, 0);
-  hmc.add_kinetic_monomial(0);
-
-  // timer to measure the time per step
-  Kokkos::Timer timer;
-  bool accept;
-  real_t acc_sum{0.0};
-  real_t acc_rate{0.0};
-  // hmc loop
-  for (size_t step = 0; step < hmcparams.nsteps; ++step) {
-    timer.reset();
-
-    // perform hmc_step
-    accept = hmc.hmc_step();
-
-    const real_t time = timer.seconds();
-    acc_sum += static_cast<real_t>(accept);
-    acc_rate = acc_sum / static_cast<real_t>(step + 1);
-
-    if (KLFT_VERBOSITY > 0) {
-      printf("Step: %ld, accepted: %ld, Acceptance rate: %f, Time: %f\n", step,
-             static_cast<size_t>(accept), acc_rate, time);
-    }
-    // measure the gauge observables
-    measureGaugeObservables<rank, Nc>(hamiltonian_field.gauge_field,
-                                      gaugeObsParams, step);
-    addLogData(simLogParams, step, hmc.delta_H, acc_rate, accept, time);
-    // TODO:make flushAllGaugeObservables append the Observables to the files ->
-    // don't lose all progress when the simulation is interupted if (step % 50
-    // == 0) {
-    //   // flush every 50 steps as well to not lose data on program interuption
-    //   // TODO: this should be set by the Params
-    //   flushAllGaugeObservables(gaugeObsParams);
-    // }
-    DEBUG_LOG("Max unitarity defect: "
-              << unitarity_check<DGaugeFieldType>(hamiltonian_field.gauge_field)
-              << "\n");
-    if (step % 1000 == 0) {
-      unitarity_restore<DGaugeFieldType>(hamiltonian_field.gauge_field);
-    }
-  }
-  // flush the measurements to the files
-  flushAllGaugeObservables(gaugeObsParams);
-  flushSimulationLogs(simLogParams);
-
-  return 0;
-}
-
-#define INSTANTIATE_HMC(R, N)                                                  \
-  template int                                                                 \
-  run_HMC<DeviceGaugeFieldType<R, N>, DeviceAdjFieldType<R, N>, RNGType>(      \
-      typename DeviceGaugeFieldType<R, N>::type,                               \
-      typename DeviceAdjFieldType<R, N>::type, const HMCParams &,              \
-      GaugeObservableParams &, SimulationLoggingParams &, const RNGType &)
-
-INSTANTIATE_HMC(4, 1);
-INSTANTIATE_HMC(4, 2);
-INSTANTIATE_HMC(3, 2);
-INSTANTIATE_HMC(3, 1);
-INSTANTIATE_HMC(2, 1);
-INSTANTIATE_HMC(2, 2);
-
-// TODO: when SU3 is fully implemented, add Nc=3 here.
-
-} // namespace klft
diff --git a/lib/HMC_exec.hpp.old b/lib/HMC_exec.hpp.old
new file mode 100644
index 0000000..57dcb0c
--- /dev/null
+++ b/lib/HMC_exec.hpp.old
@@ -0,0 +1,238 @@
+
+#include <cstddef>
+#include <memory>
+
+#include "../include/HMC.hpp"
+#include "FermionParams.hpp"
+#include "FieldTypeHelper.hpp"
+#include "GLOBAL.hpp"
+#include "GaugeObservable.hpp"
+#include "HamiltonianField.hpp"
+#include "Integrator.hpp"
+#include "UpdateMomentum.hpp"
+#include "UpdatePosition.hpp"
+
+using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
+
+namespace klft {
+
+template <typename DGaugeFieldType, typename DAdjFieldType, class RNG>
+int run_HMC(typename DGaugeFieldType::type& g_in,
+            typename DAdjFieldType::type& a_in, const HMCParams& hmcparams,
+            GaugeObservableParams& gaugeObsParams, const RNG& rng) {
+  // initiate and execute the HMC with the given parameters
+  printf("Executing HMC ...");
+  hmcparams.print();
+
+  // template argument deduction and safety
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
+  constexpr static size_t rank =
+      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
+  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
+  static_assert((rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank) &&
+                (Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc));
+  constexpr const size_t Nd = rank;
+  // get the dimensions
+  const auto& dimensions = g_in.dimensions;
+  // first we check that all the parameters are correct
+  assert(hmcparams.Ndims == Nd);
+  assert(hmcparams.Nd == Nd);
+  assert(hmcparams.Nc == Nc);
+  assert(hmcparams.L0 == dimensions[0]);
+  assert(hmcparams.L1 == dimensions[1]);
+  if constexpr (Nd > 2) {
+    assert(hmcparams.L2 == dimensions[2]);
+  }
+  if constexpr (Nd > 3) {
+    assert(hmcparams.L3 == dimensions[3]);
+  }
+
+  // define fields and update routines
+  using GaugeField = typename DGaugeFieldType::type;
+  using AdjointField = typename DAdjFieldType::type;
+  using HField = HamiltonianField<DGaugeFieldType, DAdjFieldType>;
+  using Update_Q = UpdatePositionGauge<Nd, Nc>;
+  using Update_P = UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>;
+
+  HField hamiltonian_field = HField(g_in, a_in);
+  Update_Q update_q(g_in, a_in);
+  Update_P update_p(g_in, a_in, hmcparams.beta);
+  // the integrate might need to be passed into the run_HMC as an argument as it
+  // contains a large amount of design decisions
+  std::shared_ptr<LeapFrog> leap_frog =
+      std::make_shared<LeapFrog>(hmcparams.nstepsGauge, true, nullptr,
+                                 std::make_shared<Update_Q>(update_q),
+                                 std::make_shared<Update_P>(update_p));
+
+  // now define and run the hmc
+  std::mt19937 mt(hmcparams.seed);
+  std::uniform_real_distribution<real_t> dist(0.0, 1.0);
+  using HMC = HMC<DGaugeFieldType, DAdjFieldType, RNG>;
+  HMC hmc(hmcparams, hamiltonian_field, leap_frog, rng, dist, mt);
+  hmc.add_gauge_monomial(hmcparams.beta, 0);
+  hmc.add_kinetic_monomial(0);
+
+  // timer to measure the time per step
+  Kokkos::Timer timer;
+  bool accept;
+  real_t acc_sum{0.0};
+  real_t acc_rate{0.0};
+  // hmc loop
+  for (size_t step = 0; step < hmcparams.nsteps; ++step) {
+    timer.reset();
+
+    // perform hmc_step
+    accept = hmc.hmc_step();
+
+    const real_t time = timer.seconds();
+    acc_sum += static_cast<real_t>(accept);
+    acc_rate = acc_sum / static_cast<real_t>(step + 1);
+
+    if (KLFT_VERBOSITY > 0) {
+      printf("Step: %ld, accepted: %ld, Acceptance rate: %f, Time: %f\n", step,
+             static_cast<size_t>(accept), acc_rate, time);
+    }
+    // measure the gauge observables
+    measureGaugeObservables<rank, Nc>(g_in, gaugeObsParams, step);
+    // TODO:make flushAllGaugeObservables append the Observables to the files ->
+    // don't lose all progress when the simulation is interupted if (step % 50
+    // == 0) {
+    //   // flush every 50 steps as well to not lose data on program interuption
+    //   // TODO: this should be set by the Params
+    //   flushAllGaugeObservables(gaugeObsParams);
+    // }
+  }
+  // flush the measurements to the files
+  flushAllGaugeObservables(gaugeObsParams);
+
+  return 0;
+}
+
+template <typename DGaugeFieldType, typename DAdjFieldType, class RNG>
+int run_HMC(typename DGaugeFieldType::type& g_in,
+            typename DAdjFieldType::type& a_in, const HMCParams& hmcparams,
+            const FermionParams& fparams,
+            GaugeObservableParams& gaugeObsParams, const RNG& rng) {
+            auto dparams = getDiracParams(fparams, g_in.dimensions);
+  // initiate and execute the HMC with the given parameters
+  printf("Executing HMC ...");
+  hmcparams.print();
+
+  // template argument deduction and safety
+  static_assert(isDeviceGaugeFieldType<DGaugeFieldType>::value);
+  static_assert(isDeviceAdjFieldType<DAdjFieldType>::value);
+  constexpr static size_t rank =
+      DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Rank;
+  constexpr static size_t Nc = DeviceGaugeFieldTypeTraits<DGaugeFieldType>::Nc;
+  static_assert((rank == DeviceAdjFieldTypeTraits<DAdjFieldType>::Rank) &&
+                (Nc == DeviceAdjFieldTypeTraits<DAdjFieldType>::Nc));
+  constexpr const size_t Nd = rank;
+  // get the dimensions
+  const auto& dimensions = g_in.dimensions;
+  // first we check that all the parameters are correct
+  assert(hmcparams.Ndims == Nd);
+  assert(hmcparams.Nd == Nd);
+  assert(hmcparams.Nc == Nc);
+  assert(hmcparams.L0 == dimensions[0]);
+  assert(hmcparams.L1 == dimensions[1]);
+  if constexpr (Nd > 2) {
+    assert(hmcparams.L2 == dimensions[2]);
+  }
+  if constexpr (Nd > 3) {
+    assert(hmcparams.L3 == dimensions[3]);
+  }
+
+  // define fields and update routines
+  using GaugeField = typename DGaugeFieldType::type;
+  using AdjointField = typename DAdjFieldType::type;
+  using HField = HamiltonianField<DGaugeFieldType, DAdjFieldType>;
+  using Update_Q = UpdatePositionGauge<Nd, Nc>;
+  using Update_P = UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>;
+  using Update_F =
+      UpdateMomentumFermion<rank, Nc, DGaugeFieldType, DAdjFieldType>;
+
+  HField hamiltonian_field = HField(g_in, a_in);
+  Update_Q update_q(g_in, a_in);
+  Update_P update_p(g_in, a_in, hmcparams.beta);
+  // the integrate might need to be passed into the run_HMC as an argument as it
+  // contains a large amount of design decisions
+  std::shared_ptr<LeapFrog> leap_frog =
+      std::make_shared<LeapFrog>(hmcparams.nstepsGauge, true, nullptr,
+                                 std::make_shared<Update_Q>(update_q),
+                                 std::make_shared<Update_P>(update_p));
+
+  // now define and run the hmc
+  std::mt19937 mt(hmcparams.seed);
+  std::uniform_real_distribution<real_t> dist(0.0, 1.0);
+  using HMC = HMC<DGaugeFieldType, DAdjFieldType, RNG>;
+  HMC hmc(hmcparams, hamiltonian_field, leap_frog, rng, dist, mt);
+
+  hmc.add_gauge_monomial(hmcparams.beta, 0);
+  hmc.add_kinetic_monomial(0);
+  hmc.add_fermion_monomial(dParams, 1e-6, hmcparams.seed, 0);
+
+  // timer to measure the time per step
+  Kokkos::Timer timer;
+  bool accept;
+  real_t acc_sum{0.0};
+  real_t acc_rate{0.0};
+  // hmc loop
+  for (size_t step = 0; step < hmcparams.nsteps; ++step) {
+    timer.reset();
+
+    // perform hmc_step
+    accept = hmc.hmc_step();
+
+    const real_t time = timer.seconds();
+    acc_sum += static_cast<real_t>(accept);
+    acc_rate = acc_sum / static_cast<real_t>(step + 1);
+
+    if (KLFT_VERBOSITY > 0) {
+      printf("Step: %ld, accepted: %ld, Acceptance rate: %f, Time: %f\n", step,
+             static_cast<size_t>(accept), acc_rate, time);
+    }
+    // measure the gauge observables
+    measureGaugeObservables<rank, Nc>(g_in, gaugeObsParams, step);
+    // TODO:make flushAllGaugeObservables append the Observables to the files ->
+    // don't lose all progress when the simulation is interupted if (step % 50
+    // == 0) {
+    //   // flush every 50 steps as well to not lose data on program interuption
+    //   // TODO: this should be set by the Params
+    //   flushAllGaugeObservables(gaugeObsParams);
+    // }
+  }
+  // flush the measurements to the files
+  flushAllGaugeObservables(gaugeObsParams);
+
+  return 0;
+}
+
+template int run_HMC<DeviceGaugeFieldType<4, 1>, DeviceAdjFieldType<4, 1>>(
+    typename DeviceGaugeFieldType<4, 1>::type& g_in,
+    typename DeviceAdjFieldType<4, 1>::type& a_in, const HMCParams& hmcparams,
+    GaugeObservableParams& gaugeObsParams, const RNGType& rng);
+
+template int run_HMC<DeviceGaugeFieldType<4, 2>, DeviceAdjFieldType<4, 2>>(
+    typename DeviceGaugeFieldType<4, 2>::type& g_in,
+    typename DeviceAdjFieldType<4, 2>::type& a_in, const HMCParams& hmcparams,
+    GaugeObservableParams& gaugeObsParams, const RNGType& rng);
+
+template int run_HMC<DeviceGaugeFieldType<3, 1>, DeviceAdjFieldType<3, 1>>(
+    typename DeviceGaugeFieldType<3, 1>::type& g_in,
+    typename DeviceAdjFieldType<3, 1>::type& a_in, const HMCParams& hmcparams,
+    GaugeObservableParams& gaugeObsParams, const RNGType& rng);
+
+template int run_HMC<DeviceGaugeFieldType<2, 1>, DeviceAdjFieldType<2, 1>>(
+    typename DeviceGaugeFieldType<2, 1>::type& g_in,
+    typename DeviceAdjFieldType<2, 1>::type& a_in, const HMCParams& hmcparams,
+    GaugeObservableParams& gaugeObsParams, const RNGType& rng);
+
+template int run_HMC<DeviceGaugeFieldType<2, 2>, DeviceAdjFieldType<2, 2>>(
+    typename DeviceGaugeFieldType<2, 2>::type& g_in,
+    typename DeviceAdjFieldType<2, 2>::type& a_in, const HMCParams& hmcparams,
+    GaugeObservableParams& gaugeObsParams, const RNGType& rng);
+
+// TODO: when SU3 is fully implemented, add Nc=3 here.
+
+}  // namespace klft
diff --git a/lib/Metropolis.cpp b/lib/Metropolis.cpp
index a22390f..81d3976 100644
--- a/lib/Metropolis.cpp
+++ b/lib/Metropolis.cpp
@@ -30,139 +30,152 @@
 
 using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
 
-namespace klft 
-{
+namespace klft {
 
-  int Metropolis(const std::string &input_file) {
-    // get verbosity from environment
-    const int verbosity = std::getenv("KLFT_VERBOSITY") ?
-                          std::atoi(std::getenv("KLFT_VERBOSITY")) : 0;
-    setVerbosity(verbosity);
-    // get tuning from environment
-    const int tuning = std::getenv("KLFT_TUNING") ?
-                       std::atoi(std::getenv("KLFT_TUNING")) : 0;
-    setTuning(tuning);
-    // if tuning is enbled, check if the user has set the
-    // KLFT_CACHE_FILE environment variable
-    if (tuning) {
-      const char *cache_file = std::getenv("KLFT_CACHE_FILE");
-      // if it exists, read the cache
-      if (cache_file) {
-        if (KLFT_VERBOSITY > 0) {
-          printf("Reading cache file: %s\n", cache_file);
-        }
-        readTuneCache(cache_file);
+int Metropolis(const std::string& input_file,
+               const std::string& output_directory) {
+  // get verbosity from environment
+  const int verbosity = std::getenv("KLFT_VERBOSITY")
+                            ? std::atoi(std::getenv("KLFT_VERBOSITY"))
+                            : 0;
+  setVerbosity(verbosity);
+  // get tuning from environment
+  const int tuning =
+      std::getenv("KLFT_TUNING") ? std::atoi(std::getenv("KLFT_TUNING")) : 0;
+  setTuning(tuning);
+  // if tuning is enbled, check if the user has set the
+  // KLFT_CACHE_FILE environment variable
+  if (tuning) {
+    const char* cache_file = std::getenv("KLFT_CACHE_FILE");
+    // if it exists, read the cache
+    if (cache_file) {
+      if (KLFT_VERBOSITY > 0) {
+        printf("Reading cache file: %s\n", cache_file);
       }
+      readTuneCache(cache_file);
     }
-    
-    // parse input file
-    MetropolisParams metropolisParams;
-    GaugeObservableParams  gaugeObsParams;
-    if (!parseInputFile(input_file, metropolisParams)) {
-      printf("Error parsing input file\n");
+  }
+
+  // parse input file
+  MetropolisParams metropolisParams;
+  GaugeObservableParams gaugeObsParams;
+  if (!parseInputFile(input_file, metropolisParams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  if (!parseInputFile(input_file, gaugeObsParams)) {
+    printf("Error parsing input file\n");
+    return -1;
+  }
+  // print the parameters
+  metropolisParams.print();
+  // initialize RNG
+  RNGType rng(metropolisParams.seed);
+  // initialize gauge field and run metropolis
+  // based on the system parameters
+  // case 4D
+  if (metropolisParams.Ndims == 4) {
+    // case U(1)
+    if (metropolisParams.Nc == 1) {
+      deviceGaugeField<4, 1> dev_g_U1_4D(
+          metropolisParams.L0, metropolisParams.L1, metropolisParams.L2,
+          metropolisParams.L3, identitySUN<1>());
+      run_metropolis<4, 1>(dev_g_U1_4D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
+    }
+    // case SU(2)
+    else if (metropolisParams.Nc == 2) {
+      deviceGaugeField<4, 2> dev_g_SU2_4D(
+          metropolisParams.L0, metropolisParams.L1, metropolisParams.L2,
+          metropolisParams.L3, identitySUN<2>());
+      run_metropolis<4, 2>(dev_g_SU2_4D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
+    }
+    // case SU(3)
+    else if (metropolisParams.Nc == 3) {
+      deviceGaugeField<4, 3> dev_g_SU3_4D(
+          metropolisParams.L0, metropolisParams.L1, metropolisParams.L2,
+          metropolisParams.L3, identitySUN<3>());
+      run_metropolis<4, 3>(dev_g_SU3_4D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
+    }
+    // case SU(N)
+    else {
+      printf("Error: Unsupported gauge group\n");
       return -1;
     }
-    if (!parseInputFile(input_file,  gaugeObsParams)) {
-      printf("Error parsing input file\n");
+  }
+  // case 3D
+  else if (metropolisParams.Ndims == 3) {
+    // case U(1)
+    if (metropolisParams.Nc == 1) {
+      deviceGaugeField3D<3, 1> dev_g_U1_3D(
+          metropolisParams.L0, metropolisParams.L1, metropolisParams.L2,
+          identitySUN<1>());
+      run_metropolis<3, 1>(dev_g_U1_3D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
+    }
+    // case SU(2)
+    else if (metropolisParams.Nc == 2) {
+      deviceGaugeField3D<3, 2> dev_g_SU2_3D(
+          metropolisParams.L0, metropolisParams.L1, metropolisParams.L2,
+          identitySUN<2>());
+      run_metropolis<3, 2>(dev_g_SU2_3D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
+    }
+    // case SU(3)
+    else if (metropolisParams.Nc == 3) {
+      deviceGaugeField3D<3, 3> dev_g_SU3_3D(
+          metropolisParams.L0, metropolisParams.L1, metropolisParams.L2,
+          identitySUN<3>());
+      run_metropolis<3, 3>(dev_g_SU3_3D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
+    }
+    // case SU(N)
+    else {
+      printf("Error: Unsupported gauge group\n");
       return -1;
     }
-    // print the parameters
-    metropolisParams.print();
-    // initialize RNG
-    RNGType rng(metropolisParams.seed);
-    // initialize gauge field and run metropolis
-    // based on the system parameters
-    // case 4D
-    if (metropolisParams.Ndims == 4) {
-      // case U(1)
-      if (metropolisParams.Nc == 1) {
-        deviceGaugeField<4, 1> dev_g_U1_4D(metropolisParams.L0, metropolisParams.L1,
-                                           metropolisParams.L2, metropolisParams.L3,
-                                           identitySUN<1>());
-        run_metropolis<4, 1>(dev_g_U1_4D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(2)
-      else if (metropolisParams.Nc == 2) {
-        deviceGaugeField<4, 2> dev_g_SU2_4D(metropolisParams.L0, metropolisParams.L1,
-                                           metropolisParams.L2, metropolisParams.L3,
-                                           identitySUN<2>());
-        run_metropolis<4, 2>(dev_g_SU2_4D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(3)
-      else if (metropolisParams.Nc == 3) {
-        deviceGaugeField<4, 3> dev_g_SU3_4D(metropolisParams.L0, metropolisParams.L1,
-                                           metropolisParams.L2, metropolisParams.L3,
-                                           identitySUN<3>());
-        run_metropolis<4, 3>(dev_g_SU3_4D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
+  }
+  // case 2D
+  else if (metropolisParams.Ndims == 2) {
+    // case U(1)
+    if (metropolisParams.Nc == 1) {
+      deviceGaugeField2D<2, 1> dev_g_U1_2D(
+          metropolisParams.L0, metropolisParams.L1, identitySUN<1>());
+      run_metropolis<2, 1>(dev_g_U1_2D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
     }
-    // case 3D
-    else if (metropolisParams.Ndims == 3) {
-      // case U(1)
-      if (metropolisParams.Nc == 1) {
-        deviceGaugeField3D<3, 1> dev_g_U1_3D(metropolisParams.L0, metropolisParams.L1,
-                                           metropolisParams.L2, identitySUN<1>());
-        run_metropolis<3, 1>(dev_g_U1_3D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(2)
-      else if (metropolisParams.Nc == 2) {
-        deviceGaugeField3D<3, 2> dev_g_SU2_3D(metropolisParams.L0, metropolisParams.L1,
-                                           metropolisParams.L2, identitySUN<2>());
-        run_metropolis<3, 2>(dev_g_SU2_3D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(3)
-      else if (metropolisParams.Nc == 3) {
-        deviceGaugeField3D<3, 3> dev_g_SU3_3D(metropolisParams.L0, metropolisParams.L1,
-                                           metropolisParams.L2, identitySUN<3>());
-        run_metropolis<3, 3>(dev_g_SU3_3D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
+    // case SU(2)
+    else if (metropolisParams.Nc == 2) {
+      deviceGaugeField2D<2, 2> dev_g_SU2_2D(
+          metropolisParams.L0, metropolisParams.L1, identitySUN<2>());
+      run_metropolis<2, 2>(dev_g_SU2_2D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
     }
-    // case 2D
-    else if (metropolisParams.Ndims == 2) {
-      // case U(1)
-      if (metropolisParams.Nc == 1) {
-        deviceGaugeField2D<2, 1> dev_g_U1_2D(metropolisParams.L0, metropolisParams.L1,
-                                           identitySUN<1>());
-        run_metropolis<2, 1>(dev_g_U1_2D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(2)
-      else if (metropolisParams.Nc == 2) {
-        deviceGaugeField2D<2, 2> dev_g_SU2_2D(metropolisParams.L0, metropolisParams.L1,
-                                           identitySUN<2>());
-        run_metropolis<2, 2>(dev_g_SU2_2D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(3)
-      else if (metropolisParams.Nc == 3) {
-        deviceGaugeField2D<2, 3> dev_g_SU3_2D(metropolisParams.L0, metropolisParams.L1,
-                                           identitySUN<3>());
-        run_metropolis<2, 3>(dev_g_SU3_2D, metropolisParams,  gaugeObsParams, rng);
-      }
-      // case SU(N)
-      else {
-        printf("Error: Unsupported gauge group\n");
-        return -1;
-      }
+    // case SU(3)
+    else if (metropolisParams.Nc == 3) {
+      deviceGaugeField2D<2, 3> dev_g_SU3_2D(
+          metropolisParams.L0, metropolisParams.L1, identitySUN<3>());
+      run_metropolis<2, 3>(dev_g_SU3_2D, metropolisParams, gaugeObsParams, rng,
+                           output_directory);
     }
-    // if tuning is enabled, write the cache file
-    if (KLFT_TUNING) {
-      const char *cache_file = std::getenv("KLFT_CACHE_FILE");
-      if (cache_file) {
-        writeTuneCache(cache_file);
-      } else {
-        printf("KLFT_CACHE_FILE not set\n");
-      }
+    // case SU(N)
+    else {
+      printf("Error: Unsupported gauge group\n");
+      return -1;
+    }
+  }
+  // if tuning is enabled, write the cache file
+  if (KLFT_TUNING) {
+    const char* cache_file = std::getenv("KLFT_CACHE_FILE");
+    if (cache_file) {
+      writeTuneCache(cache_file);
+    } else {
+      printf("KLFT_CACHE_FILE not set\n");
     }
-    return 0;
   }
+  return 0;
+}
 
-}
\ No newline at end of file
+}  // namespace klft
\ No newline at end of file
diff --git a/new_test.yaml b/new_test.yaml
new file mode 100644
index 0000000..1d099c1
--- /dev/null
+++ b/new_test.yaml
@@ -0,0 +1,68 @@
+
+HMCParams:
+  Ndims: 4
+  L0: 16
+  L1: 16
+  L2: 16
+  L3: 16
+  seed: 1234
+  Nd: 4
+  # Nc donst work for now have to change manually in HMC_exec.cpp
+  Nc: 2
+  coldStart: false
+  rngDelta: 1.0
+# Level is the innermost level of the Integrator, i.e that is executed most frequently.
+Integrator:
+
+  tau: 1
+  nSteps: 1000
+  Monomials:
+    - Type: "Leapfrog"
+      level: 0
+      steps: 50
+    # - Type: "Leapfrog"
+    #   level: 1
+    #   steps: 5
+Gauge Monomial:
+  level: 0
+  beta: 2
+
+# Fermion Monomial:
+#   level: 1
+#   fermion: "HWilson"
+#   solver: "CG"
+#   RepDim: 4
+#   kappa: 0.1
+#   tol: 1e-14
+
+GaugeObservableParams:
+  measurement_interval: 5
+  measure_plaquette: true
+  measure_wilson_loop_temporal: false
+  measure_wilson_loop_mu_nu: false
+
+  W_temp_L_T_pairs:
+    - [2, 3]
+    - [3, 4]
+
+  W_mu_nu_pairs:
+    - [0, 1]
+    - [1, 2]
+
+  W_Lmu_Lnu_pairs:
+    - [2, 2]
+    - [3, 3]
+
+  plaquette_filename: "plaquette_output20.txt"
+  W_temp_filename: "wilson_temp_output20.txt"
+  W_mu_nu_filename: "wilson_mu_nu_output20.txt"
+
+  write_to_file: true
+
+SimulationLoggingParams:
+  log_interval: 1
+  log_delta_H: true
+  log_acceptance: true
+  
+  log_filename: "simulation_log.txt"
+  write_to_file: true
diff --git a/test_yaml.yaml b/test_yaml.yaml
deleted file mode 100644
index 1309ab7..0000000
--- a/test_yaml.yaml
+++ /dev/null
@@ -1,59 +0,0 @@
-MetropolisParams:
-  Ndims: 4
-  L0: 32
-  L1: 32
-  L2: 32
-  L3: 32
-  nHits: 10
-  nSweep: 1000
-  seed: 1234
-  Nd: 4
-  Nc: 2
-  beta: 1.0
-  delta: 0.1
-
-HMCParams:
-  Ndims: 4
-  L0: 12
-  L1: 12
-  L2: 12
-  L3: 12
-  tau: 1.0
-  seed: 1234
-  nsteps: 20 
-  nstepsGauge: 100
-  Nd: 4
-  Nc: 2
-  beta: 4.0
-
-GaugeObservableParams:
-  measurement_interval: 10
-  measure_plaquette: true
-  measure_wilson_loop_temporal: false
-  measure_wilson_loop_mu_nu: false
-
-  W_temp_L_T_pairs:
-    - [2, 3]
-    - [3, 4]
-
-  W_mu_nu_pairs:
-    - [0, 1]
-    - [1, 2]
-
-  W_Lmu_Lnu_pairs:
-    - [2, 2]
-    - [3, 3]
-
-  plaquette_filename: "plaquette_output.txt"
-  W_temp_filename: "wilson_temp_output.txt"
-  W_mu_nu_filename: "wilson_mu_nu_output.txt"
-
-  write_to_file: false
-
-SimulationLoggingParams:
-  log_interval: 1
-  log_delta_H: true
-  log_acceptance: true
-  
-  log_filename: "simulation_log.txt"
-  write_to_file: true
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index a4f44b8..02ec0c5 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -1,2 +1,2 @@
-add_executable(reversability_test reversability_test.cpp)
-target_link_libraries(reversability_test PUBLIC klft Kokkos::kokkos yaml-cpp)
+# add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/PTBCCompileTests ${CMAKE_CURRENT_BINARY_DIR}/PTBCCompileTests)
+add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/Fermions ${CMAKE_CURRENT_BINARY_DIR}/Fermions)
\ No newline at end of file
diff --git a/tests/Fermions/CMakeLists.txt b/tests/Fermions/CMakeLists.txt
new file mode 100644
index 0000000..15fd6cc
--- /dev/null
+++ b/tests/Fermions/CMakeLists.txt
@@ -0,0 +1,17 @@
+add_executable(test_gamma_matrices test_gamma_matricies.cpp)
+target_link_libraries(test_gamma_matrices PUBLIC Kokkos::kokkos)
+
+add_executable(test_spinor test_spinor.cpp)
+target_link_libraries(test_spinor PUBLIC Kokkos::kokkos)
+
+add_executable(test_deviceSpinorField test_SpinorFields.cpp)
+target_link_libraries(test_deviceSpinorField PUBLIC Kokkos::kokkos)
+
+add_executable(test_DiracOperator test_DiracOperator.cpp)
+target_link_libraries(test_DiracOperator PUBLIC Kokkos::kokkos)
+
+add_executable(test_GDircOperator test_GDircOperator.cpp)
+target_link_libraries(test_GDircOperator PUBLIC Kokkos::kokkos)
+
+add_executable(test_Solver test_Solver.cpp)
+target_link_libraries(test_Solver PUBLIC Kokkos::kokkos)
\ No newline at end of file
diff --git a/tests/Fermions/test_DiracOperator.cpp b/tests/Fermions/test_DiracOperator.cpp
new file mode 100644
index 0000000..a497caf
--- /dev/null
+++ b/tests/Fermions/test_DiracOperator.cpp
@@ -0,0 +1,97 @@
+#include <Kokkos_Complex.hpp>
+#include <Kokkos_Core.hpp>
+
+#include "GLOBAL.hpp"
+// #include "FieldTypeHelper.hpp"
+#include "../../include/GDiracOperator.hpp"
+#include "../../include/GammaMatrix.hpp"
+#include "../../include/SpinorField.hpp"
+#include "../../include/SpinorFieldLinAlg.hpp"
+#include "../../include/klft.hpp"
+#define HLINE "=========================================================\n"
+
+using namespace klft;
+template <size_t Nc, size_t Nd>
+void print_spinor(const Spinor<Nc, Nd>& s, const char* name = "Spinor") {
+  printf("%s:\n", name);
+  for (size_t c = 0; c < Nc; ++c) {
+    printf("  Color %zu:\n", c);
+    for (size_t d = 0; d < Nd; ++d) {
+      double re = s[c][d].real();
+      double im = s[c][d].imag();
+      printf("    [%zu] = (% .6f, % .6f i)\n", d, re, im);
+    }
+  }
+}
+
+int main(int argc, char* argv[]) {
+  Kokkos::initialize(argc, argv);
+  int RETURNVALUE = 0;
+  {
+    setVerbosity(5);
+    printf("%i", KLFT_VERBOSITY);
+    printf("\n=== Testing DiracOperator SU(3)  ===\n");
+    printf("\n= Testing hermiticity =\n");
+    index_t L0 = 32, L1 = 32, L2 = 32, L3 = 32;
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    diracParams<4, 4> params(IndexArray<4>{L0, L1, L2, L3}, gammas, gamma5,
+                             -0.5);
+    printf("Lattice Dimension %ix%ix%ix%i \n", L0, L1, L2, L3);
+    printf("Generate SpinorFields...\n");
+
+    Kokkos::Random_XorShift64_Pool<> random_pool(/*seed=*/1234);
+    deviceSpinorField<3, 4> u(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    deviceSpinorField<3, 4> v(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    real_t norm = spinor_norm_sq<4, 3, 4>(u);
+    norm *= spinor_norm_sq<4, 3, 4>(v);
+    norm = Kokkos::sqrt(norm);
+
+    printf("Generating Random Gauge Config\n");
+    deviceGaugeField<4, 3> gauge(L0, L1, L2, L3, random_pool, 1);
+    printf("Instantiate DiracOperator...\n");
+    HWilsonDiracOperator<DeviceSpinorFieldType<4, 3, 4>,
+                         DeviceGaugeFieldType<4, 3>>
+        D(gauge, params);
+    printf("Apply DiracOperator...\n");
+
+    deviceSpinorField Mu = D.applyD(u);
+    deviceGaugeField<4, 3> gaugeTrafo(L0, L1, L2, L3, random_pool, 1);
+    tune_and_launch_for<4>(
+        "Gauge Trafo", IndexArray<4>{0, 0, 0, 0}, IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+#pragma unroll
+          for (size_t mu = 0; mu < 4; mu++) {
+            // gauge(i0, i1, i2, i3, mu) = gaugeTrafo(i0, i1, i2, i3, mu);
+            auto temp = gauge(i0, i1, i2, i3, mu);
+            gauge(i0, i1, i2, i3, mu) -= temp;
+            gauge(i0, i1, i2, i3, mu) -= temp;
+          }
+          // Transform spinor u, and Mu
+        });
+
+    deviceSpinorField Mv1 = D.applyD(u);
+    // deviceSpinorField<3, 4> Mu = apply_D<4, 3, 4>(u, gauge, gammas, -0.5);
+    // deviceSpinorField<3, 4> Mv = apply_D<4, 3, 4>(v, gauge, gammas, -0.5);
+    print_spinor(Mv1(0, 0, 0, 0), "Mv1");
+    print_spinor(Mu(0, 0, 0, 0), "Mu");
+    printf("Calculate Scalarproducts...\n");
+    // auto r1 = spinor_dot_product<4, 3, 4>(u, Mv1);
+    // auto r2 = spinor_dot_product<4, 3, 4>(Mu, v);
+
+    // auto r = r1 - r2;
+
+    // real_t r3 = Kokkos::sqrt(r.real() * r.real() + r.imag() * r.imag());
+    // r3 /= norm;
+
+    // if (r3 < 1e-14) {
+    //   printf("Passed hermiticity test with %.21f \n", r3);
+    // } else {
+    //   printf("Error: didn't pass hermiticity test with %.21f \n", r3);
+    //   RETURNVALUE++;
+    // }
+  }
+  Kokkos::finalize();
+  return RETURNVALUE;
+}
\ No newline at end of file
diff --git a/tests/Fermions/test_GDircOperator.cpp b/tests/Fermions/test_GDircOperator.cpp
new file mode 100644
index 0000000..dd050dc
--- /dev/null
+++ b/tests/Fermions/test_GDircOperator.cpp
@@ -0,0 +1,333 @@
+#include <Kokkos_Complex.hpp>
+#include <Kokkos_Core.hpp>
+
+#include "GLOBAL.hpp"
+// #include "FieldTypeHelper.hpp"
+#include "../../include/GDiracOperator.hpp"
+#include "../../include/GammaMatrix.hpp"
+#include "../../include/SpinorField.hpp"
+#include "../../include/SpinorFieldLinAlg.hpp"
+#include "../../include/klft.hpp"
+#define HLINE "=========================================================\n"
+
+using namespace klft;
+template <size_t Nc, size_t Nd>
+void print_spinor(const Spinor<Nc, Nd>& s, const char* name = "Spinor") {
+  printf("%s:\n", name);
+  for (size_t c = 0; c < Nc; ++c) {
+    printf("  Color %zu:\n", c);
+    for (size_t d = 0; d < Nd; ++d) {
+      Kokkos::printf("    [%zu] = (% .6f, % .6f i)\n", d, s[c][d].real(),
+                     s[c][d].imag());
+    }
+  }
+}
+
+int main(int argc, char* argv[]) {
+  Kokkos::initialize(argc, argv);
+  int RETURNVALUE = 0;
+  {
+    setVerbosity(5);
+    printf("%i", KLFT_VERBOSITY);
+    printf("\n=== Testing DiracOperator SU(3)  ===\n");
+    printf("\n= Testing hermiticity =\n");
+    index_t L0 = 4, L1 = 4, L2 = 4, L3 = 4;
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    diracParams<4, 4> params(IndexArray<4>{L0, L1, L2, L3}, gammas, gamma5,
+                             -0.5);
+    printf("Lattice Dimension %ix%ix%ix%i \n", L0, L1, L2, L3);
+    printf("Generate SpinorFields...\n");
+
+    Kokkos::Random_XorShift64_Pool<> random_pool(/*seed=*/1234);
+    deviceSpinorField<3, 4> u(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    deviceSpinorField<3, 4> v(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    real_t norm = spinor_norm_sq<4, 3, 4>(u);
+    norm *= spinor_norm_sq<4, 3, 4>(v);
+    norm = Kokkos::sqrt(norm);
+    deviceSpinorField<3, 4> Mu(L0, L1, L2, L3, complex_t(0.0, 0.0));
+    deviceSpinorField<3, 4> Mv(L0, L1, L2, L3, complex_t(0.0, 0.0));
+    printf("Generating Random Gauge Config\n");
+    deviceGaugeField<4, 3> gauge(L0, L1, L2, L3, random_pool, 1);
+    printf("Instantiate DiracOperator...\n");
+    HWilsonDiracOperator<DeviceSpinorFieldType<4, 3, 4>,
+                         DeviceGaugeFieldType<4, 3>>
+        D(gauge, params);
+    printf("Apply DiracOperator...\n");
+
+    D.applyD_inplace(u, Mu);
+    Kokkos::fence();
+    D.applyD_inplace(v, Mv);
+    // deviceSpinorField<3, 4> Mu = apply_D<4, 3, 4>(u, gauge, gammas, -0.5);
+    // deviceSpinorField<3, 4> Mv = apply_D<4, 3, 4>(v, gauge, gammas, -0.5);
+
+    printf("Calculate Scalarproducts...\n");
+    auto r1 = spinor_dot_product<4, 3, 4>(u, Mv);
+    auto r2 = spinor_dot_product<4, 3, 4>(Mu, v);
+
+    auto r = r1 - r2;
+
+    real_t r3 = Kokkos::sqrt(r.real() * r.real() + r.imag() * r.imag());
+    r3 /= norm;
+
+    if (r3 < 1e-14) {
+      printf("Passed hermiticity test with %.21f \n", r3);
+    } else {
+      printf("Error: didn't pass hermiticity test with %.21f \n", r3);
+      RETURNVALUE++;
+    }
+
+    printf("\n= Testing Gaugeinvariance =\n");
+    printf("Generating Random Gauge Transformation...\n");
+    // Use the normal GaugeField, because it can be initialised with random
+    // SU(3) matrices, however only use mu = 0
+    deviceGaugeField<4, 3> gaugeTrafo(L0, L1, L2, L3, random_pool, 1);
+    real_t norm_trafo = spinor_norm_sq<4, 3, 4>(u);
+    // Dont know if this function is needed again, therefore only defined here,
+    // and not in an include file.
+    printf("Apply Gauge Trafos...\n");
+    tune_and_launch_for<4>(
+        "Gauge Trafo", IndexArray<4>{0, 0, 0, 0}, IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+#pragma unroll
+          for (size_t mu = 0; mu < 4; mu++) {
+            gauge(i0, i1, i2, i3, mu) =
+                gaugeTrafo(i0, i1, i2, i3, 1) * gauge(i0, i1, i2, i3, mu) *
+                conj(gaugeTrafo(shift_index_plus<4, int>(
+                                    Kokkos::Array<int, 4>{i0, i1, i2, i3}, mu,
+                                    1, IndexArray<4>{L0, L1, L2, L3}),
+                                1));
+          }
+          // Transform spinor u, and Mu
+          u(i0, i1, i2, i3) = gaugeTrafo(i0, i1, i2, i3, 1) * u(i0, i1, i2, i3);
+          Mu(i0, i1, i2, i3) =
+              gaugeTrafo(i0, i1, i2, i3, 1) * Mu(i0, i1, i2, i3);
+        });
+    deviceSpinorField Mu_trafo = D.applyD(u);
+    tune_and_launch_for<4>(
+        "Subtract Spinors", IndexArray<4>{0, 0, 0, 0},
+        IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+          Mu(i0, i1, i2, i3) -= Mu_trafo(i0, i1, i2, i3);
+        });
+    real_t norm_trafo1 = spinor_norm_sq<4, 3, 4>(Mu);
+    norm_trafo1 = Kokkos::sqrt(norm_trafo1 / norm);
+    if (norm_trafo1 < 1e-14) {
+      printf("Passed invariance test with %.21f \n", norm_trafo1);
+    } else {
+      printf("Error: didn't pass invariance test with %.21f \n", norm_trafo1);
+      RETURNVALUE++;
+    }
+  }
+  {
+    printf("\n=== Testing DiracOperator SU(2)  ===\n");
+
+    setVerbosity(5);
+    printf("%i", KLFT_VERBOSITY);
+    index_t L0 = 32, L1 = 32, L2 = 32, L3 = 32;
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    diracParams<4, 4> params(IndexArray<4>{L0, L1, L2, L3}, gammas, gamma5,
+                             0.5);
+    printf("Lattice Dimension %ix%ix%ix%i", L0, L1, L2, L3);
+    printf("\n= Testing hermiticity =\n");
+
+    printf("Generate SpinorFields...\n");
+
+    Kokkos::Random_XorShift64_Pool<> random_pool(/*seed=*/1234);
+    deviceSpinorField<2, 4> u_SU2(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    deviceSpinorField<2, 4> v_SU2(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    real_t norm_SU2 = spinor_norm_sq<4, 2, 4>(u_SU2);
+    norm_SU2 *= spinor_norm_sq<4, 2, 4>(v_SU2);
+    norm_SU2 = Kokkos::sqrt(norm_SU2);
+
+    printf("Generating Random Gauge Config\n");
+    deviceGaugeField<4, 2> gauge_SU2(L0, L1, L2, L3, random_pool, 1);
+    printf("Instantiate DiracOperator...\n");
+    HWilsonDiracOperator<DeviceSpinorFieldType<4, 2, 4>,
+                         DeviceGaugeFieldType<4, 2>>
+        D_SU2(gauge_SU2, params);
+    printf("Apply DiracOperator...\n");
+
+    deviceSpinorField<2, 4> Mu_SU2 = D_SU2.applyD(u_SU2);
+    deviceSpinorField<2, 4> Mv_SU2 = D_SU2.applyD(v_SU2);
+    // deviceSpinorField<3, 4> Mu = apply_D<4, 3, 4>(u, gauge, gammas, -0.5);
+    // deviceSpinorField<3, 4> Mv = apply_D<4, 3, 4>(v, gauge, gammas, -0.5);
+
+    printf("Calculate Scalarproducts...\n");
+    auto r1_SU2 = spinor_dot_product<4, 2, 4>(u_SU2, Mv_SU2);
+    auto r2_SU2 = spinor_dot_product<4, 2, 4>(Mu_SU2, v_SU2);
+
+    auto r_SU2 = r1_SU2 - r2_SU2;
+
+    real_t r3_SU2 =
+        Kokkos::sqrt(r_SU2.real() * r_SU2.real() + r_SU2.imag() * r_SU2.imag());
+    r3_SU2 /= norm_SU2;
+
+    if (r3_SU2 < 1e-14) {
+      printf("Passed hermiticity test with %.21f \n", r3_SU2);
+    } else {
+      printf("Error: didn't pass hermiticity test with %.21f \n", r3_SU2);
+      RETURNVALUE++;
+    }
+
+    printf("\n= Testing Gaugeinvariance =\n");
+    printf("Generating Random Gauge Transformation...\n");
+    // Use the normal GaugeField, because it can be initialised with random
+    // SU(3) matrices, however only use mu = 0
+    deviceGaugeField<4, 2> gaugeTrafo_SU2(L0, L1, L2, L3, random_pool, 1);
+    real_t norm_trafo_SU2 = spinor_norm_sq<4, 2, 4>(u_SU2);
+    // Dont know if this function is needed again, therefore only defined here,
+    // and not in an include file.
+    printf("Apply Gauge Trafos...\n");
+    tune_and_launch_for<4>(
+        "Gauge Trafo", IndexArray<4>{0, 0, 0, 0}, IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+#pragma unroll
+          for (size_t mu = 0; mu < 4; mu++) {
+            gauge_SU2(i0, i1, i2, i3, mu) =
+                gaugeTrafo_SU2(i0, i1, i2, i3, 1) *
+                gauge_SU2(i0, i1, i2, i3, mu) *
+                conj(gaugeTrafo_SU2(shift_index_plus<4, int>(
+                                        Kokkos::Array<int, 4>{i0, i1, i2, i3},
+                                        mu, 1, IndexArray<4>{L0, L1, L2, L3}),
+                                    1));
+          }
+          // Transform spinor u, and Mu
+          u_SU2(i0, i1, i2, i3) =
+              gaugeTrafo_SU2(i0, i1, i2, i3, 1) * u_SU2(i0, i1, i2, i3);
+          Mu_SU2(i0, i1, i2, i3) =
+              gaugeTrafo_SU2(i0, i1, i2, i3, 1) * Mu_SU2(i0, i1, i2, i3);
+        });
+    deviceSpinorField Mu_trafo_SU2 = D_SU2.applyD(u_SU2);
+    tune_and_launch_for<4>(
+        "Subtract Spinors", IndexArray<4>{0, 0, 0, 0},
+        IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+          Mu_SU2(i0, i1, i2, i3) -= Mu_trafo_SU2(i0, i1, i2, i3);
+        });
+    real_t norm_trafo1_SU2 = spinor_norm_sq<4, 2, 4>(Mu_SU2);
+    norm_trafo1_SU2 = Kokkos::sqrt(norm_trafo1_SU2 / norm_SU2);
+    if (norm_trafo1_SU2 < 1e-14) {
+      printf("Passed invariance test with %.21f \n", norm_trafo1_SU2);
+    } else {
+      printf("Error: didn't pass invariance test with %.21f \n",
+             norm_trafo1_SU2);
+      RETURNVALUE++;
+    }
+  }
+
+  {
+    printf("\n=== Testing DiracOperator U(1)  ===\n");
+    setVerbosity(5);
+    printf("%i", KLFT_VERBOSITY);
+    index_t L0 = 32, L1 = 32, L2 = 32, L3 = 32;
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    diracParams<4, 4> params(IndexArray<4>{L0, L1, L2, L3}, gammas, gamma5,
+                             0.5);
+    printf("Lattice Dimension %ix%ix%ix%i", L0, L1, L2, L3);
+    printf("\n= Testing hermiticity =\n");
+
+    printf("Generate SpinorFields...\n");
+
+    Kokkos::Random_XorShift64_Pool<> random_pool(/*seed=*/1234);
+    deviceSpinorField<1, 4> u_U1(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    deviceSpinorField<1, 4> v_U1(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    real_t norm_U1 = spinor_norm_sq<4, 1, 4>(u_U1);
+    norm_U1 *= spinor_norm_sq<4, 1, 4>(v_U1);
+    norm_U1 = Kokkos::sqrt(norm_U1);
+
+    printf("Generating Random Gauge Config\n");
+    deviceGaugeField<4, 1> gauge_U1(L0, L1, L2, L3, random_pool, 1);
+    printf("Instantiate DiracOperator...\n");
+    HWilsonDiracOperator<DeviceSpinorFieldType<4, 1, 4>,
+                         DeviceGaugeFieldType<4, 1>>
+        D_U1(gauge_U1, params);
+    printf("Apply DiracOperator...\n");
+
+    deviceSpinorField<1, 4> Mu_U1 = D_U1.applyDdagger(u_U1);
+    deviceSpinorField<1, 4> Mv_U1 = D_U1.applyD(v_U1);
+    // deviceSpinorField<3, 4> Mu = apply_D<4, 3, 4>(u, gauge, gammas, -0.5);
+    // deviceSpinorField<3, 4> Mv = apply_D<4, 3, 4>(v, gauge, gammas, -0.5);
+
+    printf("Calculate Scalarproducts...\n");
+    auto r1_U1 = spinor_dot_product<4, 1, 4>(u_U1, Mv_U1);
+    auto r2_U1 = spinor_dot_product<4, 1, 4>(Mu_U1, v_U1);
+
+    auto r_U1 = r1_U1 - r2_U1;
+
+    real_t r3_U1 =
+        Kokkos::sqrt(r_U1.real() * r_U1.real() + r_U1.imag() * r_U1.imag());
+    r3_U1 /= norm_U1;
+
+    if (r3_U1 < 1e-14) {
+      printf("Passed hermiticity test with %.21f \n", r3_U1);
+    } else {
+      printf("Error: didn't pass hermiticity test with %.21f \n", r3_U1);
+      RETURNVALUE++;
+    }
+
+    printf("\n= Testing Gaugeinvariance =\n");
+    printf("Generating Random Gauge Transformation...\n");
+    // Use the normal GaugeField, because it can be initialised with random
+    // SU(3) matrices, however only use mu = 0
+    deviceGaugeField<4, 1> gaugeTrafo_U1(L0, L1, L2, L3, random_pool, 1);
+    real_t norm_trafo_U1 = spinor_norm_sq<4, 1, 4>(u_U1);
+    // Dont know if this function is needed again, therefore only defined here,
+    // and not in an include file.
+    printf("Spinor before Gauge Trafo:\n");
+    // print_spinor(u_U1(0, 0, 0, 0));
+    printf("Apply Gauge Trafos...\n");
+    tune_and_launch_for<4>(
+        "Gauge Trafo", IndexArray<4>{0, 0, 0, 0}, IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+#pragma unroll
+          for (size_t mu = 0; mu < 4; mu++) {
+            gauge_U1(i0, i1, i2, i3, mu) =
+                gaugeTrafo_U1(i0, i1, i2, i3, 1) *
+                gauge_U1(i0, i1, i2, i3, mu) *
+                conj(gaugeTrafo_U1(shift_index_plus<4, int>(
+                                       Kokkos::Array<int, 4>{i0, i1, i2, i3},
+                                       mu, 1, IndexArray<4>{L0, L1, L2, L3}),
+                                   1));
+          }
+          // Transform spinor u, and Mu
+          u_U1(i0, i1, i2, i3) =
+              gaugeTrafo_U1(i0, i1, i2, i3, 1) * u_U1(i0, i1, i2, i3);
+          Mu_U1(i0, i1, i2, i3) =
+              gaugeTrafo_U1(i0, i1, i2, i3, 1) * Mu_U1(i0, i1, i2, i3);
+        });
+    printf("Spinor after Gauge Trafo:\n");
+    // print_spinor(u_U1(0, 0, 0, 0));
+    deviceSpinorField<1, 4> Mu_trafo_U1 = D_U1.applyD(u_U1);
+    tune_and_launch_for<4>(
+        "Subtract Spinors", IndexArray<4>{0, 0, 0, 0},
+        IndexArray<4>{L0, L1, L2, L3},
+        KOKKOS_LAMBDA(const index_t i0, const index_t i1, const index_t i2,
+                      const index_t i3) {
+          Mu_U1(i0, i1, i2, i3) -= Mu_trafo_U1(i0, i1, i2, i3);
+        });
+    real_t norm_trafo1_U1 = spinor_norm_sq<4, 1, 4>(Mu_U1);
+    norm_trafo1_U1 = Kokkos::sqrt(norm_trafo1_U1 / norm_U1);
+    if (norm_trafo1_U1 < 1e-14) {
+      printf("Passed invariance test with %.21f \n", norm_trafo1_U1);
+    } else {
+      printf("Error: didn't pass invariance test with %.21f \n",
+             norm_trafo1_U1);
+      RETURNVALUE++;
+    }
+  }
+
+  Kokkos::finalize();
+  printf(HLINE);
+  printf("%i Errors durring Testing\n", RETURNVALUE);
+  printf(HLINE);
+  RETURNVALUE = !(RETURNVALUE == 0);
+  return RETURNVALUE;
+}
diff --git a/tests/Fermions/test_Solver.cpp b/tests/Fermions/test_Solver.cpp
new file mode 100644
index 0000000..1a2a6b2
--- /dev/null
+++ b/tests/Fermions/test_Solver.cpp
@@ -0,0 +1,97 @@
+#include <getopt.h>
+
+#include <Kokkos_Complex.hpp>
+#include <Kokkos_Core.hpp>
+
+#include "../../include/GDiracOperator.hpp"
+#include "../../include/GammaMatrix.hpp"
+#include "../../include/Solver.hpp"
+#include "../../include/SpinorField.hpp"
+#include "GLOBAL.hpp"
+// #include "../../include/SpinorFieldLinAlg.hpp"
+#include "../../include/klft.hpp"
+#define HLINE "=========================================================\n"
+using namespace klft;
+template <size_t Nc, size_t Nd>
+void print_spinor(const Spinor<Nc, Nd>& s, const char* name = "Spinor") {
+  printf("%s:\n", name);
+  for (size_t c = 0; c < Nc; ++c) {
+    printf("  Color %zu:\n", c);
+    for (size_t d = 0; d < Nd; ++d) {
+      double re = s[c][d].real();
+      double im = s[c][d].imag();
+      printf("    [%zu] = (% .20f, % .20f i)\n", d, re, im);
+    }
+  }
+}
+int main(int argc, char* argv[]) {
+  Kokkos::initialize(argc, argv);
+  int RETURNVALUE = 0;
+  {
+    // timer
+    Kokkos::Timer timer;
+
+    real_t diracTime = std::numeric_limits<real_t>::max();
+    const int verbosity = std::getenv("KLFT_VERBOSITY")
+                              ? std::atoi(std::getenv("KLFT_VERBOSITY"))
+                              : 0;
+    setVerbosity(verbosity);
+    printf("%i", KLFT_VERBOSITY);
+    const size_t N = 3;
+    printf("\n=== Testing DiracOperator SU(%zu)  ===\n", N);
+    printf("\n= Testing hermiticity =\n");
+    index_t L0 = 32, L1 = 32, L2 = 32, L3 = 32;
+    auto gammas = get_gammas<4>();
+    GammaMat<4> gamma5 = get_gamma5();
+    IndexArray<4> dims = {L0, L1, L2, L3};
+    diracParams<4, 4> param(dims, gammas, gamma5, 0.01);
+
+    printf("Lattice Dimension %ix%ix%ix%i \n", L0, L1, L2, L3);
+    printf("Generate SpinorFields...\n");
+
+    Kokkos::Random_XorShift64_Pool<> random_pool(/*seed=*/1234);
+    deviceSpinorField<N, 4> u(L0, L1, L2, L3, random_pool, 0, 1.0 / 1.41);
+    deviceSpinorField<N, 4> x(L0, L1, L2, L3, complex_t(0.0, 0.0));
+    deviceSpinorField<N, 4> x0(L0, L1, L2, L3, complex_t(0.0, 0.0));
+    deviceGaugeField<4, N> gauge(L0, L1, L2, L3, random_pool, 1);
+    printf("Instantiate DiracOperator...\n");
+    HWilsonDiracOperator<DeviceSpinorFieldType<4, N, 4>,
+                         DeviceGaugeFieldType<4, N>>
+        D(gauge, param);
+    printf("Apply dirac Operator...\n");
+    // print_spinor(u(0, 0, 0, 0));
+    timer.reset();
+    auto test = D.applyDdagger(D.applyD(u));
+    auto diracTime1 = std::min(diracTime, timer.seconds());
+    printf("QQ^\\dagger Kernel Time:     %11.4e s\n", diracTime1);
+    // print_spinor(test(0, 0, 0, 0), "Spinor to solve before solving");
+    printf("Initialize Solver...\n");
+    CGSolver solver(test, x, D);
+    printf("Apply Solver...\n");
+    auto eps = 1e-13;
+    timer.reset();
+
+    solver.solve(x0, eps);
+    auto diracTime2 = std::min(diracTime, timer.seconds());
+    // print_spinor(test(0, 0, 0, 0), "Spinor to solve after solving");
+    printf("Solver Kernel Time:     %11.4e s\n", diracTime2);
+    printf("Comparing Solver result to expected result...\n");
+    // print_spinor<3, 4>(solver.x(0, 0, 0, 0) - u(0, 0, 0, 0), "Solver
+    // Result");
+    auto res_norm =
+        spinor_norm<4, N, 4>(spinor_sub_mul<4, N, 4>(u, solver.x, 1));
+    auto norm = spinor_norm<4, N, 4>(u);
+
+    printf("Norm of Residual: %.20f\n", res_norm / norm);
+    printf("Is the residual norm smaller than %.2e ? %i\n", eps,
+           res_norm / norm < eps);
+    // printf("i%i\n", solver.x(0, 0, 0, 0) == u(0, 0, 0, 0));
+  }
+
+  Kokkos::finalize();
+  printf(HLINE);
+  printf("%i Errors durring Testing\n", RETURNVALUE);
+  printf(HLINE);
+  RETURNVALUE = !(RETURNVALUE == 0);
+  return RETURNVALUE;
+}
\ No newline at end of file
diff --git a/tests/Fermions/test_SpinorFields.cpp b/tests/Fermions/test_SpinorFields.cpp
new file mode 100644
index 0000000..ce6e41b
--- /dev/null
+++ b/tests/Fermions/test_SpinorFields.cpp
@@ -0,0 +1,64 @@
+// test_deviceSpinorField.cpp
+#include <Kokkos_Complex.hpp>
+#include <Kokkos_Core.hpp>
+#include <iostream>
+
+// Include the header(s) that define the deviceSpinorField classes.
+// For example, if you have one header that collects all these definitions:
+// #include "deviceSpinorField.hpp"
+//
+// Otherwise, include each header as needed:
+#include "GLOBAL.hpp"
+// #include "FieldTypeHelper.hpp"
+#include "../../include/SpinorField.hpp"
+#include "../../include/SpinorFieldLinAlg.hpp"
+#include "../../include/klft.hpp"
+
+// We'll assume that our classes are in the klft namespace.
+using namespace klft;
+template <size_t Nc, size_t Nd>
+void print_spinor(const Spinor<Nc, Nd>& s, const char* name = "Spinor") {
+  printf("%s:\n", name);
+  for (size_t c = 0; c < Nc; ++c) {
+    printf("  Color %zu:\n", c);
+    for (size_t d = 0; d < Nd; ++d) {
+      double re = s[c][d].real();
+      double im = s[c][d].imag();
+      printf("    [%zu] = (% .6f, % .6f i)\n", d, re, im);
+    }
+  }
+}
+
+int main(int argc, char* argv[]) {
+  // Initialize Kokkos.
+  Kokkos::initialize(argc, argv);
+  {
+    setVerbosity(5);
+    std::cout << (KLFT_VERBOSITY);
+    std::cout << "\n=== Testing deviceSpinorField  ===\n";
+    // Dimensions for 4D field:
+    index_t L0 = 8, L1 = 8, L2 = 8, L3 = 8;
+    // Set an initial complex value (e.g., identity type if that makes sense,
+    // here use (1,0))
+    complex_t init_val(1.0, 0.0);
+
+    // Instantiate the spinor field with Nc = 3, DimRep=4 (for example)
+    deviceSpinorField<3, 4> spin(L0, L1, L2, L3, init_val);
+    Kokkos::fence();
+    print_spinor(spin(0, 0, 0, 0));
+    std::cout << "\n=== Testing deviceSpinorField with random normal "
+                 "distributed values  ===\n";
+
+    Kokkos::Random_XorShift64_Pool<> random_pool(/*seed=*/12345);
+    deviceSpinorField<3, 4> spinrand(L0, L1, L2, L3, random_pool, 0,
+                                     1.0 / 1.41);
+    print_spinor(spinrand(0, 0, 0, 0));
+    Kokkos::fence();
+    printf("\n=== Testing Spinor Dot Product  ===\n");
+    auto val = spinor_dot_product<4, 3, 4>(spin, spinrand);
+    Kokkos::fence();
+    printf("% .6f+ % .6f i\n", val.real(), val.imag());
+  }
+  Kokkos::finalize();
+  return 0;
+}
\ No newline at end of file
diff --git a/tests/Fermions/test_gamma_matricies.cpp b/tests/Fermions/test_gamma_matricies.cpp
new file mode 100644
index 0000000..a06bce3
--- /dev/null
+++ b/tests/Fermions/test_gamma_matricies.cpp
@@ -0,0 +1,63 @@
+#include <iomanip>
+#include <iostream>
+
+#include "../../include/GammaMatrix.hpp"
+
+using namespace klft;
+
+#define HLINE "=========================================================\n"
+template <size_t RepDim>
+void print_matrix(const GammaMat<RepDim> &mat) {
+  std::cout << std::fixed;
+  for (int i = 0; i < 4; ++i) {
+    std::cout << "[ ";
+    for (int j = 0; j < 4; ++j) {
+      const auto &val = mat(i, j);
+      std::cout << "(" << std::setw(6) << std::setprecision(2) << val.real()
+                << (val.imag() >= 0 ? "+" : "") << std::setw(6)
+                << std::setprecision(2) << val.imag() << "i) ";
+    }
+    std::cout << "]\n";
+  }
+  std::cout << "\n";
+}
+
+int main(int argc, char const *argv[]) {
+  std::cout << HLINE << "Testing Gamma matrices" << HLINE;
+  GammaMat<4> ggamma0 = get_gamma0();
+  GammaMat<4> ggamma1 = get_gamma1();
+  GammaMat<4> ggamma2 = get_gamma2();
+  GammaMat<4> ggamma3 = get_gamma3();
+  GammaMat<4> ggamma5 = get_gamma5();
+  const auto vec_gamma = get_gammas<4>();
+  // print_matrix(ggamma0 * ggamma3 + ggamma3 * ggamma0);
+  std::cout << "Gamma0:\n";
+  print_matrix(ggamma0);
+  std::cout << "Gamma1:\n";
+  print_matrix(ggamma1);
+  std::cout << "Gamma2:\n";
+  print_matrix(ggamma2);
+  std::cout << "Gamma3:\n";
+  print_matrix(ggamma3);
+  std::cout << "Gamma5 via multiplication:\n";
+  print_matrix(ggamma0 * ggamma1 * ggamma2 * ggamma3);
+  std::cout << "Gamma5:\n";
+  print_matrix(ggamma5);
+  std::cout << HLINE << "Testing Multiplication" << HLINE;
+  std::cout << "gamma0*Gamma1*gamma2*gamma3\n";
+  print_matrix(ggamma0 * ggamma1 * ggamma2 * ggamma3);
+  std::cout << "gamma0*Gamma1*gamma2*gamma3 == gamma5:\n";
+
+  std::cout << bool(ggamma0 * ggamma1 * ggamma2 * ggamma3 == ggamma5) << "\n";
+  std::cout << HLINE << "testing get_gammas\n" << HLINE;
+  std::cout << "Gamma0:\n";
+  std::cout << (vec_gamma[0] == ggamma0) << "\n";
+  std::cout << "Gamma1:\n";
+  std::cout << (vec_gamma[1] == ggamma1) << "\n";
+  std::cout << "Gamma2:\n";
+  std::cout << (vec_gamma[2] == ggamma2) << "\n";
+  std::cout << "Gamma3:\n";
+  std::cout << (vec_gamma[3] == ggamma3) << "\n";
+  /* code */
+  return 0;
+}
\ No newline at end of file
diff --git a/tests/Fermions/test_spinor.cpp b/tests/Fermions/test_spinor.cpp
new file mode 100644
index 0000000..1afac0e
--- /dev/null
+++ b/tests/Fermions/test_spinor.cpp
@@ -0,0 +1,68 @@
+#include <assert.h>
+
+#include <iomanip>
+
+#include "../../include/GammaMatrix.hpp"
+#include "GLOBAL.hpp"
+#include "IndexHelper.hpp"
+#include "Spinor.hpp"
+using namespace klft;
+
+#define HLINE "=========================================================\n"
+
+template <size_t Nc, size_t Nd>
+void print_spinor(const Spinor<Nc, Nd>& s, const char* name = "Spinor") {
+  printf("%s:\n", name);
+  for (size_t c = 0; c < Nc; ++c) {
+    printf("  Color %zu:\n", c);
+    for (size_t d = 0; d < Nd; ++d) {
+      double re = s[c][d].real();
+      double im = s[c][d].imag();
+      printf("    [%zu] = (% .6f, % .6f i)\n", d, re, im);
+    }
+  }
+}
+
+int main(int argc, char const* argv[]) {
+  printf(HLINE);
+  printf("Testing Spinor GammaMatrix interaction\n");
+  printf(HLINE);
+  printf("Instantiate One spinor\n");
+  auto ospinor = oneSpinor<3, 4>();
+  print_spinor(ospinor);
+  printf(HLINE);
+  printf("Instantiate zero Spinor\n");
+  auto zSpinor = zeroSpinor<3, 4>();
+  printf(HLINE);
+  printf("Testing Subtracting and Scalar multiplication:\n");
+  assert(0 * ospinor == zSpinor);
+  assert(zSpinor == ospinor - ospinor);
+  printf(HLINE);
+  printf("Testing scalar multiplication and addition\n");
+  print_spinor(2 * ospinor);
+  assert(2 * ospinor == ospinor + ospinor);
+  printf(HLINE);
+  printf(HLINE);
+  printf("Testing Gamma*Spinor: \n");
+  Spinor<3, 4> id = zeroSpinor<3, 4>();
+#pragma unroll
+  for (size_t i = 0; i < 3; ++i) {
+#pragma unroll
+    for (size_t j = 0; j < 4; ++j) {
+      id[i][j] = complex_t(i * 4 + j, 0.0);
+    }
+  }
+  get_gamma1();
+  assert(get_gamma5() * id ==
+         get_gamma0() * get_gamma1() * get_gamma2() * get_gamma3() * id);
+  printf(HLINE);
+  printf("Finished\n");
+  auto idx = IndexArray<4>{0, 3, 3, 1};
+  auto dim = IndexArray<4>{4, 4, 4, 4};
+  auto idx_new = shift_index_minus_bc(idx, 0, 1, 3, -1, dim);
+  printf("Shifted index: ");
+  printf("(%zu, %zu, %zu, %zu) with sign %f\n", idx_new.first[0],
+         idx_new.first[1], idx_new.first[2], idx_new.first[3], idx_new.second);
+  printf(HLINE);
+  return 0;
+}
\ No newline at end of file
diff --git a/tests/reversability_test.cpp b/tests/reversability_test.cpp
deleted file mode 100644
index 2030ec4..0000000
--- a/tests/reversability_test.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-#include "AdjointSUN.hpp"
-#include "FieldTypeHelper.hpp"
-#include "GLOBAL.hpp"
-#include "GaugeFieldHelper.hpp"
-#include "HMC.hpp"
-#include "HamiltonianField.hpp"
-#include "InputParser.hpp"
-#include "Integrator.hpp"
-#include "SimulationLogging.hpp"
-#include "UpdateMomentum.hpp"
-#include "UpdatePosition.hpp"
-#include <cassert>
-#include <cstddef>
-#include <getopt.h>
-#include <memory>
-
-using namespace klft;
-
-#include <Kokkos_Random.hpp>
-
-using RNGType = Kokkos::Random_XorShift64_Pool<Kokkos::DefaultExecutionSpace>;
-
-#define HLINE                                                                  \
-  "====================================================================\n"
-
-int parse_args(int argc, char **argv, std::string &input_file) {
-  // Defaults
-  input_file = "input.yaml";
-
-  const std::string help_string =
-      "  -f <file_name> --filename <file_name>\n"
-      "     Name of the input file.\n"
-      "     Default: input.yaml\n"
-      "  -h, --help\n"
-      "     Prints this message.\n"
-      "     Hint: use --kokkos-help to see command line options provided by "
-      "Kokkos.\n";
-
-  static struct option long_options[] = {
-      {"filename", required_argument, NULL, 'f'},
-      {"help", no_argument, NULL, 'h'},
-      {NULL, 0, NULL, 0}};
-
-  int c;
-  int option_index = 0;
-  while ((c = getopt_long(argc, argv, "f:h", long_options, &option_index)) !=
-         -1)
-    switch (c) {
-    case 'f':
-      input_file = optarg;
-      break;
-    case 'h':
-      printf("%s", help_string.c_str());
-      return -2;
-      break;
-    case 0:
-      break;
-    default:
-      printf("%s", help_string.c_str());
-      return -1;
-      break;
-    }
-  return 0;
-}
-
-// for now, the test only allows for Nd=4
-int main(int argc, char *argv[]) {
-  printf(HLINE);
-  printf("HMC for SU(N) gauge fields\n");
-  printf(HLINE);
-
-  const int verbosity = std::getenv("KLFT_VERBOSITY")
-                            ? std::atoi(std::getenv("KLFT_VERBOSITY"))
-                            : 0;
-  setVerbosity(verbosity);
-
-  Kokkos::initialize(argc, argv);
-  int rc;
-  std::string input_file;
-  rc = parse_args(argc, argv, input_file);
-  if (rc == 2) {
-    Kokkos::finalize();
-    return 0;
-  }
-  if (rc != 0) {
-    Kokkos::finalize();
-    return rc;
-  }
-
-  HMCParams hmcParams;
-  SimulationLoggingParams simLogParams;
-  GaugeObservableParams gaugeObsParams;
-  if (!parseInputFile(input_file, hmcParams)) {
-    printf("Error parsing input file\n");
-    return -1;
-  }
-  if (!parseInputFile(input_file, simLogParams)) {
-    printf("Error parsing input file\n");
-    return -1;
-  }
-  if (!parseInputFile(input_file, gaugeObsParams)) {
-    printf("Error parsing input file\n");
-    return -1;
-  }
-
-  constexpr const index_t Nd = 4;
-  const constexpr index_t Nc = 2;
-  assert(hmcParams.Ndims == 4 && hmcParams.Nc == 2);
-
-  if (Nd == 4 && Nc == 2) {
-
-    RNGType rng(hmcParams.seed);
-    using DGaugeFieldType = DeviceGaugeFieldType<Nd, Nc>;
-    using DAdjFieldType = DeviceAdjFieldType<Nd, Nc>;
-
-    typename DGaugeFieldType::type dev_g_SU2_4D(hmcParams.L0, hmcParams.L1,
-                                                hmcParams.L2, hmcParams.L3, rng,
-                                                hmcParams.rngDelta);
-    typename DAdjFieldType::type dev_a_SU2_4D(hmcParams.L0, hmcParams.L1,
-                                              hmcParams.L2, hmcParams.L3,
-                                              traceT(identitySUN<Nc>()));
-    using HField = HamiltonianField<DGaugeFieldType, DAdjFieldType>;
-    using Update_Q = UpdatePositionGauge<Nd, Nc>;
-    using Update_P = UpdateMomentumGauge<DGaugeFieldType, DAdjFieldType>;
-
-    HField hamiltonian_field = HField(dev_g_SU2_4D, dev_a_SU2_4D);
-    // after the move, the gauge and adjoint fields are no longer valid
-    const auto &dimensions = hamiltonian_field.gauge_field.dimensions;
-
-    Update_Q update_q(hamiltonian_field.gauge_field,
-                      hamiltonian_field.adjoint_field);
-    Update_P update_p(hamiltonian_field.gauge_field,
-                      hamiltonian_field.adjoint_field, hmcParams.beta);
-    // the integrate might need to be passed into the run_HMC as an argument as
-    // it contains a large amount of design decisions
-    std::shared_ptr<LeapFrog> leap_frog =
-        std::make_shared<LeapFrog>(hmcParams.nstepsGauge, true, nullptr,
-                                   std::make_shared<Update_Q>(update_q),
-                                   std::make_shared<Update_P>(update_p));
-
-    // now define and run the hmc
-    std::mt19937 mt(hmcParams.seed);
-    std::uniform_real_distribution<real_t> dist(0.0, 1.0);
-    using HMC = HMC<DGaugeFieldType, DAdjFieldType, RNGType>;
-    HMC hmc(hmcParams, hamiltonian_field, leap_frog, rng, dist, mt);
-    hmc.add_gauge_monomial(hmcParams.beta, 0);
-    hmc.add_kinetic_monomial(0);
-
-    // timer to measure the time per step
-    Kokkos::Timer timer;
-    bool accept;
-    real_t acc_sum{0.0};
-    real_t acc_rate{0.0};
-
-    for (size_t step = 0; step < hmcParams.nsteps; ++step) {
-
-      printf("tau: %f\n", hmcParams.tau);
-      timer.reset();
-      // perform hmc_step
-      accept = hmc.hmc_step();
-      const real_t time = timer.seconds();
-      acc_sum += static_cast<real_t>(accept);
-      acc_rate = acc_sum / static_cast<real_t>(step + 1);
-      if (KLFT_VERBOSITY > 0) {
-        printf("Step: %ld, accepted: %ld, Acceptance rate: %f, Time: %f\n",
-               step, static_cast<size_t>(accept), acc_rate, time);
-      }
-      measureGaugeObservables<Nd, Nc>(hamiltonian_field.gauge_field,
-                                      gaugeObsParams, step);
-      addLogData(simLogParams, step, hmc.delta_H, acc_rate, accept, time);
-
-      // printf("Reverse step with tau = -1\n");
-      // hmcParams.tau *= -1;
-      // printf("tau: %f\n", hmcParams.tau);
-      //
-      // timer.reset();
-      // // perform hmc_step
-      // accept = hmc.hmc_step(true);
-      // const real_t time1 = timer.seconds();
-      // acc_sum += static_cast<real_t>(accept);
-      // acc_rate = acc_sum / static_cast<real_t>(step + 1);
-      // if (KLFT_VERBOSITY > 0) {
-      //   printf(
-      //       "Reverse Step: %ld, accepted: %ld, Acceptance rate: %f, Time:
-      //       %f\n", step, static_cast<size_t>(accept), acc_rate, time);
-      // }
-      // addLogData(simLogParams, step, hmc.delta_H, acc_rate, accept, time);
-      // printf("resetting gauge to before reverse step\n");
-      // hmc.reset_gauge_field();
-      //
-      // hmcParams.tau *= -1;
-    }
-
-    flushAllGaugeObservables(gaugeObsParams);
-    flushSimulationLogs(simLogParams);
-  }
-  Kokkos::finalize();
-
-  return rc;
-}
